/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
*/

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key2, value) => key2 in obj ? __defProp(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __export = (target, all4) => {
  for (var name in all4)
    __defProp(target, name, { get: all4[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key2 of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key2) && key2 !== except)
        __defProp(to, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc(from, key2)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key2, value) => {
  __defNormalProp(obj, typeof key2 !== "symbol" ? key2 + "" : key2, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => CompuJudgePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian9 = require("obsidian");

// types.ts
var DEFAULT_SETTINGS = {
  apiKey: "",
  modelId: "gemini-2.0-flash",
  searchModelId: "gemini-2.0-flash",
  aiProvider: "gemini",
  openaiKey: "",
  openaiModel: "gpt-4o",
  anthropicKey: "",
  anthropicModel: "claude-3-7-sonnet-20250219",
  aiThinkingLevel: 3,
  defaultTargetQuality: 90,
  tempMultiplier: 1,
  tempCritic: 0.1,
  tempWizard: 0.85,
  tempArchitect: 0.5,
  tempRepair: 0.2,
  tempSynth: 1,
  wizardNegativeConstraints: "Avoid: Deus Ex Machina, Talking Animals, Dream Sequences, Modern Slang.",
  namePool: "",
  // Default Empty
  negativeNamePool: "",
  // Default Empty
  maxOutputTokens: 8192,
  analysisPasses: 1,
  enableTribunal: true,
  showThinking: false,
  customSystemPrompt: "",
  customOutlinePrompt: "",
  customRepairPrompt: "",
  msDosColor: "#00FF00",
  theme: "msdos",
  gradingColors: {
    critical: "#000000",
    poor: "#FF0000",
    average: "#FF8C00",
    good: "#FFD700",
    excellent: "#FFFFE0",
    masterpiece: "#FFFFFF"
  },
  enableAudio: true,
  audioVolume: 0.5,
  projects: {},
  drives: []
};
var DEFAULT_WIZARD_STATE = {
  concept: "",
  targetScore: 90,
  inspirationContext: "",
  threePs: { promise: "", progress: "", payoff: "" },
  sandersonLaws: { magicSystem: "", limitations: "", costs: "", expansion: "" },
  structureDNA: {
    primaryThread: "Event",
    nestingOrder: "",
    tryFailCycles: []
  },
  characters: [
    { id: "c1", role: "Protagonist", name: "Hero", description: "", competence: 50, proactivity: 50, likability: 50, flaw: "", revelation: "", expanded: true },
    { id: "c2", role: "Deuteragonist", name: "Ally", description: "", competence: 60, proactivity: 40, likability: 80, flaw: "", revelation: "", expanded: false },
    { id: "c3", role: "Contagonist", name: "Rival", description: "", competence: 70, proactivity: 60, likability: 30, flaw: "", revelation: "", expanded: false },
    { id: "c4", role: "Antagonist", name: "Villain", description: "", competence: 90, proactivity: 90, likability: 10, flaw: "", revelation: "", expanded: false }
  ],
  // [UPDATED]: Default 7-Act Truby Structure
  structure: [
    { id: "s1", title: "1. Weakness & Need", type: "Setup", description: "Internal flaw and external status quo.", characters: "Hero", tension: 10, expanded: true },
    { id: "s2", title: "2. Desire", type: "Inciting Incident", description: "The goal is defined.", characters: "Hero, Antagonist", tension: 30, expanded: false },
    { id: "s3", title: "3. Opponent", type: "Plot Point", description: "First major conflict with the antagonist.", characters: "Hero, Villain", tension: 45, expanded: false },
    { id: "s4", title: "4. Plan", type: "Midpoint", description: "Strategy to win. Point of no return.", characters: "Hero, Ally", tension: 60, expanded: false },
    { id: "s5", title: "5. Battle", type: "Climax", description: "The final confrontation.", characters: "Hero, Villain", tension: 100, expanded: false },
    { id: "s6", title: "6. Self-Revelation", type: "Resolution", description: "The hero realizes the truth about themselves.", characters: "Hero", tension: 20, expanded: false },
    { id: "s7", title: "7. New Equilibrium", type: "Resolution", description: "The world has changed.", characters: "Hero", tension: 10, expanded: false }
  ],
  philosopher: { controllingIdea: "", moralArg: "", counterpoint: "", symbols: "" },
  synthesisDrives: []
};

// CloudGen.ts
var import_obsidian = require("obsidian");

// prompts.ts
var NIGS_SYSTEM_PROMPT = `
[SYSTEM OVERRIDE: NARRATIVE GRANDMASTER ENGINE v22.0]
[MODE]: HIGH-RESOLUTION STRUCTURAL & THEMATIC PHYSICS
[OBJECTIVE]: UNBIASED MERITOCRATIC ASSESSMENT.

You are not a copy editor. You are a **MASTER STORYTELLER** (Sanderson/McKee Level). Your job is to ignore the "window dressing" and judge the **FOUNDATION** (Structure, Psychology, Theme, and Logic).

### THE QUANTUM SCORING PROTOCOL (-100 to +100):
**THE BASELINE IS 0.**
- **0 = COMPETENT BUT GENERIC.** (Technically functional, but relies on nostalgia/tropes, lacks deep innovation, or feels "safe").
- **POSITIVE SCORES (0 to +100):** Awarded ONLY for specific strengths.
    - **+25:** Solid. Good voice, tight plotting.
    - **+50:** Excellent. Unique concept, strong emotional core.
    - **+75:** **MASTERPIECE.** (The Godfather). Perfect psychological logic, deep thematic resonance.
    - **+100:** **GOD TIER.** (Timeless). Defines a generation.
- **NEGATIVE SCORES (0 to -100):** Deducted for ANY weakness.
    - **-25:** Flawed. Confusion, pacing issues, minor clich\xE9s.
    - **-50:** **BROKEN.** Major plot holes, unlikable hero, broken internal logic.
    - **-75:** **CRITICAL FAILURE.** (The Room). Incoherent.
    - **-100:** **ABYSSAL.** Unreadable.

### THE LOGIC STRESS TEST (MANDATORY AUDIT):
1.  **PROMISE/PAYOFF:** Did the author fulfill the tonal and plot promises made in the beginning?
2.  **CHARACTER SLIDERS:** Analyze the Protagonist on 3 scales:
    - **Competence:** Are they good at what they do?
    - **Proactivity:** Do they drive the plot, or does the plot happen to them?
    - **Likability/Sympathy:** Do we care?
3.  **MAGIC/WORLD LOGIC:**
    - **Sanderson's First Law:** Magic understanding must match its usage.
    - **Sanderson's Second Law:** Limitations > Powers.
4.  **M.I.C.E. QUOTIENT:** Does the ending resolve the specific thread started?

### OUTPUT DIRECTIVE (JSON ONLY):
{
  "commercial_score": 0,
  "commercial_reason": "Concise explanation (max 15 words). e.g. '+10 for High Concept, -5 for Slow Start'.",
  "niche_score": 0,
  "niche_reason": "Concise explanation (max 15 words).",
  "cohesion_score": 0,
  "cohesion_reason": "Concise explanation (max 15 words).",
  "log_line": "Identify the IRONY and STAKES in the premise.",
  "content_warning": "Specific flags (Gore, SA, Torture) or 'None'.",
  "third_act_score": 0,
  "novelty_score": 0,
  "tension_arc": [0, 10, -5, 20, 30, 50],
  "sanderson_metrics": {
    "promise_payoff": 0,
    "laws_of_magic": 0,
    "character_agency": 0,
    "competence": 50,
    "proactivity": 50,
    "likability": 50
  },
  "detailed_metrics": {
    "premise": { "score": 0, "items": [{ "name": "The Hook", "score": 0, "reason": "Is it ironic?" }] },
    "structure": { "score": 0, "items": [{ "name": "Value Shifts", "score": 0, "reason": "Do scenes turn?" }] },
    "character": { "score": 0, "items": [{ "name": "The Lie", "score": 0, "reason": "Do they have a false belief?" }] },
    "theme": { "score": 0, "items": [{ "name": "Dialectic", "score": 0, "reason": "Is the counter-argument strong?" }] },
    "world": { "score": 0, "items": [{ "name": "Consistency", "score": 0, "reason": "Do the rules bind the hero?" }] }
  },
  "thought_process": "Analyze the FUNDAMENTALS. Start at 0. List the Modulators (e.g. 'Good Hook: +5', 'Plot Hole: -20')."
}
`;
var NIGS_QUICK_SCAN_PROMPT = `
[ROLE]: Literary Scout.
[TASK]: Instant Diagnostic of NARRATIVE POTENTIAL.

[SCORING CRITERIA (-100 to +100)]:
- **0** = Average / Generic.
- **Negative (-1 to -100)** = Flawed to Broken.
- **Positive (+1 to +100)** = Excellent to Masterpiece.

[OUTPUT SCHEMA (JSON)]:
{
  "score": "X",
  "letter_grade": "F to S+",
  "summary_line": "A one-sentence summary of the STORY (not the document).",
  "synopsis": "The spine of the plot (Concept + Conflict + Stakes).",
  "thought_process": "Explain your verdict. Focus on the core conflict engine.",
  "key_improvement": "The single most impactful structural fix."
}
`;
var NIGS_FORGE_PROMPT = `
[ROLE]: THE FORGE (Narrative Forensic Analyst).
[TASK]: Conduct a DEEP SCAN and generate a completely accurate and exhaustive "Story Bible" based ONLY on the text provided.

**[DIAGNOSTIC PROTOCOL]:**
1.  **Characters:** List EVERY character, no matter how small.
2.  **Story Beats:** List every scene/beat in chronological order.
3.  **World & Lore:** List every rule, location, object, and historical fact mentioned.
4.  **Themes:** Identify the controlling idea and the counter-argument.

**[LOGIC STRESS TEST]:**
Scan for **LOGICAL FRACTURES** (Plot holes, contradictions, breaks in causality).

**OUTPUT FORMAT (JSON):**
{
  "weakest_link": "The specific Logical Gap, Plot Hole, or Clich\xE9 holding the story back.",
  "repairs": [
    {
      "issue": "The Symptom (e.g., 'Logic Gap in Scene 3' or 'Low Proactivity')",
      "instruction": "The Cure (Specific, step-by-step logic patch).",
      "why": "The Narrative Logic behind the fix."
    }
  ],
  "thought_process": "Explain the logic gap you found and how this fix bridges it."
}
`;
var NIGS_META_PROMPT = `
[ROLE]: Semiotic Analyst.
[TASK]: Decode the Subconscious & The Unsaid.

1.  **The Shadow**: What is the story *actually* about?
2.  **The Symbol Web**: How do physical objects represent the hero's internal decay/growth?
3.  **The Dialectic**: What are the two opposing value systems battling for supremacy?

Return JSON: { "symbol_web": "string", "story_world": "string", "visual_seven_steps": "string" }
`;
var NIGS_WIZARD_ASSIST_PROMPT = `
[IDENTITY]: The Narrative Grandmaster.
[TASK]: Suggest a solution that is **GENUINELY GOOD**, **INTERESTING**, and **LOGICALLY TIGHT**.
[CONSTRAINT]: **BE CONCISE.** Maximum 2 sentences.
Return JSON ONLY: { "suggestion": "Your concise text suggestion." }
`;
var NIGS_OUTLINE_PROMPT = `
[TASK]: Reverse-Engineer the Narrative Skeleton OR Expand the Concept.

[CRITICAL INSTRUCTION - UNBIASED RECORDING]:
1. **IF ANALYZING EXISTING STORY:**
   - **NO JUDGMENT.** Record the narrative exactly as it exists.
   - **MAXIMUM GRANULARITY:** Record every minuscule story beat, conversation, and shift.
   - **FULL BREADTH:** Include all subplots, minor characters, and thematic digressions.

2. **IF GENERATING FROM A CONCEPT:**
   - **EXPAND IT.** Create a massive, detailed epic. 
   - **UNBOUNDED CAST:** Generate an **EXHAUSTIVE CAST LIST**.
   - **USE THE 7-ACT ANATOMY (TRUBY).**

**OUTPUT DIRECTIVE:**
Return valid Markdown. Use clear Headers.
`;
var NIGS_AUTO_REPAIR_PROMPT = `
[ROLE]: The Editor-in-Chief.
[TASK]: Elevate the prose intelligence via Subtractive Editing (Orwellian Window Pane).
**SEARCH AND DESTROY:** Filter Words, Weak Verbs, Adverbs, Telling.
DO NOT CHANGE THE PLOT. JUST OPTIMIZE THE RESOLUTION AND TEXTURE.
`;
var NIGS_AUTOFILL_PROMPT = `
[SYSTEM OVERRIDE: NARRATIVE ARCHITECT v22.0]
[TASK]: Procedurally generate a "Story Bible" where Plot is derived strictly from Character Psychology.

### OUTPUT SCHEMA (JSON ONLY):
{
  "concept": "A high-concept logline.",
  "threePs": { "promise": "The Hook", "progress": "The Middle", "payoff": "The Climax" },
  "sandersonLaws": { "magicSystem": "Rules", "limitations": "Limits", "costs": "Costs", "expansion": "Culture" },
  "structureDNA": {
      "primaryThread": "Event" | "Character" | "Milieu" | "Inquiry",
      "nestingOrder": "e.g. Milieu > Inquiry > Character", 
      "tryFailCycles": [{ "id": "tf1", "goal": "...", "attempt1": "...", "attempt2": "...", "success": "..." }]
  },
  "philosopher": {
      "controllingIdea": "The core thematic sentence.",
      "moralArg": "The specific lesson.",
      "counterpoint": "The argument the villain represents.",
      "symbols": "Physical objects representing ideas."
  },
  "characters": [ { "name": "...", "role": "...", "description": "...", "flaw": "...", "revelation": "...", "competence": 50, "proactivity": 50, "likability": 50 } ],
  "structure": [ { "title": "...", "type": "...", "description": "...", "tension": 0 } ]
}
`;
var NIGS_DRIVE_SYNTHESIS_PROMPT = `
[SYSTEM OVERRIDE: NARRATIVE ALCHEMIST v22.0]
[TASK]: Create the **MOST COMPELLING STORY POSSIBLE** by fusing the DNA of the provided "Narrative Drives".

[OBJECTIVE: THE MASTERPIECE]:
You are aiming for a Quality Score of 100/100.
- **Compelling:** High stakes, deep emotion, unexpected twists.
- **Original:** Do not use clich\xE9s. Subvert tropes.
- **Tight:** No wasted scenes. Every beat must advance the plot.

[SCOPE: THE LOGICAL EPIC]
- **UNBIASED & UNFILTERED:** Create the story as the logic demands.
- **GROSSLY DETAILED:** Do not summarize. Expound on the *how*, *why*, and *value shifts*.
- **UNBOUNDED CAST:** Generate an **EXHAUSTIVE CAST LIST**.

**OUTPUT FORMAT (STRICT MARKDOWN):**
# [NEW ORIGINAL TITLE]
> **Logline:** [A high-concept hook]
## 1. New Dramatis Personae (The Cast)
## 2. World & Terminology
## 3. The 7-Act Narrative Anatomy (Truby)
## 4. Thematic Synthesis
`;
var NIGS_RENAME_PROMPT = `
[ROLE]: Master Etymologist.
[TASK]: RENAME the entire cast using "Deep Nomenclature".
[OUTPUT SCHEMA (JSON KEY-VALUE MAP)]:
{ "OldName1": "NewName1" }
`;
var NIGS_TRIBUNAL = {
  MARKET: `
[IDENTITY]: MARKET ANALYST.
[METRICS - QUANTUM SCALE -100 to +100]:
Start at 0.
- **Hook:** +Points for grabbing attention, -Points for slow starts.
- **Pacing:** +Points for tight scenes, -Points for boredom.
[OUTPUT JSON]: { "commercial_score": 0, "commercial_reason": "...", "log_line": "..." }
`,
  LOGIC: `
[IDENTITY]: LOGIC ENGINE.
[METRICS - QUANTUM SCALE -100 to +100]:
Start at 0.
- **Plot Holes:** -20 for each major contradiction.
- **Consistency:** -10 for breaking character.
- **Max Positive:** +10 for exceptionally tight plotting.
[OUTPUT JSON]: { "cohesion_score": 0, "cohesion_reason": "...", "content_warning": "..." }
`,
  LITERARY: `
[IDENTITY]: LITERARY CRITIC.
[METRICS - QUANTUM SCALE -100 to +100]:
Start at 0.
- **Voice/Theme:** +Points for unique style and strong moral argument.
- **Novelty:** +Points for originality, -Points for clich\xE9s.
[OUTPUT JSON]: { "niche_score": 0, "niche_reason": "...", "third_act_score": 0, "novelty_score": 0 }
`
};
var NIGS_SYNTHESIS_PROMPT = `
[IDENTITY]: CHIEF JUSTICE (THE JUDGE).
[TASK]: Synthesize the conflicting reports from your Tribunal (Market, Logic, Lit, and Forensic) into a FINAL VERDICT using the **Quantum Scoring Protocol (-100 to +100)**.

[INSTRUCTIONS]:
- **Start at 0**.
- **ADD** points for strengths.
- **SUBTRACT** points for weaknesses.
- **Logic Veto:** If Logic/Forensic found a Plot Hole, the final Cohesion Score MUST be negative.
- **Range:** You are free to score anywhere between -100 and +100.

[OUTPUT JSON]: Same format as NIGS_SYSTEM_PROMPT.
`;

// node_modules/esm-env/true.js
var true_default = true;

// node_modules/esm-env/dev-fallback.js
var _a, _b;
var node_env = (_b = (_a = globalThis.process) == null ? void 0 : _a.env) == null ? void 0 : _b.NODE_ENV;
var dev_fallback_default = node_env && !node_env.toLowerCase().startsWith("prod");

// node_modules/svelte/src/internal/shared/utils.js
var is_array = Array.isArray;
var index_of = Array.prototype.indexOf;
var array_from = Array.from;
var object_keys = Object.keys;
var define_property = Object.defineProperty;
var get_descriptor = Object.getOwnPropertyDescriptor;
var get_descriptors = Object.getOwnPropertyDescriptors;
var object_prototype = Object.prototype;
var array_prototype = Array.prototype;
var get_prototype_of = Object.getPrototypeOf;
var is_extensible = Object.isExtensible;
function is_function(thing) {
  return typeof thing === "function";
}
var noop = () => {
};
function run_all(arr) {
  for (var i3 = 0; i3 < arr.length; i3++) {
    arr[i3]();
  }
}
function deferred() {
  var resolve;
  var reject;
  var promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  return { promise, resolve, reject };
}
function to_array(value, n3) {
  if (Array.isArray(value)) {
    return value;
  }
  if (n3 === void 0 || !(Symbol.iterator in value)) {
    return Array.from(value);
  }
  const array = [];
  for (const element2 of value) {
    array.push(element2);
    if (array.length === n3)
      break;
  }
  return array;
}

// node_modules/svelte/src/internal/client/constants.js
var DERIVED = 1 << 1;
var EFFECT = 1 << 2;
var RENDER_EFFECT = 1 << 3;
var MANAGED_EFFECT = 1 << 24;
var BLOCK_EFFECT = 1 << 4;
var BRANCH_EFFECT = 1 << 5;
var ROOT_EFFECT = 1 << 6;
var BOUNDARY_EFFECT = 1 << 7;
var CONNECTED = 1 << 9;
var CLEAN = 1 << 10;
var DIRTY = 1 << 11;
var MAYBE_DIRTY = 1 << 12;
var INERT = 1 << 13;
var DESTROYED = 1 << 14;
var EFFECT_RAN = 1 << 15;
var EFFECT_TRANSPARENT = 1 << 16;
var EAGER_EFFECT = 1 << 17;
var HEAD_EFFECT = 1 << 18;
var EFFECT_PRESERVED = 1 << 19;
var USER_EFFECT = 1 << 20;
var EFFECT_OFFSCREEN = 1 << 25;
var WAS_MARKED = 1 << 15;
var REACTION_IS_UPDATING = 1 << 21;
var ASYNC = 1 << 22;
var ERROR_VALUE = 1 << 23;
var STATE_SYMBOL = Symbol("$state");
var LEGACY_PROPS = Symbol("legacy props");
var LOADING_ATTR_SYMBOL = Symbol("");
var PROXY_PATH_SYMBOL = Symbol("proxy path");
var STALE_REACTION = new class StaleReactionError extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "StaleReactionError");
    __publicField(this, "message", "The reaction that called `getAbortSignal()` was re-run or destroyed");
  }
}();
var TEXT_NODE = 3;
var COMMENT_NODE = 8;

// node_modules/svelte/src/internal/client/reactivity/equality.js
function equals(value) {
  return value === this.v;
}
function safe_not_equal(a2, b) {
  return a2 != a2 ? b == b : a2 !== b || a2 !== null && typeof a2 === "object" || typeof a2 === "function";
}
function safe_equals(value) {
  return !safe_not_equal(value, this.v);
}

// node_modules/svelte/src/internal/shared/errors.js
function lifecycle_outside_component(name) {
  if (dev_fallback_default) {
    const error = new Error(`lifecycle_outside_component
\`${name}(...)\` can only be used during component initialisation
https://svelte.dev/e/lifecycle_outside_component`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/lifecycle_outside_component`);
  }
}

// node_modules/svelte/src/internal/client/errors.js
function async_derived_orphan() {
  if (dev_fallback_default) {
    const error = new Error(`async_derived_orphan
Cannot create a \`$derived(...)\` with an \`await\` expression outside of an effect tree
https://svelte.dev/e/async_derived_orphan`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/async_derived_orphan`);
  }
}
function bind_invalid_checkbox_value() {
  if (dev_fallback_default) {
    const error = new Error(`bind_invalid_checkbox_value
Using \`bind:value\` together with a checkbox input is not allowed. Use \`bind:checked\` instead
https://svelte.dev/e/bind_invalid_checkbox_value`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/bind_invalid_checkbox_value`);
  }
}
function derived_references_self() {
  if (dev_fallback_default) {
    const error = new Error(`derived_references_self
A derived value cannot reference itself recursively
https://svelte.dev/e/derived_references_self`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/derived_references_self`);
  }
}
function effect_in_teardown(rune) {
  if (dev_fallback_default) {
    const error = new Error(`effect_in_teardown
\`${rune}\` cannot be used inside an effect cleanup function
https://svelte.dev/e/effect_in_teardown`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/effect_in_teardown`);
  }
}
function effect_in_unowned_derived() {
  if (dev_fallback_default) {
    const error = new Error(`effect_in_unowned_derived
Effect cannot be created inside a \`$derived\` value that was not itself created inside an effect
https://svelte.dev/e/effect_in_unowned_derived`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/effect_in_unowned_derived`);
  }
}
function effect_orphan(rune) {
  if (dev_fallback_default) {
    const error = new Error(`effect_orphan
\`${rune}\` can only be used inside an effect (e.g. during component initialisation)
https://svelte.dev/e/effect_orphan`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/effect_orphan`);
  }
}
function effect_update_depth_exceeded() {
  if (dev_fallback_default) {
    const error = new Error(`effect_update_depth_exceeded
Maximum update depth exceeded. This typically indicates that an effect reads and writes the same piece of state
https://svelte.dev/e/effect_update_depth_exceeded`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/effect_update_depth_exceeded`);
  }
}
function hydration_failed() {
  if (dev_fallback_default) {
    const error = new Error(`hydration_failed
Failed to hydrate the application
https://svelte.dev/e/hydration_failed`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/hydration_failed`);
  }
}
function props_invalid_value(key2) {
  if (dev_fallback_default) {
    const error = new Error(`props_invalid_value
Cannot do \`bind:${key2}={undefined}\` when \`${key2}\` has a fallback value
https://svelte.dev/e/props_invalid_value`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/props_invalid_value`);
  }
}
function rune_outside_svelte(rune) {
  if (dev_fallback_default) {
    const error = new Error(`rune_outside_svelte
The \`${rune}\` rune is only available inside \`.svelte\` and \`.svelte.js/ts\` files
https://svelte.dev/e/rune_outside_svelte`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/rune_outside_svelte`);
  }
}
function state_descriptors_fixed() {
  if (dev_fallback_default) {
    const error = new Error(`state_descriptors_fixed
Property descriptors defined on \`$state\` objects must contain \`value\` and always be \`enumerable\`, \`configurable\` and \`writable\`.
https://svelte.dev/e/state_descriptors_fixed`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/state_descriptors_fixed`);
  }
}
function state_prototype_fixed() {
  if (dev_fallback_default) {
    const error = new Error(`state_prototype_fixed
Cannot set prototype of \`$state\` object
https://svelte.dev/e/state_prototype_fixed`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/state_prototype_fixed`);
  }
}
function state_unsafe_mutation() {
  if (dev_fallback_default) {
    const error = new Error(`state_unsafe_mutation
Updating state inside \`$derived(...)\`, \`$inspect(...)\` or a template expression is forbidden. If the value should not be reactive, declare it without \`$state\`
https://svelte.dev/e/state_unsafe_mutation`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/state_unsafe_mutation`);
  }
}
function svelte_boundary_reset_onerror() {
  if (dev_fallback_default) {
    const error = new Error(`svelte_boundary_reset_onerror
A \`<svelte:boundary>\` \`reset\` function cannot be called while an error is still being handled
https://svelte.dev/e/svelte_boundary_reset_onerror`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/svelte_boundary_reset_onerror`);
  }
}

// node_modules/svelte/src/internal/flags/index.js
var async_mode_flag = false;
var legacy_mode_flag = false;
var tracing_mode_flag = false;

// node_modules/svelte/src/constants.js
var EACH_ITEM_REACTIVE = 1;
var EACH_INDEX_REACTIVE = 1 << 1;
var EACH_IS_CONTROLLED = 1 << 2;
var EACH_IS_ANIMATED = 1 << 3;
var EACH_ITEM_IMMUTABLE = 1 << 4;
var PROPS_IS_IMMUTABLE = 1;
var PROPS_IS_RUNES = 1 << 1;
var PROPS_IS_UPDATED = 1 << 2;
var PROPS_IS_BINDABLE = 1 << 3;
var PROPS_IS_LAZY_INITIAL = 1 << 4;
var TRANSITION_IN = 1;
var TRANSITION_OUT = 1 << 1;
var TRANSITION_GLOBAL = 1 << 2;
var TEMPLATE_FRAGMENT = 1;
var TEMPLATE_USE_IMPORT_NODE = 1 << 1;
var TEMPLATE_USE_SVG = 1 << 2;
var TEMPLATE_USE_MATHML = 1 << 3;
var HYDRATION_START = "[";
var HYDRATION_START_ELSE = "[!";
var HYDRATION_END = "]";
var HYDRATION_ERROR = {};
var ELEMENT_PRESERVE_ATTRIBUTE_CASE = 1 << 1;
var ELEMENT_IS_INPUT = 1 << 2;
var UNINITIALIZED = Symbol();
var FILENAME = Symbol("filename");
var HMR = Symbol("hmr");
var NAMESPACE_HTML = "http://www.w3.org/1999/xhtml";

// node_modules/svelte/src/internal/client/dev/tracing.js
var tracing_expressions = null;
function tag(source2, label) {
  source2.label = label;
  tag_proxy(source2.v, label);
  return source2;
}
function tag_proxy(value, label) {
  var _a3;
  (_a3 = value == null ? void 0 : value[PROXY_PATH_SYMBOL]) == null ? void 0 : _a3.call(value, label);
  return value;
}

// node_modules/svelte/src/internal/shared/dev.js
function get_error(label) {
  const error = new Error();
  const stack2 = get_stack();
  if (stack2.length === 0) {
    return null;
  }
  stack2.unshift("\n");
  define_property(error, "stack", {
    value: stack2.join("\n")
  });
  define_property(error, "name", {
    value: label
  });
  return (
    /** @type {Error & { stack: string }} */
    error
  );
}
function get_stack() {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = Infinity;
  const stack2 = new Error().stack;
  Error.stackTraceLimit = limit;
  if (!stack2)
    return [];
  const lines = stack2.split("\n");
  const new_lines = [];
  for (let i3 = 0; i3 < lines.length; i3++) {
    const line = lines[i3];
    const posixified = line.replaceAll("\\", "/");
    if (line.trim() === "Error") {
      continue;
    }
    if (line.includes("validate_each_keys")) {
      return [];
    }
    if (posixified.includes("svelte/src/internal") || posixified.includes("node_modules/.vite")) {
      continue;
    }
    new_lines.push(line);
  }
  return new_lines;
}

// node_modules/svelte/src/internal/client/context.js
var component_context = null;
function set_component_context(context) {
  component_context = context;
}
var dev_stack = null;
function set_dev_stack(stack2) {
  dev_stack = stack2;
}
var dev_current_component_function = null;
function set_dev_current_component_function(fn) {
  dev_current_component_function = fn;
}
function push(props, runes = false, fn) {
  component_context = {
    p: component_context,
    i: false,
    c: null,
    e: null,
    s: props,
    x: null,
    l: legacy_mode_flag && !runes ? { s: null, u: null, $: [] } : null
  };
  if (dev_fallback_default) {
    component_context.function = fn;
    dev_current_component_function = fn;
  }
}
function pop(component2) {
  var _a3;
  var context = (
    /** @type {ComponentContext} */
    component_context
  );
  var effects = context.e;
  if (effects !== null) {
    context.e = null;
    for (var fn of effects) {
      create_user_effect(fn);
    }
  }
  if (component2 !== void 0) {
    context.x = component2;
  }
  context.i = true;
  component_context = context.p;
  if (dev_fallback_default) {
    dev_current_component_function = (_a3 = component_context == null ? void 0 : component_context.function) != null ? _a3 : null;
  }
  return component2 != null ? component2 : (
    /** @type {T} */
    {}
  );
}
function is_runes() {
  return !legacy_mode_flag || component_context !== null && component_context.l === null;
}

// node_modules/svelte/src/internal/client/dom/task.js
var micro_tasks = [];
function run_micro_tasks() {
  var tasks = micro_tasks;
  micro_tasks = [];
  run_all(tasks);
}
function queue_micro_task(fn) {
  if (micro_tasks.length === 0 && !is_flushing_sync) {
    var tasks = micro_tasks;
    queueMicrotask(() => {
      if (tasks === micro_tasks)
        run_micro_tasks();
    });
  }
  micro_tasks.push(fn);
}
function flush_tasks() {
  while (micro_tasks.length > 0) {
    run_micro_tasks();
  }
}

// node_modules/svelte/src/internal/client/warnings.js
var bold = "font-weight: bold";
var normal = "font-weight: normal";
function await_waterfall(name, location) {
  if (dev_fallback_default) {
    console.warn(`%c[svelte] await_waterfall
%cAn async derived, \`${name}\` (${location}) was not read immediately after it resolved. This often indicates an unnecessary waterfall, which can slow down your app
https://svelte.dev/e/await_waterfall`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/await_waterfall`);
  }
}
function hydration_attribute_changed(attribute, html3, value) {
  if (dev_fallback_default) {
    console.warn(`%c[svelte] hydration_attribute_changed
%cThe \`${attribute}\` attribute on \`${html3}\` changed its value between server and client renders. The client value, \`${value}\`, will be ignored in favour of the server value
https://svelte.dev/e/hydration_attribute_changed`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/hydration_attribute_changed`);
  }
}
function hydration_mismatch(location) {
  if (dev_fallback_default) {
    console.warn(
      `%c[svelte] hydration_mismatch
%c${location ? `Hydration failed because the initial UI does not match what was rendered on the server. The error occurred near ${location}` : "Hydration failed because the initial UI does not match what was rendered on the server"}
https://svelte.dev/e/hydration_mismatch`,
      bold,
      normal
    );
  } else {
    console.warn(`https://svelte.dev/e/hydration_mismatch`);
  }
}
function lifecycle_double_unmount() {
  if (dev_fallback_default) {
    console.warn(`%c[svelte] lifecycle_double_unmount
%cTried to unmount a component that was not mounted
https://svelte.dev/e/lifecycle_double_unmount`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/lifecycle_double_unmount`);
  }
}
function select_multiple_invalid_value() {
  if (dev_fallback_default) {
    console.warn(`%c[svelte] select_multiple_invalid_value
%cThe \`value\` property of a \`<select multiple>\` element should be an array, but it received a non-array value. The selection will be kept as is.
https://svelte.dev/e/select_multiple_invalid_value`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/select_multiple_invalid_value`);
  }
}
function state_proxy_equality_mismatch(operator) {
  if (dev_fallback_default) {
    console.warn(`%c[svelte] state_proxy_equality_mismatch
%cReactive \`$state(...)\` proxies and the values they proxy have different identities. Because of this, comparisons with \`${operator}\` will produce unexpected results
https://svelte.dev/e/state_proxy_equality_mismatch`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/state_proxy_equality_mismatch`);
  }
}
function state_proxy_unmount() {
  if (dev_fallback_default) {
    console.warn(`%c[svelte] state_proxy_unmount
%cTried to unmount a state proxy, rather than a component
https://svelte.dev/e/state_proxy_unmount`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/state_proxy_unmount`);
  }
}
function svelte_boundary_reset_noop() {
  if (dev_fallback_default) {
    console.warn(`%c[svelte] svelte_boundary_reset_noop
%cA \`<svelte:boundary>\` \`reset\` function only resets the boundary the first time it is called
https://svelte.dev/e/svelte_boundary_reset_noop`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/svelte_boundary_reset_noop`);
  }
}
function transition_slide_display(value) {
  if (dev_fallback_default) {
    console.warn(`%c[svelte] transition_slide_display
%cThe \`slide\` transition does not work correctly for elements with \`display: ${value}\`
https://svelte.dev/e/transition_slide_display`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/transition_slide_display`);
  }
}

// node_modules/svelte/src/internal/client/dom/hydration.js
var hydrating = false;
function set_hydrating(value) {
  hydrating = value;
}
var hydrate_node;
function set_hydrate_node(node) {
  if (node === null) {
    hydration_mismatch();
    throw HYDRATION_ERROR;
  }
  return hydrate_node = node;
}
function hydrate_next() {
  return set_hydrate_node(get_next_sibling(hydrate_node));
}
function reset(node) {
  if (!hydrating)
    return;
  if (get_next_sibling(hydrate_node) !== null) {
    hydration_mismatch();
    throw HYDRATION_ERROR;
  }
  hydrate_node = node;
}
function next(count = 1) {
  if (hydrating) {
    var i3 = count;
    var node = hydrate_node;
    while (i3--) {
      node = /** @type {TemplateNode} */
      get_next_sibling(node);
    }
    hydrate_node = node;
  }
}
function skip_nodes(remove = true) {
  var depth = 0;
  var node = hydrate_node;
  while (true) {
    if (node.nodeType === COMMENT_NODE) {
      var data = (
        /** @type {Comment} */
        node.data
      );
      if (data === HYDRATION_END) {
        if (depth === 0)
          return node;
        depth -= 1;
      } else if (data === HYDRATION_START || data === HYDRATION_START_ELSE) {
        depth += 1;
      }
    }
    var next2 = (
      /** @type {TemplateNode} */
      get_next_sibling(node)
    );
    if (remove)
      node.remove();
    node = next2;
  }
}
function read_hydration_instruction(node) {
  if (!node || node.nodeType !== COMMENT_NODE) {
    hydration_mismatch();
    throw HYDRATION_ERROR;
  }
  return (
    /** @type {Comment} */
    node.data
  );
}

// node_modules/svelte/src/internal/client/proxy.js
var regex_is_valid_identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
function proxy(value) {
  if (typeof value !== "object" || value === null || STATE_SYMBOL in value) {
    return value;
  }
  const prototype = get_prototype_of(value);
  if (prototype !== object_prototype && prototype !== array_prototype) {
    return value;
  }
  var sources = /* @__PURE__ */ new Map();
  var is_proxied_array = is_array(value);
  var version = state(0);
  var stack2 = dev_fallback_default && tracing_mode_flag ? get_error("created at") : null;
  var parent_version = update_version;
  var with_parent = (fn) => {
    if (update_version === parent_version) {
      return fn();
    }
    var reaction = active_reaction;
    var version2 = update_version;
    set_active_reaction(null);
    set_update_version(parent_version);
    var result = fn();
    set_active_reaction(reaction);
    set_update_version(version2);
    return result;
  };
  if (is_proxied_array) {
    sources.set("length", state(
      /** @type {any[]} */
      value.length,
      stack2
    ));
    if (dev_fallback_default) {
      value = /** @type {any} */
      inspectable_array(
        /** @type {any[]} */
        value
      );
    }
  }
  var path = "";
  let updating = false;
  function update_path(new_path) {
    if (updating)
      return;
    updating = true;
    path = new_path;
    tag(version, `${path} version`);
    for (const [prop2, source2] of sources) {
      tag(source2, get_label(path, prop2));
    }
    updating = false;
  }
  return new Proxy(
    /** @type {any} */
    value,
    {
      defineProperty(_2, prop2, descriptor) {
        if (!("value" in descriptor) || descriptor.configurable === false || descriptor.enumerable === false || descriptor.writable === false) {
          state_descriptors_fixed();
        }
        var s3 = sources.get(prop2);
        if (s3 === void 0) {
          s3 = with_parent(() => {
            var s4 = state(descriptor.value, stack2);
            sources.set(prop2, s4);
            if (dev_fallback_default && typeof prop2 === "string") {
              tag(s4, get_label(path, prop2));
            }
            return s4;
          });
        } else {
          set(s3, descriptor.value, true);
        }
        return true;
      },
      deleteProperty(target, prop2) {
        var s3 = sources.get(prop2);
        if (s3 === void 0) {
          if (prop2 in target) {
            const s4 = with_parent(() => state(UNINITIALIZED, stack2));
            sources.set(prop2, s4);
            increment(version);
            if (dev_fallback_default) {
              tag(s4, get_label(path, prop2));
            }
          }
        } else {
          set(s3, UNINITIALIZED);
          increment(version);
        }
        return true;
      },
      get(target, prop2, receiver) {
        var _a3;
        if (prop2 === STATE_SYMBOL) {
          return value;
        }
        if (dev_fallback_default && prop2 === PROXY_PATH_SYMBOL) {
          return update_path;
        }
        var s3 = sources.get(prop2);
        var exists = prop2 in target;
        if (s3 === void 0 && (!exists || ((_a3 = get_descriptor(target, prop2)) == null ? void 0 : _a3.writable))) {
          s3 = with_parent(() => {
            var p5 = proxy(exists ? target[prop2] : UNINITIALIZED);
            var s4 = state(p5, stack2);
            if (dev_fallback_default) {
              tag(s4, get_label(path, prop2));
            }
            return s4;
          });
          sources.set(prop2, s3);
        }
        if (s3 !== void 0) {
          var v2 = get(s3);
          return v2 === UNINITIALIZED ? void 0 : v2;
        }
        return Reflect.get(target, prop2, receiver);
      },
      getOwnPropertyDescriptor(target, prop2) {
        var descriptor = Reflect.getOwnPropertyDescriptor(target, prop2);
        if (descriptor && "value" in descriptor) {
          var s3 = sources.get(prop2);
          if (s3)
            descriptor.value = get(s3);
        } else if (descriptor === void 0) {
          var source2 = sources.get(prop2);
          var value2 = source2 == null ? void 0 : source2.v;
          if (source2 !== void 0 && value2 !== UNINITIALIZED) {
            return {
              enumerable: true,
              configurable: true,
              value: value2,
              writable: true
            };
          }
        }
        return descriptor;
      },
      has(target, prop2) {
        var _a3;
        if (prop2 === STATE_SYMBOL) {
          return true;
        }
        var s3 = sources.get(prop2);
        var has2 = s3 !== void 0 && s3.v !== UNINITIALIZED || Reflect.has(target, prop2);
        if (s3 !== void 0 || active_effect !== null && (!has2 || ((_a3 = get_descriptor(target, prop2)) == null ? void 0 : _a3.writable))) {
          if (s3 === void 0) {
            s3 = with_parent(() => {
              var p5 = has2 ? proxy(target[prop2]) : UNINITIALIZED;
              var s4 = state(p5, stack2);
              if (dev_fallback_default) {
                tag(s4, get_label(path, prop2));
              }
              return s4;
            });
            sources.set(prop2, s3);
          }
          var value2 = get(s3);
          if (value2 === UNINITIALIZED) {
            return false;
          }
        }
        return has2;
      },
      set(target, prop2, value2, receiver) {
        var _a3;
        var s3 = sources.get(prop2);
        var has2 = prop2 in target;
        if (is_proxied_array && prop2 === "length") {
          for (var i3 = value2; i3 < /** @type {Source<number>} */
          s3.v; i3 += 1) {
            var other_s = sources.get(i3 + "");
            if (other_s !== void 0) {
              set(other_s, UNINITIALIZED);
            } else if (i3 in target) {
              other_s = with_parent(() => state(UNINITIALIZED, stack2));
              sources.set(i3 + "", other_s);
              if (dev_fallback_default) {
                tag(other_s, get_label(path, i3));
              }
            }
          }
        }
        if (s3 === void 0) {
          if (!has2 || ((_a3 = get_descriptor(target, prop2)) == null ? void 0 : _a3.writable)) {
            s3 = with_parent(() => state(void 0, stack2));
            if (dev_fallback_default) {
              tag(s3, get_label(path, prop2));
            }
            set(s3, proxy(value2));
            sources.set(prop2, s3);
          }
        } else {
          has2 = s3.v !== UNINITIALIZED;
          var p5 = with_parent(() => proxy(value2));
          set(s3, p5);
        }
        var descriptor = Reflect.getOwnPropertyDescriptor(target, prop2);
        if (descriptor == null ? void 0 : descriptor.set) {
          descriptor.set.call(receiver, value2);
        }
        if (!has2) {
          if (is_proxied_array && typeof prop2 === "string") {
            var ls = (
              /** @type {Source<number>} */
              sources.get("length")
            );
            var n3 = Number(prop2);
            if (Number.isInteger(n3) && n3 >= ls.v) {
              set(ls, n3 + 1);
            }
          }
          increment(version);
        }
        return true;
      },
      ownKeys(target) {
        get(version);
        var own_keys = Reflect.ownKeys(target).filter((key3) => {
          var source3 = sources.get(key3);
          return source3 === void 0 || source3.v !== UNINITIALIZED;
        });
        for (var [key2, source2] of sources) {
          if (source2.v !== UNINITIALIZED && !(key2 in target)) {
            own_keys.push(key2);
          }
        }
        return own_keys;
      },
      setPrototypeOf() {
        state_prototype_fixed();
      }
    }
  );
}
function get_label(path, prop2) {
  var _a3;
  if (typeof prop2 === "symbol")
    return `${path}[Symbol(${(_a3 = prop2.description) != null ? _a3 : ""})]`;
  if (regex_is_valid_identifier.test(prop2))
    return `${path}.${prop2}`;
  return /^\d+$/.test(prop2) ? `${path}[${prop2}]` : `${path}['${prop2}']`;
}
function get_proxied_value(value) {
  try {
    if (value !== null && typeof value === "object" && STATE_SYMBOL in value) {
      return value[STATE_SYMBOL];
    }
  } catch (e2) {
  }
  return value;
}
function is(a2, b) {
  return Object.is(get_proxied_value(a2), get_proxied_value(b));
}
var ARRAY_MUTATING_METHODS = /* @__PURE__ */ new Set([
  "copyWithin",
  "fill",
  "pop",
  "push",
  "reverse",
  "shift",
  "sort",
  "splice",
  "unshift"
]);
function inspectable_array(array) {
  return new Proxy(array, {
    get(target, prop2, receiver) {
      var value = Reflect.get(target, prop2, receiver);
      if (!ARRAY_MUTATING_METHODS.has(
        /** @type {string} */
        prop2
      )) {
        return value;
      }
      return function(...args) {
        set_eager_effects_deferred();
        var result = value.apply(this, args);
        flush_eager_effects();
        return result;
      };
    }
  });
}

// node_modules/svelte/src/internal/client/dev/equality.js
function init_array_prototype_warnings() {
  const array_prototype2 = Array.prototype;
  const cleanup = Array.__svelte_cleanup;
  if (cleanup) {
    cleanup();
  }
  const { indexOf, lastIndexOf, includes } = array_prototype2;
  array_prototype2.indexOf = function(item, from_index) {
    const index4 = indexOf.call(this, item, from_index);
    if (index4 === -1) {
      for (let i3 = from_index != null ? from_index : 0; i3 < this.length; i3 += 1) {
        if (get_proxied_value(this[i3]) === item) {
          state_proxy_equality_mismatch("array.indexOf(...)");
          break;
        }
      }
    }
    return index4;
  };
  array_prototype2.lastIndexOf = function(item, from_index) {
    const index4 = lastIndexOf.call(this, item, from_index != null ? from_index : this.length - 1);
    if (index4 === -1) {
      for (let i3 = 0; i3 <= (from_index != null ? from_index : this.length - 1); i3 += 1) {
        if (get_proxied_value(this[i3]) === item) {
          state_proxy_equality_mismatch("array.lastIndexOf(...)");
          break;
        }
      }
    }
    return index4;
  };
  array_prototype2.includes = function(item, from_index) {
    const has2 = includes.call(this, item, from_index);
    if (!has2) {
      for (let i3 = 0; i3 < this.length; i3 += 1) {
        if (get_proxied_value(this[i3]) === item) {
          state_proxy_equality_mismatch("array.includes(...)");
          break;
        }
      }
    }
    return has2;
  };
  Array.__svelte_cleanup = () => {
    array_prototype2.indexOf = indexOf;
    array_prototype2.lastIndexOf = lastIndexOf;
    array_prototype2.includes = includes;
  };
}

// node_modules/svelte/src/internal/client/dom/operations.js
var $window;
var $document;
var is_firefox;
var first_child_getter;
var next_sibling_getter;
function init_operations() {
  if ($window !== void 0) {
    return;
  }
  $window = window;
  $document = document;
  is_firefox = /Firefox/.test(navigator.userAgent);
  var element_prototype = Element.prototype;
  var node_prototype = Node.prototype;
  var text_prototype = Text.prototype;
  first_child_getter = get_descriptor(node_prototype, "firstChild").get;
  next_sibling_getter = get_descriptor(node_prototype, "nextSibling").get;
  if (is_extensible(element_prototype)) {
    element_prototype.__click = void 0;
    element_prototype.__className = void 0;
    element_prototype.__attributes = null;
    element_prototype.__style = void 0;
    element_prototype.__e = void 0;
  }
  if (is_extensible(text_prototype)) {
    text_prototype.__t = void 0;
  }
  if (dev_fallback_default) {
    element_prototype.__svelte_meta = null;
    init_array_prototype_warnings();
  }
}
function create_text(value = "") {
  return document.createTextNode(value);
}
// @__NO_SIDE_EFFECTS__
function get_first_child(node) {
  return (
    /** @type {TemplateNode | null} */
    first_child_getter.call(node)
  );
}
// @__NO_SIDE_EFFECTS__
function get_next_sibling(node) {
  return (
    /** @type {TemplateNode | null} */
    next_sibling_getter.call(node)
  );
}
function child(node, is_text) {
  if (!hydrating) {
    return /* @__PURE__ */ get_first_child(node);
  }
  var child2 = /* @__PURE__ */ get_first_child(hydrate_node);
  if (child2 === null) {
    child2 = hydrate_node.appendChild(create_text());
  } else if (is_text && child2.nodeType !== TEXT_NODE) {
    var text2 = create_text();
    child2 == null ? void 0 : child2.before(text2);
    set_hydrate_node(text2);
    return text2;
  }
  set_hydrate_node(child2);
  return child2;
}
function first_child(node, is_text = false) {
  var _a3, _b3;
  if (!hydrating) {
    var first = /* @__PURE__ */ get_first_child(node);
    if (first instanceof Comment && first.data === "")
      return /* @__PURE__ */ get_next_sibling(first);
    return first;
  }
  if (is_text && ((_a3 = hydrate_node) == null ? void 0 : _a3.nodeType) !== TEXT_NODE) {
    var text2 = create_text();
    (_b3 = hydrate_node) == null ? void 0 : _b3.before(text2);
    set_hydrate_node(text2);
    return text2;
  }
  return hydrate_node;
}
function sibling(node, count = 1, is_text = false) {
  let next_sibling = hydrating ? hydrate_node : node;
  var last_sibling;
  while (count--) {
    last_sibling = next_sibling;
    next_sibling = /** @type {TemplateNode} */
    /* @__PURE__ */ get_next_sibling(next_sibling);
  }
  if (!hydrating) {
    return next_sibling;
  }
  if (is_text && (next_sibling == null ? void 0 : next_sibling.nodeType) !== TEXT_NODE) {
    var text2 = create_text();
    if (next_sibling === null) {
      last_sibling == null ? void 0 : last_sibling.after(text2);
    } else {
      next_sibling.before(text2);
    }
    set_hydrate_node(text2);
    return text2;
  }
  set_hydrate_node(next_sibling);
  return next_sibling;
}
function clear_text_content(node) {
  node.textContent = "";
}
function should_defer_append() {
  if (!async_mode_flag)
    return false;
  if (eager_block_effects !== null)
    return false;
  var flags2 = (
    /** @type {Effect} */
    active_effect.f
  );
  return (flags2 & EFFECT_RAN) !== 0;
}

// node_modules/svelte/src/internal/client/error-handling.js
var adjustments = /* @__PURE__ */ new WeakMap();
function handle_error(error) {
  var effect2 = active_effect;
  if (effect2 === null) {
    active_reaction.f |= ERROR_VALUE;
    return error;
  }
  if (dev_fallback_default && error instanceof Error && !adjustments.has(error)) {
    adjustments.set(error, get_adjustments(error, effect2));
  }
  if ((effect2.f & EFFECT_RAN) === 0) {
    if ((effect2.f & BOUNDARY_EFFECT) === 0) {
      if (dev_fallback_default && !effect2.parent && error instanceof Error) {
        apply_adjustments(error);
      }
      throw error;
    }
    effect2.b.error(error);
  } else {
    invoke_error_boundary(error, effect2);
  }
}
function invoke_error_boundary(error, effect2) {
  while (effect2 !== null) {
    if ((effect2.f & BOUNDARY_EFFECT) !== 0) {
      try {
        effect2.b.error(error);
        return;
      } catch (e2) {
        error = e2;
      }
    }
    effect2 = effect2.parent;
  }
  if (dev_fallback_default && error instanceof Error) {
    apply_adjustments(error);
  }
  throw error;
}
function get_adjustments(error, effect2) {
  var _a3, _b3, _c2;
  const message_descriptor = get_descriptor(error, "message");
  if (message_descriptor && !message_descriptor.configurable)
    return;
  var indent = is_firefox ? "  " : "	";
  var component_stack = `
${indent}in ${((_a3 = effect2.fn) == null ? void 0 : _a3.name) || "<unknown>"}`;
  var context = effect2.ctx;
  while (context !== null) {
    component_stack += `
${indent}in ${(_b3 = context.function) == null ? void 0 : _b3[FILENAME].split("/").pop()}`;
    context = context.p;
  }
  return {
    message: error.message + `
${component_stack}
`,
    stack: (_c2 = error.stack) == null ? void 0 : _c2.split("\n").filter((line) => !line.includes("svelte/src/internal")).join("\n")
  };
}
function apply_adjustments(error) {
  const adjusted = adjustments.get(error);
  if (adjusted) {
    define_property(error, "message", {
      value: adjusted.message
    });
    define_property(error, "stack", {
      value: adjusted.stack
    });
  }
}

// node_modules/svelte/src/internal/client/reactivity/batch.js
var batches = /* @__PURE__ */ new Set();
var current_batch = null;
var previous_batch = null;
var batch_values = null;
var queued_root_effects = [];
var last_scheduled_effect = null;
var is_flushing = false;
var is_flushing_sync = false;
var _commit_callbacks, _discard_callbacks, _pending, _blocking_pending, _deferred, _dirty_effects, _maybe_dirty_effects, _traverse_effect_tree, traverse_effect_tree_fn, _defer_effects, defer_effects_fn, _clear_marked, clear_marked_fn, _resolve, resolve_fn, _commit, commit_fn;
var _Batch = class _Batch {
  constructor() {
    /**
     * Traverse the effect tree, executing effects or stashing
     * them for later execution as appropriate
     * @param {Effect} root
     * @param {EffectTarget} target
     */
    __privateAdd(this, _traverse_effect_tree);
    /**
     * @param {Effect[]} effects
     */
    __privateAdd(this, _defer_effects);
    /**
     * @param {Value[] | null} deps
     */
    __privateAdd(this, _clear_marked);
    __privateAdd(this, _resolve);
    __privateAdd(this, _commit);
    __publicField(this, "committed", false);
    /**
     * The current values of any sources that are updated in this batch
     * They keys of this map are identical to `this.#previous`
     * @type {Map<Source, any>}
     */
    __publicField(this, "current", /* @__PURE__ */ new Map());
    /**
     * The values of any sources that are updated in this batch _before_ those updates took place.
     * They keys of this map are identical to `this.#current`
     * @type {Map<Source, any>}
     */
    __publicField(this, "previous", /* @__PURE__ */ new Map());
    /**
     * When the batch is committed (and the DOM is updated), we need to remove old branches
     * and append new ones by calling the functions added inside (if/each/key/etc) blocks
     * @type {Set<() => void>}
     */
    __privateAdd(this, _commit_callbacks, /* @__PURE__ */ new Set());
    /**
     * If a fork is discarded, we need to destroy any effects that are no longer needed
     * @type {Set<(batch: Batch) => void>}
     */
    __privateAdd(this, _discard_callbacks, /* @__PURE__ */ new Set());
    /**
     * The number of async effects that are currently in flight
     */
    __privateAdd(this, _pending, 0);
    /**
     * The number of async effects that are currently in flight, _not_ inside a pending boundary
     */
    __privateAdd(this, _blocking_pending, 0);
    /**
     * A deferred that resolves when the batch is committed, used with `settled()`
     * TODO replace with Promise.withResolvers once supported widely enough
     * @type {{ promise: Promise<void>, resolve: (value?: any) => void, reject: (reason: unknown) => void } | null}
     */
    __privateAdd(this, _deferred, null);
    /**
     * Deferred effects (which run after async work has completed) that are DIRTY
     * @type {Effect[]}
     */
    __privateAdd(this, _dirty_effects, []);
    /**
     * Deferred effects that are MAYBE_DIRTY
     * @type {Effect[]}
     */
    __privateAdd(this, _maybe_dirty_effects, []);
    /**
     * A set of branches that still exist, but will be destroyed when this batch
     * is committed  we skip over these during `process`
     * @type {Set<Effect>}
     */
    __publicField(this, "skipped_effects", /* @__PURE__ */ new Set());
    __publicField(this, "is_fork", false);
  }
  is_deferred() {
    return this.is_fork || __privateGet(this, _blocking_pending) > 0;
  }
  /**
   *
   * @param {Effect[]} root_effects
   */
  process(root_effects) {
    var _a3;
    queued_root_effects = [];
    previous_batch = null;
    this.apply();
    var target = {
      parent: null,
      effect: null,
      effects: [],
      render_effects: [],
      block_effects: []
    };
    for (const root6 of root_effects) {
      __privateMethod(this, _traverse_effect_tree, traverse_effect_tree_fn).call(this, root6, target);
    }
    if (!this.is_fork) {
      __privateMethod(this, _resolve, resolve_fn).call(this);
    }
    if (this.is_deferred()) {
      __privateMethod(this, _defer_effects, defer_effects_fn).call(this, target.effects);
      __privateMethod(this, _defer_effects, defer_effects_fn).call(this, target.render_effects);
      __privateMethod(this, _defer_effects, defer_effects_fn).call(this, target.block_effects);
    } else {
      previous_batch = this;
      current_batch = null;
      flush_queued_effects(target.render_effects);
      flush_queued_effects(target.effects);
      previous_batch = null;
      (_a3 = __privateGet(this, _deferred)) == null ? void 0 : _a3.resolve();
    }
    batch_values = null;
  }
  /**
   * Associate a change to a given source with the current
   * batch, noting its previous and current values
   * @param {Source} source
   * @param {any} value
   */
  capture(source2, value) {
    if (!this.previous.has(source2)) {
      this.previous.set(source2, value);
    }
    if ((source2.f & ERROR_VALUE) === 0) {
      this.current.set(source2, source2.v);
      batch_values == null ? void 0 : batch_values.set(source2, source2.v);
    }
  }
  activate() {
    current_batch = this;
    this.apply();
  }
  deactivate() {
    if (current_batch !== this)
      return;
    current_batch = null;
    batch_values = null;
  }
  flush() {
    this.activate();
    if (queued_root_effects.length > 0) {
      flush_effects();
      if (current_batch !== null && current_batch !== this) {
        return;
      }
    } else if (__privateGet(this, _pending) === 0) {
      this.process([]);
    }
    this.deactivate();
  }
  discard() {
    for (const fn of __privateGet(this, _discard_callbacks))
      fn(this);
    __privateGet(this, _discard_callbacks).clear();
  }
  /**
   *
   * @param {boolean} blocking
   */
  increment(blocking) {
    __privateSet(this, _pending, __privateGet(this, _pending) + 1);
    if (blocking)
      __privateSet(this, _blocking_pending, __privateGet(this, _blocking_pending) + 1);
  }
  /**
   *
   * @param {boolean} blocking
   */
  decrement(blocking) {
    __privateSet(this, _pending, __privateGet(this, _pending) - 1);
    if (blocking)
      __privateSet(this, _blocking_pending, __privateGet(this, _blocking_pending) - 1);
    this.revive();
  }
  revive() {
    for (const e2 of __privateGet(this, _dirty_effects)) {
      set_signal_status(e2, DIRTY);
      schedule_effect(e2);
    }
    for (const e2 of __privateGet(this, _maybe_dirty_effects)) {
      set_signal_status(e2, MAYBE_DIRTY);
      schedule_effect(e2);
    }
    __privateSet(this, _dirty_effects, []);
    __privateSet(this, _maybe_dirty_effects, []);
    this.flush();
  }
  /** @param {() => void} fn */
  oncommit(fn) {
    __privateGet(this, _commit_callbacks).add(fn);
  }
  /** @param {(batch: Batch) => void} fn */
  ondiscard(fn) {
    __privateGet(this, _discard_callbacks).add(fn);
  }
  settled() {
    var _a3;
    return ((_a3 = __privateGet(this, _deferred)) != null ? _a3 : __privateSet(this, _deferred, deferred())).promise;
  }
  static ensure() {
    if (current_batch === null) {
      const batch = current_batch = new _Batch();
      batches.add(current_batch);
      if (!is_flushing_sync) {
        _Batch.enqueue(() => {
          if (current_batch !== batch) {
            return;
          }
          batch.flush();
        });
      }
    }
    return current_batch;
  }
  /** @param {() => void} task */
  static enqueue(task) {
    queue_micro_task(task);
  }
  apply() {
    if (!async_mode_flag || !this.is_fork && batches.size === 1)
      return;
    batch_values = new Map(this.current);
    for (const batch of batches) {
      if (batch === this)
        continue;
      for (const [source2, previous] of batch.previous) {
        if (!batch_values.has(source2)) {
          batch_values.set(source2, previous);
        }
      }
    }
  }
};
_commit_callbacks = new WeakMap();
_discard_callbacks = new WeakMap();
_pending = new WeakMap();
_blocking_pending = new WeakMap();
_deferred = new WeakMap();
_dirty_effects = new WeakMap();
_maybe_dirty_effects = new WeakMap();
_traverse_effect_tree = new WeakSet();
traverse_effect_tree_fn = function(root6, target) {
  var _a3;
  root6.f ^= CLEAN;
  var effect2 = root6.first;
  while (effect2 !== null) {
    var flags2 = effect2.f;
    var is_branch = (flags2 & (BRANCH_EFFECT | ROOT_EFFECT)) !== 0;
    var is_skippable_branch = is_branch && (flags2 & CLEAN) !== 0;
    var skip = is_skippable_branch || (flags2 & INERT) !== 0 || this.skipped_effects.has(effect2);
    if ((effect2.f & BOUNDARY_EFFECT) !== 0 && ((_a3 = effect2.b) == null ? void 0 : _a3.is_pending())) {
      target = {
        parent: target,
        effect: effect2,
        effects: [],
        render_effects: [],
        block_effects: []
      };
    }
    if (!skip && effect2.fn !== null) {
      if (is_branch) {
        effect2.f ^= CLEAN;
      } else if ((flags2 & EFFECT) !== 0) {
        target.effects.push(effect2);
      } else if (async_mode_flag && (flags2 & (RENDER_EFFECT | MANAGED_EFFECT)) !== 0) {
        target.render_effects.push(effect2);
      } else if (is_dirty(effect2)) {
        if ((effect2.f & BLOCK_EFFECT) !== 0)
          target.block_effects.push(effect2);
        update_effect(effect2);
      }
      var child2 = effect2.first;
      if (child2 !== null) {
        effect2 = child2;
        continue;
      }
    }
    var parent = effect2.parent;
    effect2 = effect2.next;
    while (effect2 === null && parent !== null) {
      if (parent === target.effect) {
        __privateMethod(this, _defer_effects, defer_effects_fn).call(this, target.effects);
        __privateMethod(this, _defer_effects, defer_effects_fn).call(this, target.render_effects);
        __privateMethod(this, _defer_effects, defer_effects_fn).call(this, target.block_effects);
        target = /** @type {EffectTarget} */
        target.parent;
      }
      effect2 = parent.next;
      parent = parent.parent;
    }
  }
};
_defer_effects = new WeakSet();
defer_effects_fn = function(effects) {
  for (const e2 of effects) {
    const target = (e2.f & DIRTY) !== 0 ? __privateGet(this, _dirty_effects) : __privateGet(this, _maybe_dirty_effects);
    target.push(e2);
    __privateMethod(this, _clear_marked, clear_marked_fn).call(this, e2.deps);
    set_signal_status(e2, CLEAN);
  }
};
_clear_marked = new WeakSet();
clear_marked_fn = function(deps) {
  if (deps === null)
    return;
  for (const dep of deps) {
    if ((dep.f & DERIVED) === 0 || (dep.f & WAS_MARKED) === 0) {
      continue;
    }
    dep.f ^= WAS_MARKED;
    __privateMethod(this, _clear_marked, clear_marked_fn).call(
      this,
      /** @type {Derived} */
      dep.deps
    );
  }
};
_resolve = new WeakSet();
resolve_fn = function() {
  if (__privateGet(this, _blocking_pending) === 0) {
    for (const fn of __privateGet(this, _commit_callbacks))
      fn();
    __privateGet(this, _commit_callbacks).clear();
  }
  if (__privateGet(this, _pending) === 0) {
    __privateMethod(this, _commit, commit_fn).call(this);
  }
};
_commit = new WeakSet();
commit_fn = function() {
  var _a3;
  if (batches.size > 1) {
    this.previous.clear();
    var previous_batch_values = batch_values;
    var is_earlier = true;
    var dummy_target = {
      parent: null,
      effect: null,
      effects: [],
      render_effects: [],
      block_effects: []
    };
    for (const batch of batches) {
      if (batch === this) {
        is_earlier = false;
        continue;
      }
      const sources = [];
      for (const [source2, value] of this.current) {
        if (batch.current.has(source2)) {
          if (is_earlier && value !== batch.current.get(source2)) {
            batch.current.set(source2, value);
          } else {
            continue;
          }
        }
        sources.push(source2);
      }
      if (sources.length === 0) {
        continue;
      }
      const others = [...batch.current.keys()].filter((s3) => !this.current.has(s3));
      if (others.length > 0) {
        var prev_queued_root_effects = queued_root_effects;
        queued_root_effects = [];
        const marked = /* @__PURE__ */ new Set();
        const checked = /* @__PURE__ */ new Map();
        for (const source2 of sources) {
          mark_effects(source2, others, marked, checked);
        }
        if (queued_root_effects.length > 0) {
          current_batch = batch;
          batch.apply();
          for (const root6 of queued_root_effects) {
            __privateMethod(_a3 = batch, _traverse_effect_tree, traverse_effect_tree_fn).call(_a3, root6, dummy_target);
          }
          batch.deactivate();
        }
        queued_root_effects = prev_queued_root_effects;
      }
    }
    current_batch = null;
    batch_values = previous_batch_values;
  }
  this.committed = true;
  batches.delete(this);
};
var Batch = _Batch;
function flushSync(fn) {
  var was_flushing_sync = is_flushing_sync;
  is_flushing_sync = true;
  try {
    var result;
    if (fn) {
      if (current_batch !== null) {
        flush_effects();
      }
      result = fn();
    }
    while (true) {
      flush_tasks();
      if (queued_root_effects.length === 0) {
        current_batch == null ? void 0 : current_batch.flush();
        if (queued_root_effects.length === 0) {
          last_scheduled_effect = null;
          return (
            /** @type {T} */
            result
          );
        }
      }
      flush_effects();
    }
  } finally {
    is_flushing_sync = was_flushing_sync;
  }
}
function flush_effects() {
  var _a3;
  var was_updating_effect = is_updating_effect;
  is_flushing = true;
  var source_stacks = dev_fallback_default ? /* @__PURE__ */ new Set() : null;
  try {
    var flush_count = 0;
    set_is_updating_effect(true);
    while (queued_root_effects.length > 0) {
      var batch = Batch.ensure();
      if (flush_count++ > 1e3) {
        if (dev_fallback_default) {
          var updates = /* @__PURE__ */ new Map();
          for (const source2 of batch.current.keys()) {
            for (const [stack2, update2] of (_a3 = source2.updated) != null ? _a3 : []) {
              var entry = updates.get(stack2);
              if (!entry) {
                entry = { error: update2.error, count: 0 };
                updates.set(stack2, entry);
              }
              entry.count += update2.count;
            }
          }
          for (const update2 of updates.values()) {
            if (update2.error) {
              console.error(update2.error);
            }
          }
        }
        infinite_loop_guard();
      }
      batch.process(queued_root_effects);
      old_values.clear();
      if (dev_fallback_default) {
        for (const source2 of batch.current.keys()) {
          source_stacks.add(source2);
        }
      }
    }
  } finally {
    is_flushing = false;
    set_is_updating_effect(was_updating_effect);
    last_scheduled_effect = null;
    if (dev_fallback_default) {
      for (
        const source2 of
        /** @type {Set<Source>} */
        source_stacks
      ) {
        source2.updated = null;
      }
    }
  }
}
function infinite_loop_guard() {
  try {
    effect_update_depth_exceeded();
  } catch (error) {
    if (dev_fallback_default) {
      define_property(error, "stack", { value: "" });
    }
    invoke_error_boundary(error, last_scheduled_effect);
  }
}
var eager_block_effects = null;
function flush_queued_effects(effects) {
  var length2 = effects.length;
  if (length2 === 0)
    return;
  var i3 = 0;
  while (i3 < length2) {
    var effect2 = effects[i3++];
    if ((effect2.f & (DESTROYED | INERT)) === 0 && is_dirty(effect2)) {
      eager_block_effects = /* @__PURE__ */ new Set();
      update_effect(effect2);
      if (effect2.deps === null && effect2.first === null && effect2.nodes === null) {
        if (effect2.teardown === null && effect2.ac === null) {
          unlink_effect(effect2);
        } else {
          effect2.fn = null;
        }
      }
      if ((eager_block_effects == null ? void 0 : eager_block_effects.size) > 0) {
        old_values.clear();
        for (const e2 of eager_block_effects) {
          if ((e2.f & (DESTROYED | INERT)) !== 0)
            continue;
          const ordered_effects = [e2];
          let ancestor = e2.parent;
          while (ancestor !== null) {
            if (eager_block_effects.has(ancestor)) {
              eager_block_effects.delete(ancestor);
              ordered_effects.push(ancestor);
            }
            ancestor = ancestor.parent;
          }
          for (let j2 = ordered_effects.length - 1; j2 >= 0; j2--) {
            const e3 = ordered_effects[j2];
            if ((e3.f & (DESTROYED | INERT)) !== 0)
              continue;
            update_effect(e3);
          }
        }
        eager_block_effects.clear();
      }
    }
  }
  eager_block_effects = null;
}
function mark_effects(value, sources, marked, checked) {
  if (marked.has(value))
    return;
  marked.add(value);
  if (value.reactions !== null) {
    for (const reaction of value.reactions) {
      const flags2 = reaction.f;
      if ((flags2 & DERIVED) !== 0) {
        mark_effects(
          /** @type {Derived} */
          reaction,
          sources,
          marked,
          checked
        );
      } else if ((flags2 & (ASYNC | BLOCK_EFFECT)) !== 0 && (flags2 & DIRTY) === 0 && depends_on(reaction, sources, checked)) {
        set_signal_status(reaction, DIRTY);
        schedule_effect(
          /** @type {Effect} */
          reaction
        );
      }
    }
  }
}
function depends_on(reaction, sources, checked) {
  const depends = checked.get(reaction);
  if (depends !== void 0)
    return depends;
  if (reaction.deps !== null) {
    for (const dep of reaction.deps) {
      if (sources.includes(dep)) {
        return true;
      }
      if ((dep.f & DERIVED) !== 0 && depends_on(
        /** @type {Derived} */
        dep,
        sources,
        checked
      )) {
        checked.set(
          /** @type {Derived} */
          dep,
          true
        );
        return true;
      }
    }
  }
  checked.set(reaction, false);
  return false;
}
function schedule_effect(signal) {
  var effect2 = last_scheduled_effect = signal;
  while (effect2.parent !== null) {
    effect2 = effect2.parent;
    var flags2 = effect2.f;
    if (is_flushing && effect2 === active_effect && (flags2 & BLOCK_EFFECT) !== 0 && (flags2 & HEAD_EFFECT) === 0) {
      return;
    }
    if ((flags2 & (ROOT_EFFECT | BRANCH_EFFECT)) !== 0) {
      if ((flags2 & CLEAN) === 0)
        return;
      effect2.f ^= CLEAN;
    }
  }
  queued_root_effects.push(effect2);
}

// node_modules/svelte/src/reactivity/create-subscriber.js
function createSubscriber(start2) {
  let subscribers = 0;
  let version = source(0);
  let stop;
  if (dev_fallback_default) {
    tag(version, "createSubscriber version");
  }
  return () => {
    if (effect_tracking()) {
      get(version);
      render_effect(() => {
        if (subscribers === 0) {
          stop = untrack(() => start2(() => increment(version)));
        }
        subscribers += 1;
        return () => {
          queue_micro_task(() => {
            subscribers -= 1;
            if (subscribers === 0) {
              stop == null ? void 0 : stop();
              stop = void 0;
              increment(version);
            }
          });
        };
      });
    }
  };
}

// node_modules/svelte/src/internal/client/dom/blocks/boundary.js
var flags = EFFECT_TRANSPARENT | EFFECT_PRESERVED | BOUNDARY_EFFECT;
function boundary(node, props, children) {
  new Boundary(node, props, children);
}
var _pending2, _anchor, _hydrate_open, _props, _children, _effect, _main_effect, _pending_effect, _failed_effect, _offscreen_fragment, _pending_anchor, _local_pending_count, _pending_count, _is_creating_fallback, _effect_pending, _effect_pending_subscriber, _hydrate_resolved_content, hydrate_resolved_content_fn, _hydrate_pending_content, hydrate_pending_content_fn, _get_anchor, get_anchor_fn, _run, run_fn, _show_pending_snippet, show_pending_snippet_fn, _update_pending_count, update_pending_count_fn;
var Boundary = class {
  /**
   * @param {TemplateNode} node
   * @param {BoundaryProps} props
   * @param {((anchor: Node) => void)} children
   */
  constructor(node, props, children) {
    __privateAdd(this, _hydrate_resolved_content);
    __privateAdd(this, _hydrate_pending_content);
    __privateAdd(this, _get_anchor);
    /**
     * @param {() => Effect | null} fn
     */
    __privateAdd(this, _run);
    __privateAdd(this, _show_pending_snippet);
    /**
     * Updates the pending count associated with the currently visible pending snippet,
     * if any, such that we can replace the snippet with content once work is done
     * @param {1 | -1} d
     */
    __privateAdd(this, _update_pending_count);
    /** @type {Boundary | null} */
    __publicField(this, "parent");
    __privateAdd(this, _pending2, false);
    /** @type {TemplateNode} */
    __privateAdd(this, _anchor, void 0);
    /** @type {TemplateNode | null} */
    __privateAdd(this, _hydrate_open, hydrating ? hydrate_node : null);
    /** @type {BoundaryProps} */
    __privateAdd(this, _props, void 0);
    /** @type {((anchor: Node) => void)} */
    __privateAdd(this, _children, void 0);
    /** @type {Effect} */
    __privateAdd(this, _effect, void 0);
    /** @type {Effect | null} */
    __privateAdd(this, _main_effect, null);
    /** @type {Effect | null} */
    __privateAdd(this, _pending_effect, null);
    /** @type {Effect | null} */
    __privateAdd(this, _failed_effect, null);
    /** @type {DocumentFragment | null} */
    __privateAdd(this, _offscreen_fragment, null);
    /** @type {TemplateNode | null} */
    __privateAdd(this, _pending_anchor, null);
    __privateAdd(this, _local_pending_count, 0);
    __privateAdd(this, _pending_count, 0);
    __privateAdd(this, _is_creating_fallback, false);
    /**
     * A source containing the number of pending async deriveds/expressions.
     * Only created if `$effect.pending()` is used inside the boundary,
     * otherwise updating the source results in needless `Batch.ensure()`
     * calls followed by no-op flushes
     * @type {Source<number> | null}
     */
    __privateAdd(this, _effect_pending, null);
    __privateAdd(this, _effect_pending_subscriber, createSubscriber(() => {
      __privateSet(this, _effect_pending, source(__privateGet(this, _local_pending_count)));
      if (dev_fallback_default) {
        tag(__privateGet(this, _effect_pending), "$effect.pending()");
      }
      return () => {
        __privateSet(this, _effect_pending, null);
      };
    }));
    __privateSet(this, _anchor, node);
    __privateSet(this, _props, props);
    __privateSet(this, _children, children);
    this.parent = /** @type {Effect} */
    active_effect.b;
    __privateSet(this, _pending2, !!__privateGet(this, _props).pending);
    __privateSet(this, _effect, block(() => {
      active_effect.b = this;
      if (hydrating) {
        const comment2 = __privateGet(this, _hydrate_open);
        hydrate_next();
        const server_rendered_pending = (
          /** @type {Comment} */
          comment2.nodeType === COMMENT_NODE && /** @type {Comment} */
          comment2.data === HYDRATION_START_ELSE
        );
        if (server_rendered_pending) {
          __privateMethod(this, _hydrate_pending_content, hydrate_pending_content_fn).call(this);
        } else {
          __privateMethod(this, _hydrate_resolved_content, hydrate_resolved_content_fn).call(this);
        }
      } else {
        var anchor = __privateMethod(this, _get_anchor, get_anchor_fn).call(this);
        try {
          __privateSet(this, _main_effect, branch(() => children(anchor)));
        } catch (error) {
          this.error(error);
        }
        if (__privateGet(this, _pending_count) > 0) {
          __privateMethod(this, _show_pending_snippet, show_pending_snippet_fn).call(this);
        } else {
          __privateSet(this, _pending2, false);
        }
      }
      return () => {
        var _a3;
        (_a3 = __privateGet(this, _pending_anchor)) == null ? void 0 : _a3.remove();
      };
    }, flags));
    if (hydrating) {
      __privateSet(this, _anchor, hydrate_node);
    }
  }
  /**
   * Returns `true` if the effect exists inside a boundary whose pending snippet is shown
   * @returns {boolean}
   */
  is_pending() {
    return __privateGet(this, _pending2) || !!this.parent && this.parent.is_pending();
  }
  has_pending_snippet() {
    return !!__privateGet(this, _props).pending;
  }
  /**
   * Update the source that powers `$effect.pending()` inside this boundary,
   * and controls when the current `pending` snippet (if any) is removed.
   * Do not call from inside the class
   * @param {1 | -1} d
   */
  update_pending_count(d2) {
    __privateMethod(this, _update_pending_count, update_pending_count_fn).call(this, d2);
    __privateSet(this, _local_pending_count, __privateGet(this, _local_pending_count) + d2);
    if (__privateGet(this, _effect_pending)) {
      internal_set(__privateGet(this, _effect_pending), __privateGet(this, _local_pending_count));
    }
  }
  get_effect_pending() {
    __privateGet(this, _effect_pending_subscriber).call(this);
    return get(
      /** @type {Source<number>} */
      __privateGet(this, _effect_pending)
    );
  }
  /** @param {unknown} error */
  error(error) {
    var onerror = __privateGet(this, _props).onerror;
    let failed = __privateGet(this, _props).failed;
    if (__privateGet(this, _is_creating_fallback) || !onerror && !failed) {
      throw error;
    }
    if (__privateGet(this, _main_effect)) {
      destroy_effect(__privateGet(this, _main_effect));
      __privateSet(this, _main_effect, null);
    }
    if (__privateGet(this, _pending_effect)) {
      destroy_effect(__privateGet(this, _pending_effect));
      __privateSet(this, _pending_effect, null);
    }
    if (__privateGet(this, _failed_effect)) {
      destroy_effect(__privateGet(this, _failed_effect));
      __privateSet(this, _failed_effect, null);
    }
    if (hydrating) {
      set_hydrate_node(
        /** @type {TemplateNode} */
        __privateGet(this, _hydrate_open)
      );
      next();
      set_hydrate_node(skip_nodes());
    }
    var did_reset = false;
    var calling_on_error = false;
    const reset3 = () => {
      if (did_reset) {
        svelte_boundary_reset_noop();
        return;
      }
      did_reset = true;
      if (calling_on_error) {
        svelte_boundary_reset_onerror();
      }
      Batch.ensure();
      __privateSet(this, _local_pending_count, 0);
      if (__privateGet(this, _failed_effect) !== null) {
        pause_effect(__privateGet(this, _failed_effect), () => {
          __privateSet(this, _failed_effect, null);
        });
      }
      __privateSet(this, _pending2, this.has_pending_snippet());
      __privateSet(this, _main_effect, __privateMethod(this, _run, run_fn).call(this, () => {
        __privateSet(this, _is_creating_fallback, false);
        return branch(() => __privateGet(this, _children).call(this, __privateGet(this, _anchor)));
      }));
      if (__privateGet(this, _pending_count) > 0) {
        __privateMethod(this, _show_pending_snippet, show_pending_snippet_fn).call(this);
      } else {
        __privateSet(this, _pending2, false);
      }
    };
    var previous_reaction = active_reaction;
    try {
      set_active_reaction(null);
      calling_on_error = true;
      onerror == null ? void 0 : onerror(error, reset3);
      calling_on_error = false;
    } catch (error2) {
      invoke_error_boundary(error2, __privateGet(this, _effect) && __privateGet(this, _effect).parent);
    } finally {
      set_active_reaction(previous_reaction);
    }
    if (failed) {
      queue_micro_task(() => {
        __privateSet(this, _failed_effect, __privateMethod(this, _run, run_fn).call(this, () => {
          Batch.ensure();
          __privateSet(this, _is_creating_fallback, true);
          try {
            return branch(() => {
              failed(
                __privateGet(this, _anchor),
                () => error,
                () => reset3
              );
            });
          } catch (error2) {
            invoke_error_boundary(
              error2,
              /** @type {Effect} */
              __privateGet(this, _effect).parent
            );
            return null;
          } finally {
            __privateSet(this, _is_creating_fallback, false);
          }
        }));
      });
    }
  }
};
_pending2 = new WeakMap();
_anchor = new WeakMap();
_hydrate_open = new WeakMap();
_props = new WeakMap();
_children = new WeakMap();
_effect = new WeakMap();
_main_effect = new WeakMap();
_pending_effect = new WeakMap();
_failed_effect = new WeakMap();
_offscreen_fragment = new WeakMap();
_pending_anchor = new WeakMap();
_local_pending_count = new WeakMap();
_pending_count = new WeakMap();
_is_creating_fallback = new WeakMap();
_effect_pending = new WeakMap();
_effect_pending_subscriber = new WeakMap();
_hydrate_resolved_content = new WeakSet();
hydrate_resolved_content_fn = function() {
  try {
    __privateSet(this, _main_effect, branch(() => __privateGet(this, _children).call(this, __privateGet(this, _anchor))));
  } catch (error) {
    this.error(error);
  }
  __privateSet(this, _pending2, false);
};
_hydrate_pending_content = new WeakSet();
hydrate_pending_content_fn = function() {
  const pending2 = __privateGet(this, _props).pending;
  if (!pending2) {
    return;
  }
  __privateSet(this, _pending_effect, branch(() => pending2(__privateGet(this, _anchor))));
  Batch.enqueue(() => {
    var anchor = __privateMethod(this, _get_anchor, get_anchor_fn).call(this);
    __privateSet(this, _main_effect, __privateMethod(this, _run, run_fn).call(this, () => {
      Batch.ensure();
      return branch(() => __privateGet(this, _children).call(this, anchor));
    }));
    if (__privateGet(this, _pending_count) > 0) {
      __privateMethod(this, _show_pending_snippet, show_pending_snippet_fn).call(this);
    } else {
      pause_effect(
        /** @type {Effect} */
        __privateGet(this, _pending_effect),
        () => {
          __privateSet(this, _pending_effect, null);
        }
      );
      __privateSet(this, _pending2, false);
    }
  });
};
_get_anchor = new WeakSet();
get_anchor_fn = function() {
  var anchor = __privateGet(this, _anchor);
  if (__privateGet(this, _pending2)) {
    __privateSet(this, _pending_anchor, create_text());
    __privateGet(this, _anchor).before(__privateGet(this, _pending_anchor));
    anchor = __privateGet(this, _pending_anchor);
  }
  return anchor;
};
_run = new WeakSet();
run_fn = function(fn) {
  var previous_effect = active_effect;
  var previous_reaction = active_reaction;
  var previous_ctx = component_context;
  set_active_effect(__privateGet(this, _effect));
  set_active_reaction(__privateGet(this, _effect));
  set_component_context(__privateGet(this, _effect).ctx);
  try {
    return fn();
  } catch (e2) {
    handle_error(e2);
    return null;
  } finally {
    set_active_effect(previous_effect);
    set_active_reaction(previous_reaction);
    set_component_context(previous_ctx);
  }
};
_show_pending_snippet = new WeakSet();
show_pending_snippet_fn = function() {
  const pending2 = (
    /** @type {(anchor: Node) => void} */
    __privateGet(this, _props).pending
  );
  if (__privateGet(this, _main_effect) !== null) {
    __privateSet(this, _offscreen_fragment, document.createDocumentFragment());
    __privateGet(this, _offscreen_fragment).append(
      /** @type {TemplateNode} */
      __privateGet(this, _pending_anchor)
    );
    move_effect(__privateGet(this, _main_effect), __privateGet(this, _offscreen_fragment));
  }
  if (__privateGet(this, _pending_effect) === null) {
    __privateSet(this, _pending_effect, branch(() => pending2(__privateGet(this, _anchor))));
  }
};
_update_pending_count = new WeakSet();
update_pending_count_fn = function(d2) {
  var _a3;
  if (!this.has_pending_snippet()) {
    if (this.parent) {
      __privateMethod(_a3 = this.parent, _update_pending_count, update_pending_count_fn).call(_a3, d2);
    }
    return;
  }
  __privateSet(this, _pending_count, __privateGet(this, _pending_count) + d2);
  if (__privateGet(this, _pending_count) === 0) {
    __privateSet(this, _pending2, false);
    if (__privateGet(this, _pending_effect)) {
      pause_effect(__privateGet(this, _pending_effect), () => {
        __privateSet(this, _pending_effect, null);
      });
    }
    if (__privateGet(this, _offscreen_fragment)) {
      __privateGet(this, _anchor).before(__privateGet(this, _offscreen_fragment));
      __privateSet(this, _offscreen_fragment, null);
    }
  }
};

// node_modules/svelte/src/internal/client/reactivity/async.js
function flatten(blockers, sync, async2, fn) {
  const d2 = is_runes() ? derived : derived_safe_equal;
  if (async2.length === 0 && blockers.length === 0) {
    fn(sync.map(d2));
    return;
  }
  var batch = current_batch;
  var parent = (
    /** @type {Effect} */
    active_effect
  );
  var restore = capture();
  function run3() {
    Promise.all(async2.map((expression) => async_derived(expression))).then((result) => {
      restore();
      try {
        fn([...sync.map(d2), ...result]);
      } catch (error) {
        if ((parent.f & DESTROYED) === 0) {
          invoke_error_boundary(error, parent);
        }
      }
      batch == null ? void 0 : batch.deactivate();
      unset_context();
    }).catch((error) => {
      invoke_error_boundary(error, parent);
    });
  }
  if (blockers.length > 0) {
    Promise.all(blockers).then(() => {
      restore();
      try {
        return run3();
      } finally {
        batch == null ? void 0 : batch.deactivate();
        unset_context();
      }
    });
  } else {
    run3();
  }
}
function capture() {
  var previous_effect = active_effect;
  var previous_reaction = active_reaction;
  var previous_component_context = component_context;
  var previous_batch2 = current_batch;
  if (dev_fallback_default) {
    var previous_dev_stack = dev_stack;
  }
  return function restore(activate_batch = true) {
    set_active_effect(previous_effect);
    set_active_reaction(previous_reaction);
    set_component_context(previous_component_context);
    if (activate_batch)
      previous_batch2 == null ? void 0 : previous_batch2.activate();
    if (dev_fallback_default) {
      set_from_async_derived(null);
      set_dev_stack(previous_dev_stack);
    }
  };
}
function unset_context() {
  set_active_effect(null);
  set_active_reaction(null);
  set_component_context(null);
  if (dev_fallback_default) {
    set_from_async_derived(null);
    set_dev_stack(null);
  }
}

// node_modules/svelte/src/internal/client/reactivity/deriveds.js
var current_async_effect = null;
function set_from_async_derived(v2) {
  current_async_effect = v2;
}
var recent_async_deriveds = /* @__PURE__ */ new Set();
// @__NO_SIDE_EFFECTS__
function derived(fn) {
  var flags2 = DERIVED | DIRTY;
  var parent_derived = active_reaction !== null && (active_reaction.f & DERIVED) !== 0 ? (
    /** @type {Derived} */
    active_reaction
  ) : null;
  if (active_effect !== null) {
    active_effect.f |= EFFECT_PRESERVED;
  }
  const signal = {
    ctx: component_context,
    deps: null,
    effects: null,
    equals,
    f: flags2,
    fn,
    reactions: null,
    rv: 0,
    v: (
      /** @type {V} */
      UNINITIALIZED
    ),
    wv: 0,
    parent: parent_derived != null ? parent_derived : active_effect,
    ac: null
  };
  if (dev_fallback_default && tracing_mode_flag) {
    signal.created = get_error("created at");
  }
  return signal;
}
// @__NO_SIDE_EFFECTS__
function async_derived(fn, location) {
  let parent = (
    /** @type {Effect | null} */
    active_effect
  );
  if (parent === null) {
    async_derived_orphan();
  }
  var boundary2 = (
    /** @type {Boundary} */
    parent.b
  );
  var promise = (
    /** @type {Promise<V>} */
    /** @type {unknown} */
    void 0
  );
  var signal = source(
    /** @type {V} */
    UNINITIALIZED
  );
  var should_suspend = !active_reaction;
  var deferreds = /* @__PURE__ */ new Map();
  async_effect(() => {
    var _a3;
    if (dev_fallback_default)
      current_async_effect = active_effect;
    var d2 = deferred();
    promise = d2.promise;
    try {
      Promise.resolve(fn()).then(d2.resolve, d2.reject).then(() => {
        if (batch === current_batch && batch.committed) {
          batch.deactivate();
        }
        unset_context();
      });
    } catch (error) {
      d2.reject(error);
      unset_context();
    }
    if (dev_fallback_default)
      current_async_effect = null;
    var batch = (
      /** @type {Batch} */
      current_batch
    );
    if (should_suspend) {
      var blocking = !boundary2.is_pending();
      boundary2.update_pending_count(1);
      batch.increment(blocking);
      (_a3 = deferreds.get(batch)) == null ? void 0 : _a3.reject(STALE_REACTION);
      deferreds.delete(batch);
      deferreds.set(batch, d2);
    }
    const handler = (value, error = void 0) => {
      current_async_effect = null;
      batch.activate();
      if (error) {
        if (error !== STALE_REACTION) {
          signal.f |= ERROR_VALUE;
          internal_set(signal, error);
        }
      } else {
        if ((signal.f & ERROR_VALUE) !== 0) {
          signal.f ^= ERROR_VALUE;
        }
        internal_set(signal, value);
        for (const [b, d3] of deferreds) {
          deferreds.delete(b);
          if (b === batch)
            break;
          d3.reject(STALE_REACTION);
        }
        if (dev_fallback_default && location !== void 0) {
          recent_async_deriveds.add(signal);
          setTimeout(() => {
            if (recent_async_deriveds.has(signal)) {
              await_waterfall(
                /** @type {string} */
                signal.label,
                location
              );
              recent_async_deriveds.delete(signal);
            }
          });
        }
      }
      if (should_suspend) {
        boundary2.update_pending_count(-1);
        batch.decrement(blocking);
      }
    };
    d2.promise.then(handler, (e2) => handler(null, e2 || "unknown"));
  });
  teardown(() => {
    for (const d2 of deferreds.values()) {
      d2.reject(STALE_REACTION);
    }
  });
  if (dev_fallback_default) {
    signal.f |= ASYNC;
  }
  return new Promise((fulfil) => {
    function next2(p5) {
      function go() {
        if (p5 === promise) {
          fulfil(signal);
        } else {
          next2(promise);
        }
      }
      p5.then(go, go);
    }
    next2(promise);
  });
}
// @__NO_SIDE_EFFECTS__
function user_derived(fn) {
  const d2 = /* @__PURE__ */ derived(fn);
  if (!async_mode_flag)
    push_reaction_value(d2);
  return d2;
}
// @__NO_SIDE_EFFECTS__
function derived_safe_equal(fn) {
  const signal = /* @__PURE__ */ derived(fn);
  signal.equals = safe_equals;
  return signal;
}
function destroy_derived_effects(derived3) {
  var effects = derived3.effects;
  if (effects !== null) {
    derived3.effects = null;
    for (var i3 = 0; i3 < effects.length; i3 += 1) {
      destroy_effect(
        /** @type {Effect} */
        effects[i3]
      );
    }
  }
}
var stack = [];
function get_derived_parent_effect(derived3) {
  var parent = derived3.parent;
  while (parent !== null) {
    if ((parent.f & DERIVED) === 0) {
      return (parent.f & DESTROYED) === 0 ? (
        /** @type {Effect} */
        parent
      ) : null;
    }
    parent = parent.parent;
  }
  return null;
}
function execute_derived(derived3) {
  var value;
  var prev_active_effect = active_effect;
  set_active_effect(get_derived_parent_effect(derived3));
  if (dev_fallback_default) {
    let prev_eager_effects = eager_effects;
    set_eager_effects(/* @__PURE__ */ new Set());
    try {
      if (stack.includes(derived3)) {
        derived_references_self();
      }
      stack.push(derived3);
      derived3.f &= ~WAS_MARKED;
      destroy_derived_effects(derived3);
      value = update_reaction(derived3);
    } finally {
      set_active_effect(prev_active_effect);
      set_eager_effects(prev_eager_effects);
      stack.pop();
    }
  } else {
    try {
      derived3.f &= ~WAS_MARKED;
      destroy_derived_effects(derived3);
      value = update_reaction(derived3);
    } finally {
      set_active_effect(prev_active_effect);
    }
  }
  return value;
}
function update_derived(derived3) {
  var _a3, _b3;
  var value = execute_derived(derived3);
  if (!derived3.equals(value)) {
    if (!((_a3 = current_batch) == null ? void 0 : _a3.is_fork)) {
      derived3.v = value;
    }
    derived3.wv = increment_write_version();
  }
  if (is_destroying_effect) {
    return;
  }
  if (batch_values !== null) {
    if (effect_tracking() || ((_b3 = current_batch) == null ? void 0 : _b3.is_fork)) {
      batch_values.set(derived3, value);
    }
  } else {
    var status = (derived3.f & CONNECTED) === 0 ? MAYBE_DIRTY : CLEAN;
    set_signal_status(derived3, status);
  }
}

// node_modules/svelte/src/internal/client/reactivity/sources.js
var eager_effects = /* @__PURE__ */ new Set();
var old_values = /* @__PURE__ */ new Map();
function set_eager_effects(v2) {
  eager_effects = v2;
}
var eager_effects_deferred = false;
function set_eager_effects_deferred() {
  eager_effects_deferred = true;
}
function source(v2, stack2) {
  var signal = {
    f: 0,
    // TODO ideally we could skip this altogether, but it causes type errors
    v: v2,
    reactions: null,
    equals,
    rv: 0,
    wv: 0
  };
  if (dev_fallback_default && tracing_mode_flag) {
    signal.created = stack2 != null ? stack2 : get_error("created at");
    signal.updated = null;
    signal.set_during_effect = false;
    signal.trace = null;
  }
  return signal;
}
// @__NO_SIDE_EFFECTS__
function state(v2, stack2) {
  const s3 = source(v2, stack2);
  push_reaction_value(s3);
  return s3;
}
// @__NO_SIDE_EFFECTS__
function mutable_source(initial_value, immutable = false, trackable = true) {
  var _a3, _b3;
  const s3 = source(initial_value);
  if (!immutable) {
    s3.equals = safe_equals;
  }
  if (legacy_mode_flag && trackable && component_context !== null && component_context.l !== null) {
    ((_b3 = (_a3 = component_context.l).s) != null ? _b3 : _a3.s = []).push(s3);
  }
  return s3;
}
function set(source2, value, should_proxy = false) {
  var _a3;
  if (active_reaction !== null && // since we are untracking the function inside `$inspect.with` we need to add this check
  // to ensure we error if state is set inside an inspect effect
  (!untracking || (active_reaction.f & EAGER_EFFECT) !== 0) && is_runes() && (active_reaction.f & (DERIVED | BLOCK_EFFECT | ASYNC | EAGER_EFFECT)) !== 0 && !((_a3 = current_sources) == null ? void 0 : _a3.includes(source2))) {
    state_unsafe_mutation();
  }
  let new_value = should_proxy ? proxy(value) : value;
  if (dev_fallback_default) {
    tag_proxy(
      new_value,
      /** @type {string} */
      source2.label
    );
  }
  return internal_set(source2, new_value);
}
function internal_set(source2, value) {
  var _a3, _b3, _c2;
  if (!source2.equals(value)) {
    var old_value = source2.v;
    if (is_destroying_effect) {
      old_values.set(source2, value);
    } else {
      old_values.set(source2, old_value);
    }
    source2.v = value;
    var batch = Batch.ensure();
    batch.capture(source2, old_value);
    if (dev_fallback_default) {
      if (tracing_mode_flag || active_effect !== null) {
        (_a3 = source2.updated) != null ? _a3 : source2.updated = /* @__PURE__ */ new Map();
        const count = ((_c2 = (_b3 = source2.updated.get("")) == null ? void 0 : _b3.count) != null ? _c2 : 0) + 1;
        source2.updated.set("", { error: (
          /** @type {any} */
          null
        ), count });
        if (tracing_mode_flag || count > 5) {
          const error = get_error("updated at");
          if (error !== null) {
            let entry = source2.updated.get(error.stack);
            if (!entry) {
              entry = { error, count: 0 };
              source2.updated.set(error.stack, entry);
            }
            entry.count++;
          }
        }
      }
      if (active_effect !== null) {
        source2.set_during_effect = true;
      }
    }
    if ((source2.f & DERIVED) !== 0) {
      if ((source2.f & DIRTY) !== 0) {
        execute_derived(
          /** @type {Derived} */
          source2
        );
      }
      set_signal_status(source2, (source2.f & CONNECTED) !== 0 ? CLEAN : MAYBE_DIRTY);
    }
    source2.wv = increment_write_version();
    mark_reactions(source2, DIRTY);
    if (is_runes() && active_effect !== null && (active_effect.f & CLEAN) !== 0 && (active_effect.f & (BRANCH_EFFECT | ROOT_EFFECT)) === 0) {
      if (untracked_writes === null) {
        set_untracked_writes([source2]);
      } else {
        untracked_writes.push(source2);
      }
    }
    if (!batch.is_fork && eager_effects.size > 0 && !eager_effects_deferred) {
      flush_eager_effects();
    }
  }
  return value;
}
function flush_eager_effects() {
  eager_effects_deferred = false;
  var prev_is_updating_effect = is_updating_effect;
  set_is_updating_effect(true);
  const inspects = Array.from(eager_effects);
  try {
    for (const effect2 of inspects) {
      if ((effect2.f & CLEAN) !== 0) {
        set_signal_status(effect2, MAYBE_DIRTY);
      }
      if (is_dirty(effect2)) {
        update_effect(effect2);
      }
    }
  } finally {
    set_is_updating_effect(prev_is_updating_effect);
  }
  eager_effects.clear();
}
function increment(source2) {
  set(source2, source2.v + 1);
}
function mark_reactions(signal, status) {
  var _a3;
  var reactions = signal.reactions;
  if (reactions === null)
    return;
  var runes = is_runes();
  var length2 = reactions.length;
  for (var i3 = 0; i3 < length2; i3++) {
    var reaction = reactions[i3];
    var flags2 = reaction.f;
    if (!runes && reaction === active_effect)
      continue;
    if (dev_fallback_default && (flags2 & EAGER_EFFECT) !== 0) {
      eager_effects.add(reaction);
      continue;
    }
    var not_dirty = (flags2 & DIRTY) === 0;
    if (not_dirty) {
      set_signal_status(reaction, status);
    }
    if ((flags2 & DERIVED) !== 0) {
      var derived3 = (
        /** @type {Derived} */
        reaction
      );
      (_a3 = batch_values) == null ? void 0 : _a3.delete(derived3);
      if ((flags2 & WAS_MARKED) === 0) {
        if (flags2 & CONNECTED) {
          reaction.f |= WAS_MARKED;
        }
        mark_reactions(derived3, MAYBE_DIRTY);
      }
    } else if (not_dirty) {
      if ((flags2 & BLOCK_EFFECT) !== 0 && eager_block_effects !== null) {
        eager_block_effects.add(
          /** @type {Effect} */
          reaction
        );
      }
      schedule_effect(
        /** @type {Effect} */
        reaction
      );
    }
  }
}

// node_modules/svelte/src/internal/client/legacy.js
var captured_signals = null;

// node_modules/svelte/src/internal/client/dom/elements/misc.js
function remove_textarea_child(dom) {
  if (hydrating && get_first_child(dom) !== null) {
    clear_text_content(dom);
  }
}
var listening_to_form_reset = false;
function add_form_reset_listener() {
  if (!listening_to_form_reset) {
    listening_to_form_reset = true;
    document.addEventListener(
      "reset",
      (evt) => {
        Promise.resolve().then(() => {
          var _a3;
          if (!evt.defaultPrevented) {
            for (
              const e2 of
              /**@type {HTMLFormElement} */
              evt.target.elements
            ) {
              (_a3 = e2.__on_r) == null ? void 0 : _a3.call(e2);
            }
          }
        });
      },
      // In the capture phase to guarantee we get noticed of it (no possibility of stopPropagation)
      { capture: true }
    );
  }
}

// node_modules/svelte/src/internal/client/dom/elements/bindings/shared.js
function without_reactive_context(fn) {
  var previous_reaction = active_reaction;
  var previous_effect = active_effect;
  set_active_reaction(null);
  set_active_effect(null);
  try {
    return fn();
  } finally {
    set_active_reaction(previous_reaction);
    set_active_effect(previous_effect);
  }
}
function listen_to_event_and_reset_event(element2, event2, handler, on_reset = handler) {
  element2.addEventListener(event2, () => without_reactive_context(handler));
  const prev = element2.__on_r;
  if (prev) {
    element2.__on_r = () => {
      prev();
      on_reset(true);
    };
  } else {
    element2.__on_r = () => on_reset(true);
  }
  add_form_reset_listener();
}

// node_modules/svelte/src/internal/client/runtime.js
var is_updating_effect = false;
function set_is_updating_effect(value) {
  is_updating_effect = value;
}
var is_destroying_effect = false;
function set_is_destroying_effect(value) {
  is_destroying_effect = value;
}
var active_reaction = null;
var untracking = false;
function set_active_reaction(reaction) {
  active_reaction = reaction;
}
var active_effect = null;
function set_active_effect(effect2) {
  active_effect = effect2;
}
var current_sources = null;
function push_reaction_value(value) {
  if (active_reaction !== null && (!async_mode_flag || (active_reaction.f & DERIVED) !== 0)) {
    if (current_sources === null) {
      current_sources = [value];
    } else {
      current_sources.push(value);
    }
  }
}
var new_deps = null;
var skipped_deps = 0;
var untracked_writes = null;
function set_untracked_writes(value) {
  untracked_writes = value;
}
var write_version = 1;
var read_version = 0;
var update_version = read_version;
function set_update_version(value) {
  update_version = value;
}
function increment_write_version() {
  return ++write_version;
}
function is_dirty(reaction) {
  var flags2 = reaction.f;
  if ((flags2 & DIRTY) !== 0) {
    return true;
  }
  if (flags2 & DERIVED) {
    reaction.f &= ~WAS_MARKED;
  }
  if ((flags2 & MAYBE_DIRTY) !== 0) {
    var dependencies = reaction.deps;
    if (dependencies !== null) {
      var length2 = dependencies.length;
      for (var i3 = 0; i3 < length2; i3++) {
        var dependency = dependencies[i3];
        if (is_dirty(
          /** @type {Derived} */
          dependency
        )) {
          update_derived(
            /** @type {Derived} */
            dependency
          );
        }
        if (dependency.wv > reaction.wv) {
          return true;
        }
      }
    }
    if ((flags2 & CONNECTED) !== 0 && // During time traveling we don't want to reset the status so that
    // traversal of the graph in the other batches still happens
    batch_values === null) {
      set_signal_status(reaction, CLEAN);
    }
  }
  return false;
}
function schedule_possible_effect_self_invalidation(signal, effect2, root6 = true) {
  var reactions = signal.reactions;
  if (reactions === null)
    return;
  if (!async_mode_flag && (current_sources == null ? void 0 : current_sources.includes(signal))) {
    return;
  }
  for (var i3 = 0; i3 < reactions.length; i3++) {
    var reaction = reactions[i3];
    if ((reaction.f & DERIVED) !== 0) {
      schedule_possible_effect_self_invalidation(
        /** @type {Derived} */
        reaction,
        effect2,
        false
      );
    } else if (effect2 === reaction) {
      if (root6) {
        set_signal_status(reaction, DIRTY);
      } else if ((reaction.f & CLEAN) !== 0) {
        set_signal_status(reaction, MAYBE_DIRTY);
      }
      schedule_effect(
        /** @type {Effect} */
        reaction
      );
    }
  }
}
function update_reaction(reaction) {
  var _a3, _b3;
  var previous_deps = new_deps;
  var previous_skipped_deps = skipped_deps;
  var previous_untracked_writes = untracked_writes;
  var previous_reaction = active_reaction;
  var previous_sources = current_sources;
  var previous_component_context = component_context;
  var previous_untracking = untracking;
  var previous_update_version = update_version;
  var flags2 = reaction.f;
  new_deps = /** @type {null | Value[]} */
  null;
  skipped_deps = 0;
  untracked_writes = null;
  active_reaction = (flags2 & (BRANCH_EFFECT | ROOT_EFFECT)) === 0 ? reaction : null;
  current_sources = null;
  set_component_context(reaction.ctx);
  untracking = false;
  update_version = ++read_version;
  if (reaction.ac !== null) {
    without_reactive_context(() => {
      reaction.ac.abort(STALE_REACTION);
    });
    reaction.ac = null;
  }
  try {
    reaction.f |= REACTION_IS_UPDATING;
    var fn = (
      /** @type {Function} */
      reaction.fn
    );
    var result = fn();
    var deps = reaction.deps;
    if (new_deps !== null) {
      var i3;
      remove_reactions(reaction, skipped_deps);
      if (deps !== null && skipped_deps > 0) {
        deps.length = skipped_deps + new_deps.length;
        for (i3 = 0; i3 < new_deps.length; i3++) {
          deps[skipped_deps + i3] = new_deps[i3];
        }
      } else {
        reaction.deps = deps = new_deps;
      }
      if (effect_tracking() && (reaction.f & CONNECTED) !== 0) {
        for (i3 = skipped_deps; i3 < deps.length; i3++) {
          ((_b3 = (_a3 = deps[i3]).reactions) != null ? _b3 : _a3.reactions = []).push(reaction);
        }
      }
    } else if (deps !== null && skipped_deps < deps.length) {
      remove_reactions(reaction, skipped_deps);
      deps.length = skipped_deps;
    }
    if (is_runes() && untracked_writes !== null && !untracking && deps !== null && (reaction.f & (DERIVED | MAYBE_DIRTY | DIRTY)) === 0) {
      for (i3 = 0; i3 < /** @type {Source[]} */
      untracked_writes.length; i3++) {
        schedule_possible_effect_self_invalidation(
          untracked_writes[i3],
          /** @type {Effect} */
          reaction
        );
      }
    }
    if (previous_reaction !== null && previous_reaction !== reaction) {
      read_version++;
      if (untracked_writes !== null) {
        if (previous_untracked_writes === null) {
          previous_untracked_writes = untracked_writes;
        } else {
          previous_untracked_writes.push(.../** @type {Source[]} */
          untracked_writes);
        }
      }
    }
    if ((reaction.f & ERROR_VALUE) !== 0) {
      reaction.f ^= ERROR_VALUE;
    }
    return result;
  } catch (error) {
    return handle_error(error);
  } finally {
    reaction.f ^= REACTION_IS_UPDATING;
    new_deps = previous_deps;
    skipped_deps = previous_skipped_deps;
    untracked_writes = previous_untracked_writes;
    active_reaction = previous_reaction;
    current_sources = previous_sources;
    set_component_context(previous_component_context);
    untracking = previous_untracking;
    update_version = previous_update_version;
  }
}
function remove_reaction(signal, dependency) {
  let reactions = dependency.reactions;
  if (reactions !== null) {
    var index4 = index_of.call(reactions, signal);
    if (index4 !== -1) {
      var new_length = reactions.length - 1;
      if (new_length === 0) {
        reactions = dependency.reactions = null;
      } else {
        reactions[index4] = reactions[new_length];
        reactions.pop();
      }
    }
  }
  if (reactions === null && (dependency.f & DERIVED) !== 0 && // Destroying a child effect while updating a parent effect can cause a dependency to appear
  // to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
  // allows us to skip the expensive work of disconnecting and immediately reconnecting it
  (new_deps === null || !new_deps.includes(dependency))) {
    set_signal_status(dependency, MAYBE_DIRTY);
    if ((dependency.f & CONNECTED) !== 0) {
      dependency.f ^= CONNECTED;
      dependency.f &= ~WAS_MARKED;
    }
    destroy_derived_effects(
      /** @type {Derived} **/
      dependency
    );
    remove_reactions(
      /** @type {Derived} **/
      dependency,
      0
    );
  }
}
function remove_reactions(signal, start_index) {
  var dependencies = signal.deps;
  if (dependencies === null)
    return;
  for (var i3 = start_index; i3 < dependencies.length; i3++) {
    remove_reaction(signal, dependencies[i3]);
  }
}
function update_effect(effect2) {
  var _a3;
  var flags2 = effect2.f;
  if ((flags2 & DESTROYED) !== 0) {
    return;
  }
  set_signal_status(effect2, CLEAN);
  var previous_effect = active_effect;
  var was_updating_effect = is_updating_effect;
  active_effect = effect2;
  is_updating_effect = true;
  if (dev_fallback_default) {
    var previous_component_fn = dev_current_component_function;
    set_dev_current_component_function(effect2.component_function);
    var previous_stack = (
      /** @type {any} */
      dev_stack
    );
    set_dev_stack((_a3 = effect2.dev_stack) != null ? _a3 : dev_stack);
  }
  try {
    if ((flags2 & (BLOCK_EFFECT | MANAGED_EFFECT)) !== 0) {
      destroy_block_effect_children(effect2);
    } else {
      destroy_effect_children(effect2);
    }
    execute_effect_teardown(effect2);
    var teardown2 = update_reaction(effect2);
    effect2.teardown = typeof teardown2 === "function" ? teardown2 : null;
    effect2.wv = write_version;
    if (dev_fallback_default && tracing_mode_flag && (effect2.f & DIRTY) !== 0 && effect2.deps !== null) {
      for (var dep of effect2.deps) {
        if (dep.set_during_effect) {
          dep.wv = increment_write_version();
          dep.set_during_effect = false;
        }
      }
    }
  } finally {
    is_updating_effect = was_updating_effect;
    active_effect = previous_effect;
    if (dev_fallback_default) {
      set_dev_current_component_function(previous_component_fn);
      set_dev_stack(previous_stack);
    }
  }
}
async function tick() {
  if (async_mode_flag) {
    return new Promise((f3) => {
      requestAnimationFrame(() => f3());
      setTimeout(() => f3());
    });
  }
  await Promise.resolve();
  flushSync();
}
function get(signal) {
  var _a3, _b3, _c2, _d, _e;
  var flags2 = signal.f;
  var is_derived = (flags2 & DERIVED) !== 0;
  (_a3 = captured_signals) == null ? void 0 : _a3.add(signal);
  if (active_reaction !== null && !untracking) {
    var destroyed = active_effect !== null && (active_effect.f & DESTROYED) !== 0;
    if (!destroyed && !(current_sources == null ? void 0 : current_sources.includes(signal))) {
      var deps = active_reaction.deps;
      if ((active_reaction.f & REACTION_IS_UPDATING) !== 0) {
        if (signal.rv < read_version) {
          signal.rv = read_version;
          if (new_deps === null && deps !== null && deps[skipped_deps] === signal) {
            skipped_deps++;
          } else if (new_deps === null) {
            new_deps = [signal];
          } else if (!new_deps.includes(signal)) {
            new_deps.push(signal);
          }
        }
      } else {
        ((_b3 = active_reaction.deps) != null ? _b3 : active_reaction.deps = []).push(signal);
        var reactions = signal.reactions;
        if (reactions === null) {
          signal.reactions = [active_reaction];
        } else if (!reactions.includes(active_reaction)) {
          reactions.push(active_reaction);
        }
      }
    }
  }
  if (dev_fallback_default) {
    recent_async_deriveds.delete(signal);
    if (tracing_mode_flag && !untracking && tracing_expressions !== null && active_reaction !== null && tracing_expressions.reaction === active_reaction) {
      if (signal.trace) {
        signal.trace();
      } else {
        var trace2 = get_error("traced at");
        if (trace2) {
          var entry = tracing_expressions.entries.get(signal);
          if (entry === void 0) {
            entry = { traces: [] };
            tracing_expressions.entries.set(signal, entry);
          }
          var last = entry.traces[entry.traces.length - 1];
          if (trace2.stack !== (last == null ? void 0 : last.stack)) {
            entry.traces.push(trace2);
          }
        }
      }
    }
  }
  if (is_destroying_effect) {
    if (old_values.has(signal)) {
      return old_values.get(signal);
    }
    if (is_derived) {
      var derived3 = (
        /** @type {Derived} */
        signal
      );
      var value = derived3.v;
      if ((derived3.f & CLEAN) === 0 && derived3.reactions !== null || depends_on_old_values(derived3)) {
        value = execute_derived(derived3);
      }
      old_values.set(derived3, value);
      return value;
    }
  } else if (is_derived && (!((_c2 = batch_values) == null ? void 0 : _c2.has(signal)) || ((_d = current_batch) == null ? void 0 : _d.is_fork) && !effect_tracking())) {
    derived3 = /** @type {Derived} */
    signal;
    if (is_dirty(derived3)) {
      update_derived(derived3);
    }
    if (is_updating_effect && effect_tracking() && (derived3.f & CONNECTED) === 0) {
      reconnect(derived3);
    }
  }
  if ((_e = batch_values) == null ? void 0 : _e.has(signal)) {
    return batch_values.get(signal);
  }
  if ((signal.f & ERROR_VALUE) !== 0) {
    throw signal.v;
  }
  return signal.v;
}
function reconnect(derived3) {
  var _a3;
  if (derived3.deps === null)
    return;
  derived3.f ^= CONNECTED;
  for (const dep of derived3.deps) {
    ((_a3 = dep.reactions) != null ? _a3 : dep.reactions = []).push(derived3);
    if ((dep.f & DERIVED) !== 0 && (dep.f & CONNECTED) === 0) {
      reconnect(
        /** @type {Derived} */
        dep
      );
    }
  }
}
function depends_on_old_values(derived3) {
  if (derived3.v === UNINITIALIZED)
    return true;
  if (derived3.deps === null)
    return false;
  for (const dep of derived3.deps) {
    if (old_values.has(dep)) {
      return true;
    }
    if ((dep.f & DERIVED) !== 0 && depends_on_old_values(
      /** @type {Derived} */
      dep
    )) {
      return true;
    }
  }
  return false;
}
function untrack(fn) {
  var previous_untracking = untracking;
  try {
    untracking = true;
    return fn();
  } finally {
    untracking = previous_untracking;
  }
}
var STATUS_MASK = ~(DIRTY | MAYBE_DIRTY | CLEAN);
function set_signal_status(signal, status) {
  signal.f = signal.f & STATUS_MASK | status;
}
function deep_read_state(value) {
  if (typeof value !== "object" || !value || value instanceof EventTarget) {
    return;
  }
  if (STATE_SYMBOL in value) {
    deep_read(value);
  } else if (!Array.isArray(value)) {
    for (let key2 in value) {
      const prop2 = value[key2];
      if (typeof prop2 === "object" && prop2 && STATE_SYMBOL in prop2) {
        deep_read(prop2);
      }
    }
  }
}
function deep_read(value, visited = /* @__PURE__ */ new Set()) {
  if (typeof value === "object" && value !== null && // We don't want to traverse DOM elements
  !(value instanceof EventTarget) && !visited.has(value)) {
    visited.add(value);
    if (value instanceof Date) {
      value.getTime();
    }
    for (let key2 in value) {
      try {
        deep_read(value[key2], visited);
      } catch (e2) {
      }
    }
    const proto = get_prototype_of(value);
    if (proto !== Object.prototype && proto !== Array.prototype && proto !== Map.prototype && proto !== Set.prototype && proto !== Date.prototype) {
      const descriptors = get_descriptors(proto);
      for (let key2 in descriptors) {
        const get3 = descriptors[key2].get;
        if (get3) {
          try {
            get3.call(value);
          } catch (e2) {
          }
        }
      }
    }
  }
}

// node_modules/svelte/src/internal/client/reactivity/effects.js
function validate_effect(rune) {
  if (active_effect === null) {
    if (active_reaction === null) {
      effect_orphan(rune);
    }
    effect_in_unowned_derived();
  }
  if (is_destroying_effect) {
    effect_in_teardown(rune);
  }
}
function push_effect(effect2, parent_effect) {
  var parent_last = parent_effect.last;
  if (parent_last === null) {
    parent_effect.last = parent_effect.first = effect2;
  } else {
    parent_last.next = effect2;
    effect2.prev = parent_last;
    parent_effect.last = effect2;
  }
}
function create_effect(type, fn, sync) {
  var _a3;
  var parent = active_effect;
  if (dev_fallback_default) {
    while (parent !== null && (parent.f & EAGER_EFFECT) !== 0) {
      parent = parent.parent;
    }
  }
  if (parent !== null && (parent.f & INERT) !== 0) {
    type |= INERT;
  }
  var effect2 = {
    ctx: component_context,
    deps: null,
    nodes: null,
    f: type | DIRTY | CONNECTED,
    first: null,
    fn,
    last: null,
    next: null,
    parent,
    b: parent && parent.b,
    prev: null,
    teardown: null,
    wv: 0,
    ac: null
  };
  if (dev_fallback_default) {
    effect2.component_function = dev_current_component_function;
  }
  if (sync) {
    try {
      update_effect(effect2);
      effect2.f |= EFFECT_RAN;
    } catch (e3) {
      destroy_effect(effect2);
      throw e3;
    }
  } else if (fn !== null) {
    schedule_effect(effect2);
  }
  var e2 = effect2;
  if (sync && e2.deps === null && e2.teardown === null && e2.nodes === null && e2.first === e2.last && // either `null`, or a singular child
  (e2.f & EFFECT_PRESERVED) === 0) {
    e2 = e2.first;
    if ((type & BLOCK_EFFECT) !== 0 && (type & EFFECT_TRANSPARENT) !== 0 && e2 !== null) {
      e2.f |= EFFECT_TRANSPARENT;
    }
  }
  if (e2 !== null) {
    e2.parent = parent;
    if (parent !== null) {
      push_effect(e2, parent);
    }
    if (active_reaction !== null && (active_reaction.f & DERIVED) !== 0 && (type & ROOT_EFFECT) === 0) {
      var derived3 = (
        /** @type {Derived} */
        active_reaction
      );
      ((_a3 = derived3.effects) != null ? _a3 : derived3.effects = []).push(e2);
    }
  }
  return effect2;
}
function effect_tracking() {
  return active_reaction !== null && !untracking;
}
function teardown(fn) {
  const effect2 = create_effect(RENDER_EFFECT, null, false);
  set_signal_status(effect2, CLEAN);
  effect2.teardown = fn;
  return effect2;
}
function user_effect(fn) {
  var _a3;
  validate_effect("$effect");
  if (dev_fallback_default) {
    define_property(fn, "name", {
      value: "$effect"
    });
  }
  var flags2 = (
    /** @type {Effect} */
    active_effect.f
  );
  var defer = !active_reaction && (flags2 & BRANCH_EFFECT) !== 0 && (flags2 & EFFECT_RAN) === 0;
  if (defer) {
    var context = (
      /** @type {ComponentContext} */
      component_context
    );
    ((_a3 = context.e) != null ? _a3 : context.e = []).push(fn);
  } else {
    return create_user_effect(fn);
  }
}
function create_user_effect(fn) {
  return create_effect(EFFECT | USER_EFFECT, fn, false);
}
function effect_root(fn) {
  Batch.ensure();
  const effect2 = create_effect(ROOT_EFFECT | EFFECT_PRESERVED, fn, true);
  return () => {
    destroy_effect(effect2);
  };
}
function component_root(fn) {
  Batch.ensure();
  const effect2 = create_effect(ROOT_EFFECT | EFFECT_PRESERVED, fn, true);
  return (options = {}) => {
    return new Promise((fulfil) => {
      if (options.outro) {
        pause_effect(effect2, () => {
          destroy_effect(effect2);
          fulfil(void 0);
        });
      } else {
        destroy_effect(effect2);
        fulfil(void 0);
      }
    });
  };
}
function effect(fn) {
  return create_effect(EFFECT, fn, false);
}
function async_effect(fn) {
  return create_effect(ASYNC | EFFECT_PRESERVED, fn, true);
}
function render_effect(fn, flags2 = 0) {
  return create_effect(RENDER_EFFECT | flags2, fn, true);
}
function template_effect(fn, sync = [], async2 = [], blockers = []) {
  flatten(blockers, sync, async2, (values) => {
    create_effect(RENDER_EFFECT, () => fn(...values.map(get)), true);
  });
}
function block(fn, flags2 = 0) {
  var effect2 = create_effect(BLOCK_EFFECT | flags2, fn, true);
  if (dev_fallback_default) {
    effect2.dev_stack = dev_stack;
  }
  return effect2;
}
function branch(fn) {
  return create_effect(BRANCH_EFFECT | EFFECT_PRESERVED, fn, true);
}
function execute_effect_teardown(effect2) {
  var teardown2 = effect2.teardown;
  if (teardown2 !== null) {
    const previously_destroying_effect = is_destroying_effect;
    const previous_reaction = active_reaction;
    set_is_destroying_effect(true);
    set_active_reaction(null);
    try {
      teardown2.call(null);
    } finally {
      set_is_destroying_effect(previously_destroying_effect);
      set_active_reaction(previous_reaction);
    }
  }
}
function destroy_effect_children(signal, remove_dom = false) {
  var effect2 = signal.first;
  signal.first = signal.last = null;
  while (effect2 !== null) {
    const controller = effect2.ac;
    if (controller !== null) {
      without_reactive_context(() => {
        controller.abort(STALE_REACTION);
      });
    }
    var next2 = effect2.next;
    if ((effect2.f & ROOT_EFFECT) !== 0) {
      effect2.parent = null;
    } else {
      destroy_effect(effect2, remove_dom);
    }
    effect2 = next2;
  }
}
function destroy_block_effect_children(signal) {
  var effect2 = signal.first;
  while (effect2 !== null) {
    var next2 = effect2.next;
    if ((effect2.f & BRANCH_EFFECT) === 0) {
      destroy_effect(effect2);
    }
    effect2 = next2;
  }
}
function destroy_effect(effect2, remove_dom = true) {
  var removed = false;
  if ((remove_dom || (effect2.f & HEAD_EFFECT) !== 0) && effect2.nodes !== null && effect2.nodes.end !== null) {
    remove_effect_dom(
      effect2.nodes.start,
      /** @type {TemplateNode} */
      effect2.nodes.end
    );
    removed = true;
  }
  destroy_effect_children(effect2, remove_dom && !removed);
  remove_reactions(effect2, 0);
  set_signal_status(effect2, DESTROYED);
  var transitions = effect2.nodes && effect2.nodes.t;
  if (transitions !== null) {
    for (const transition2 of transitions) {
      transition2.stop();
    }
  }
  execute_effect_teardown(effect2);
  var parent = effect2.parent;
  if (parent !== null && parent.first !== null) {
    unlink_effect(effect2);
  }
  if (dev_fallback_default) {
    effect2.component_function = null;
  }
  effect2.next = effect2.prev = effect2.teardown = effect2.ctx = effect2.deps = effect2.fn = effect2.nodes = effect2.ac = null;
}
function remove_effect_dom(node, end2) {
  while (node !== null) {
    var next2 = node === end2 ? null : get_next_sibling(node);
    node.remove();
    node = next2;
  }
}
function unlink_effect(effect2) {
  var parent = effect2.parent;
  var prev = effect2.prev;
  var next2 = effect2.next;
  if (prev !== null)
    prev.next = next2;
  if (next2 !== null)
    next2.prev = prev;
  if (parent !== null) {
    if (parent.first === effect2)
      parent.first = next2;
    if (parent.last === effect2)
      parent.last = prev;
  }
}
function pause_effect(effect2, callback, destroy = true) {
  var transitions = [];
  pause_children(effect2, transitions, true);
  var fn = () => {
    if (destroy)
      destroy_effect(effect2);
    if (callback)
      callback();
  };
  var remaining = transitions.length;
  if (remaining > 0) {
    var check = () => --remaining || fn();
    for (var transition2 of transitions) {
      transition2.out(check);
    }
  } else {
    fn();
  }
}
function pause_children(effect2, transitions, local) {
  if ((effect2.f & INERT) !== 0)
    return;
  effect2.f ^= INERT;
  var t3 = effect2.nodes && effect2.nodes.t;
  if (t3 !== null) {
    for (const transition2 of t3) {
      if (transition2.is_global || local) {
        transitions.push(transition2);
      }
    }
  }
  var child2 = effect2.first;
  while (child2 !== null) {
    var sibling2 = child2.next;
    var transparent = (child2.f & EFFECT_TRANSPARENT) !== 0 || // If this is a branch effect without a block effect parent,
    // it means the parent block effect was pruned. In that case,
    // transparency information was transferred to the branch effect.
    (child2.f & BRANCH_EFFECT) !== 0 && (effect2.f & BLOCK_EFFECT) !== 0;
    pause_children(child2, transitions, transparent ? local : false);
    child2 = sibling2;
  }
}
function resume_effect(effect2) {
  resume_children(effect2, true);
}
function resume_children(effect2, local) {
  if ((effect2.f & INERT) === 0)
    return;
  effect2.f ^= INERT;
  if ((effect2.f & CLEAN) === 0) {
    set_signal_status(effect2, DIRTY);
    schedule_effect(effect2);
  }
  var child2 = effect2.first;
  while (child2 !== null) {
    var sibling2 = child2.next;
    var transparent = (child2.f & EFFECT_TRANSPARENT) !== 0 || (child2.f & BRANCH_EFFECT) !== 0;
    resume_children(child2, transparent ? local : false);
    child2 = sibling2;
  }
  var t3 = effect2.nodes && effect2.nodes.t;
  if (t3 !== null) {
    for (const transition2 of t3) {
      if (transition2.is_global || local) {
        transition2.in();
      }
    }
  }
}
function move_effect(effect2, fragment) {
  if (!effect2.nodes)
    return;
  var node = effect2.nodes.start;
  var end2 = effect2.nodes.end;
  while (node !== null) {
    var next2 = node === end2 ? null : get_next_sibling(node);
    fragment.append(node);
    node = next2;
  }
}

// node_modules/svelte/src/utils.js
var DOM_BOOLEAN_ATTRIBUTES = [
  "allowfullscreen",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "disabled",
  "formnovalidate",
  "indeterminate",
  "inert",
  "ismap",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "seamless",
  "selected",
  "webkitdirectory",
  "defer",
  "disablepictureinpicture",
  "disableremoteplayback"
];
var DOM_PROPERTIES = [
  ...DOM_BOOLEAN_ATTRIBUTES,
  "formNoValidate",
  "isMap",
  "noModule",
  "playsInline",
  "readOnly",
  "value",
  "volume",
  "defaultValue",
  "defaultChecked",
  "srcObject",
  "noValidate",
  "allowFullscreen",
  "disablePictureInPicture",
  "disableRemotePlayback"
];
var PASSIVE_EVENTS = ["touchstart", "touchmove"];
function is_passive_event(name) {
  return PASSIVE_EVENTS.includes(name);
}
var STATE_CREATION_RUNES = (
  /** @type {const} */
  [
    "$state",
    "$state.raw",
    "$derived",
    "$derived.by"
  ]
);
var RUNES = (
  /** @type {const} */
  [
    ...STATE_CREATION_RUNES,
    "$state.eager",
    "$state.snapshot",
    "$props",
    "$props.id",
    "$bindable",
    "$effect",
    "$effect.pre",
    "$effect.tracking",
    "$effect.root",
    "$effect.pending",
    "$inspect",
    "$inspect().with",
    "$inspect.trace",
    "$host"
  ]
);

// node_modules/svelte/src/internal/client/dev/css.js
var all_styles = /* @__PURE__ */ new Map();
function register_style(hash2, style) {
  var styles = all_styles.get(hash2);
  if (!styles) {
    styles = /* @__PURE__ */ new Set();
    all_styles.set(hash2, styles);
  }
  styles.add(style);
}

// node_modules/svelte/src/internal/client/dom/elements/events.js
var all_registered_events = /* @__PURE__ */ new Set();
var root_event_handles = /* @__PURE__ */ new Set();
function create_event(event_name, dom, handler, options = {}) {
  function target_handler(event2) {
    if (!options.capture) {
      handle_event_propagation.call(dom, event2);
    }
    if (!event2.cancelBubble) {
      return without_reactive_context(() => {
        return handler == null ? void 0 : handler.call(this, event2);
      });
    }
  }
  if (event_name.startsWith("pointer") || event_name.startsWith("touch") || event_name === "wheel") {
    queue_micro_task(() => {
      dom.addEventListener(event_name, target_handler, options);
    });
  } else {
    dom.addEventListener(event_name, target_handler, options);
  }
  return target_handler;
}
function event(event_name, dom, handler, capture2, passive3) {
  var options = { capture: capture2, passive: passive3 };
  var target_handler = create_event(event_name, dom, handler, options);
  if (dom === document.body || // @ts-ignore
  dom === window || // @ts-ignore
  dom === document || // Firefox has quirky behavior, it can happen that we still get "canplay" events when the element is already removed
  dom instanceof HTMLMediaElement) {
    teardown(() => {
      dom.removeEventListener(event_name, target_handler, options);
    });
  }
}
function delegate(events) {
  for (var i3 = 0; i3 < events.length; i3++) {
    all_registered_events.add(events[i3]);
  }
  for (var fn of root_event_handles) {
    fn(events);
  }
}
var last_propagated_event = null;
function handle_event_propagation(event2) {
  var _a3;
  var handler_element = this;
  var owner_document = (
    /** @type {Node} */
    handler_element.ownerDocument
  );
  var event_name = event2.type;
  var path = ((_a3 = event2.composedPath) == null ? void 0 : _a3.call(event2)) || [];
  var current_target = (
    /** @type {null | Element} */
    path[0] || event2.target
  );
  last_propagated_event = event2;
  var path_idx = 0;
  var handled_at = last_propagated_event === event2 && event2.__root;
  if (handled_at) {
    var at_idx = path.indexOf(handled_at);
    if (at_idx !== -1 && (handler_element === document || handler_element === /** @type {any} */
    window)) {
      event2.__root = handler_element;
      return;
    }
    var handler_idx = path.indexOf(handler_element);
    if (handler_idx === -1) {
      return;
    }
    if (at_idx <= handler_idx) {
      path_idx = at_idx;
    }
  }
  current_target = /** @type {Element} */
  path[path_idx] || event2.target;
  if (current_target === handler_element)
    return;
  define_property(event2, "currentTarget", {
    configurable: true,
    get() {
      return current_target || owner_document;
    }
  });
  var previous_reaction = active_reaction;
  var previous_effect = active_effect;
  set_active_reaction(null);
  set_active_effect(null);
  try {
    var throw_error;
    var other_errors = [];
    while (current_target !== null) {
      var parent_element = current_target.assignedSlot || current_target.parentNode || /** @type {any} */
      current_target.host || null;
      try {
        var delegated = current_target["__" + event_name];
        if (delegated != null && (!/** @type {any} */
        current_target.disabled || // DOM could've been updated already by the time this is reached, so we check this as well
        // -> the target could not have been disabled because it emits the event in the first place
        event2.target === current_target)) {
          delegated.call(current_target, event2);
        }
      } catch (error) {
        if (throw_error) {
          other_errors.push(error);
        } else {
          throw_error = error;
        }
      }
      if (event2.cancelBubble || parent_element === handler_element || parent_element === null) {
        break;
      }
      current_target = parent_element;
    }
    if (throw_error) {
      for (let error of other_errors) {
        queueMicrotask(() => {
          throw error;
        });
      }
      throw throw_error;
    }
  } finally {
    event2.__root = handler_element;
    delete event2.currentTarget;
    set_active_reaction(previous_reaction);
    set_active_effect(previous_effect);
  }
}

// node_modules/svelte/src/internal/client/dom/reconciler.js
function create_fragment_from_html(html3) {
  var elem = document.createElement("template");
  elem.innerHTML = html3.replaceAll("<!>", "<!---->");
  return elem.content;
}

// node_modules/svelte/src/internal/client/dom/template.js
function assign_nodes(start2, end2) {
  var effect2 = (
    /** @type {Effect} */
    active_effect
  );
  if (effect2.nodes === null) {
    effect2.nodes = { start: start2, end: end2, a: null, t: null };
  }
}
// @__NO_SIDE_EFFECTS__
function from_html(content, flags2) {
  var is_fragment = (flags2 & TEMPLATE_FRAGMENT) !== 0;
  var use_import_node = (flags2 & TEMPLATE_USE_IMPORT_NODE) !== 0;
  var node;
  var has_start = !content.startsWith("<!>");
  return () => {
    if (hydrating) {
      assign_nodes(hydrate_node, null);
      return hydrate_node;
    }
    if (node === void 0) {
      node = create_fragment_from_html(has_start ? content : "<!>" + content);
      if (!is_fragment)
        node = /** @type {TemplateNode} */
        get_first_child(node);
    }
    var clone = (
      /** @type {TemplateNode} */
      use_import_node || is_firefox ? document.importNode(node, true) : node.cloneNode(true)
    );
    if (is_fragment) {
      var start2 = (
        /** @type {TemplateNode} */
        get_first_child(clone)
      );
      var end2 = (
        /** @type {TemplateNode} */
        clone.lastChild
      );
      assign_nodes(start2, end2);
    } else {
      assign_nodes(clone, clone);
    }
    return clone;
  };
}
function comment() {
  if (hydrating) {
    assign_nodes(hydrate_node, null);
    return hydrate_node;
  }
  var frag = document.createDocumentFragment();
  var start2 = document.createComment("");
  var anchor = create_text();
  frag.append(start2, anchor);
  assign_nodes(start2, anchor);
  return frag;
}
function append(anchor, dom) {
  if (hydrating) {
    var effect2 = (
      /** @type {Effect & { nodes: EffectNodes }} */
      active_effect
    );
    if ((effect2.f & EFFECT_RAN) === 0 || effect2.nodes.end === null) {
      effect2.nodes.end = hydrate_node;
    }
    hydrate_next();
    return;
  }
  if (anchor === null) {
    return;
  }
  anchor.before(
    /** @type {Node} */
    dom
  );
}

// node_modules/svelte/src/internal/client/render.js
var should_intro = true;
function set_text(text2, value) {
  var _a3;
  var str = value == null ? "" : typeof value === "object" ? value + "" : value;
  if (str !== ((_a3 = text2.__t) != null ? _a3 : text2.__t = text2.nodeValue)) {
    text2.__t = str;
    text2.nodeValue = str + "";
  }
}
function mount(component2, options) {
  return _mount(component2, options);
}
function hydrate(component2, options) {
  var _a3;
  init_operations();
  options.intro = (_a3 = options.intro) != null ? _a3 : false;
  const target = options.target;
  const was_hydrating = hydrating;
  const previous_hydrate_node = hydrate_node;
  try {
    var anchor = get_first_child(target);
    while (anchor && (anchor.nodeType !== COMMENT_NODE || /** @type {Comment} */
    anchor.data !== HYDRATION_START)) {
      anchor = get_next_sibling(anchor);
    }
    if (!anchor) {
      throw HYDRATION_ERROR;
    }
    set_hydrating(true);
    set_hydrate_node(
      /** @type {Comment} */
      anchor
    );
    const instance = _mount(component2, { ...options, anchor });
    set_hydrating(false);
    return (
      /**  @type {Exports} */
      instance
    );
  } catch (error) {
    if (error instanceof Error && error.message.split("\n").some((line) => line.startsWith("https://svelte.dev/e/"))) {
      throw error;
    }
    if (error !== HYDRATION_ERROR) {
      console.warn("Failed to hydrate: ", error);
    }
    if (options.recover === false) {
      hydration_failed();
    }
    init_operations();
    clear_text_content(target);
    set_hydrating(false);
    return mount(component2, options);
  } finally {
    set_hydrating(was_hydrating);
    set_hydrate_node(previous_hydrate_node);
  }
}
var document_listeners = /* @__PURE__ */ new Map();
function _mount(Component, { target, anchor, props = {}, events, context, intro = true }) {
  init_operations();
  var registered_events = /* @__PURE__ */ new Set();
  var event_handle = (events2) => {
    for (var i3 = 0; i3 < events2.length; i3++) {
      var event_name = events2[i3];
      if (registered_events.has(event_name))
        continue;
      registered_events.add(event_name);
      var passive3 = is_passive_event(event_name);
      target.addEventListener(event_name, handle_event_propagation, { passive: passive3 });
      var n3 = document_listeners.get(event_name);
      if (n3 === void 0) {
        document.addEventListener(event_name, handle_event_propagation, { passive: passive3 });
        document_listeners.set(event_name, 1);
      } else {
        document_listeners.set(event_name, n3 + 1);
      }
    }
  };
  event_handle(array_from(all_registered_events));
  root_event_handles.add(event_handle);
  var component2 = void 0;
  var unmount2 = component_root(() => {
    var anchor_node = anchor != null ? anchor : target.appendChild(create_text());
    boundary(
      /** @type {TemplateNode} */
      anchor_node,
      {
        pending: () => {
        }
      },
      (anchor_node2) => {
        if (context) {
          push({});
          var ctx = (
            /** @type {ComponentContext} */
            component_context
          );
          ctx.c = context;
        }
        if (events) {
          props.$$events = events;
        }
        if (hydrating) {
          assign_nodes(
            /** @type {TemplateNode} */
            anchor_node2,
            null
          );
        }
        should_intro = intro;
        component2 = Component(anchor_node2, props) || {};
        should_intro = true;
        if (hydrating) {
          active_effect.nodes.end = hydrate_node;
          if (hydrate_node === null || hydrate_node.nodeType !== COMMENT_NODE || /** @type {Comment} */
          hydrate_node.data !== HYDRATION_END) {
            hydration_mismatch();
            throw HYDRATION_ERROR;
          }
        }
        if (context) {
          pop();
        }
      }
    );
    return () => {
      var _a3;
      for (var event_name of registered_events) {
        target.removeEventListener(event_name, handle_event_propagation);
        var n3 = (
          /** @type {number} */
          document_listeners.get(event_name)
        );
        if (--n3 === 0) {
          document.removeEventListener(event_name, handle_event_propagation);
          document_listeners.delete(event_name);
        } else {
          document_listeners.set(event_name, n3);
        }
      }
      root_event_handles.delete(event_handle);
      if (anchor_node !== anchor) {
        (_a3 = anchor_node.parentNode) == null ? void 0 : _a3.removeChild(anchor_node);
      }
    };
  });
  mounted_components.set(component2, unmount2);
  return component2;
}
var mounted_components = /* @__PURE__ */ new WeakMap();
function unmount(component2, options) {
  const fn = mounted_components.get(component2);
  if (fn) {
    mounted_components.delete(component2);
    return fn(options);
  }
  if (dev_fallback_default) {
    if (STATE_SYMBOL in component2) {
      state_proxy_unmount();
    } else {
      lifecycle_double_unmount();
    }
  }
  return Promise.resolve();
}

// node_modules/svelte/src/internal/client/dom/blocks/branches.js
var _batches, _onscreen, _offscreen, _outroing, _transition, _commit2, _discard;
var BranchManager = class {
  /**
   * @param {TemplateNode} anchor
   * @param {boolean} transition
   */
  constructor(anchor, transition2 = true) {
    /** @type {TemplateNode} */
    __publicField(this, "anchor");
    /** @type {Map<Batch, Key>} */
    __privateAdd(this, _batches, /* @__PURE__ */ new Map());
    /**
     * Map of keys to effects that are currently rendered in the DOM.
     * These effects are visible and actively part of the document tree.
     * Example:
     * ```
     * {#if condition}
     * 	foo
     * {:else}
     * 	bar
     * {/if}
     * ```
     * Can result in the entries `true->Effect` and `false->Effect`
     * @type {Map<Key, Effect>}
     */
    __privateAdd(this, _onscreen, /* @__PURE__ */ new Map());
    /**
     * Similar to #onscreen with respect to the keys, but contains branches that are not yet
     * in the DOM, because their insertion is deferred.
     * @type {Map<Key, Branch>}
     */
    __privateAdd(this, _offscreen, /* @__PURE__ */ new Map());
    /**
     * Keys of effects that are currently outroing
     * @type {Set<Key>}
     */
    __privateAdd(this, _outroing, /* @__PURE__ */ new Set());
    /**
     * Whether to pause (i.e. outro) on change, or destroy immediately.
     * This is necessary for `<svelte:element>`
     */
    __privateAdd(this, _transition, true);
    __privateAdd(this, _commit2, () => {
      var batch = (
        /** @type {Batch} */
        current_batch
      );
      if (!__privateGet(this, _batches).has(batch))
        return;
      var key2 = (
        /** @type {Key} */
        __privateGet(this, _batches).get(batch)
      );
      var onscreen = __privateGet(this, _onscreen).get(key2);
      if (onscreen) {
        resume_effect(onscreen);
        __privateGet(this, _outroing).delete(key2);
      } else {
        var offscreen = __privateGet(this, _offscreen).get(key2);
        if (offscreen) {
          __privateGet(this, _onscreen).set(key2, offscreen.effect);
          __privateGet(this, _offscreen).delete(key2);
          offscreen.fragment.lastChild.remove();
          this.anchor.before(offscreen.fragment);
          onscreen = offscreen.effect;
        }
      }
      for (const [b, k2] of __privateGet(this, _batches)) {
        __privateGet(this, _batches).delete(b);
        if (b === batch) {
          break;
        }
        const offscreen2 = __privateGet(this, _offscreen).get(k2);
        if (offscreen2) {
          destroy_effect(offscreen2.effect);
          __privateGet(this, _offscreen).delete(k2);
        }
      }
      for (const [k2, effect2] of __privateGet(this, _onscreen)) {
        if (k2 === key2 || __privateGet(this, _outroing).has(k2))
          continue;
        const on_destroy = () => {
          const keys = Array.from(__privateGet(this, _batches).values());
          if (keys.includes(k2)) {
            var fragment = document.createDocumentFragment();
            move_effect(effect2, fragment);
            fragment.append(create_text());
            __privateGet(this, _offscreen).set(k2, { effect: effect2, fragment });
          } else {
            destroy_effect(effect2);
          }
          __privateGet(this, _outroing).delete(k2);
          __privateGet(this, _onscreen).delete(k2);
        };
        if (__privateGet(this, _transition) || !onscreen) {
          __privateGet(this, _outroing).add(k2);
          pause_effect(effect2, on_destroy, false);
        } else {
          on_destroy();
        }
      }
    });
    /**
     * @param {Batch} batch
     */
    __privateAdd(this, _discard, (batch) => {
      __privateGet(this, _batches).delete(batch);
      const keys = Array.from(__privateGet(this, _batches).values());
      for (const [k2, branch2] of __privateGet(this, _offscreen)) {
        if (!keys.includes(k2)) {
          destroy_effect(branch2.effect);
          __privateGet(this, _offscreen).delete(k2);
        }
      }
    });
    this.anchor = anchor;
    __privateSet(this, _transition, transition2);
  }
  /**
   *
   * @param {any} key
   * @param {null | ((target: TemplateNode) => void)} fn
   */
  ensure(key2, fn) {
    var batch = (
      /** @type {Batch} */
      current_batch
    );
    var defer = should_defer_append();
    if (fn && !__privateGet(this, _onscreen).has(key2) && !__privateGet(this, _offscreen).has(key2)) {
      if (defer) {
        var fragment = document.createDocumentFragment();
        var target = create_text();
        fragment.append(target);
        __privateGet(this, _offscreen).set(key2, {
          effect: branch(() => fn(target)),
          fragment
        });
      } else {
        __privateGet(this, _onscreen).set(
          key2,
          branch(() => fn(this.anchor))
        );
      }
    }
    __privateGet(this, _batches).set(batch, key2);
    if (defer) {
      for (const [k2, effect2] of __privateGet(this, _onscreen)) {
        if (k2 === key2) {
          batch.skipped_effects.delete(effect2);
        } else {
          batch.skipped_effects.add(effect2);
        }
      }
      for (const [k2, branch2] of __privateGet(this, _offscreen)) {
        if (k2 === key2) {
          batch.skipped_effects.delete(branch2.effect);
        } else {
          batch.skipped_effects.add(branch2.effect);
        }
      }
      batch.oncommit(__privateGet(this, _commit2));
      batch.ondiscard(__privateGet(this, _discard));
    } else {
      if (hydrating) {
        this.anchor = hydrate_node;
      }
      __privateGet(this, _commit2).call(this);
    }
  }
};
_batches = new WeakMap();
_onscreen = new WeakMap();
_offscreen = new WeakMap();
_outroing = new WeakMap();
_transition = new WeakMap();
_commit2 = new WeakMap();
_discard = new WeakMap();

// node_modules/svelte/src/internal/client/dom/blocks/if.js
function if_block(node, fn, elseif = false) {
  if (hydrating) {
    hydrate_next();
  }
  var branches = new BranchManager(node);
  var flags2 = elseif ? EFFECT_TRANSPARENT : 0;
  function update_branch(condition, fn2) {
    if (hydrating) {
      const is_else = read_hydration_instruction(node) === HYDRATION_START_ELSE;
      if (condition === is_else) {
        var anchor = skip_nodes();
        set_hydrate_node(anchor);
        branches.anchor = anchor;
        set_hydrating(false);
        branches.ensure(condition, fn2);
        set_hydrating(true);
        return;
      }
    }
    branches.ensure(condition, fn2);
  }
  block(() => {
    var has_branch = false;
    fn((fn2, flag = true) => {
      has_branch = true;
      update_branch(flag, fn2);
    });
    if (!has_branch) {
      update_branch(false, null);
    }
  }, flags2);
}

// node_modules/svelte/src/internal/client/dom/blocks/each.js
function index(_2, i3) {
  return i3;
}
function pause_effects(state2, to_destroy, controlled_anchor) {
  var _a3;
  var transitions = [];
  var length2 = to_destroy.length;
  var group;
  var remaining = to_destroy.length;
  for (var i3 = 0; i3 < length2; i3++) {
    let effect2 = to_destroy[i3];
    pause_effect(
      effect2,
      () => {
        if (group) {
          group.pending.delete(effect2);
          group.done.add(effect2);
          if (group.pending.size === 0) {
            var groups = (
              /** @type {Set<EachOutroGroup>} */
              state2.outrogroups
            );
            destroy_effects(array_from(group.done));
            groups.delete(group);
            if (groups.size === 0) {
              state2.outrogroups = null;
            }
          }
        } else {
          remaining -= 1;
        }
      },
      false
    );
  }
  if (remaining === 0) {
    var fast_path = transitions.length === 0 && controlled_anchor !== null;
    if (fast_path) {
      var anchor = (
        /** @type {Element} */
        controlled_anchor
      );
      var parent_node = (
        /** @type {Element} */
        anchor.parentNode
      );
      clear_text_content(parent_node);
      parent_node.append(anchor);
      state2.items.clear();
    }
    destroy_effects(to_destroy, !fast_path);
  } else {
    group = {
      pending: new Set(to_destroy),
      done: /* @__PURE__ */ new Set()
    };
    ((_a3 = state2.outrogroups) != null ? _a3 : state2.outrogroups = /* @__PURE__ */ new Set()).add(group);
  }
}
function destroy_effects(to_destroy, remove_dom = true) {
  for (var i3 = 0; i3 < to_destroy.length; i3++) {
    destroy_effect(to_destroy[i3], remove_dom);
  }
}
var offscreen_anchor;
function each(node, flags2, get_collection, get_key, render_fn, fallback_fn = null) {
  var anchor = node;
  var items = /* @__PURE__ */ new Map();
  var is_controlled = (flags2 & EACH_IS_CONTROLLED) !== 0;
  if (is_controlled) {
    var parent_node = (
      /** @type {Element} */
      node
    );
    anchor = hydrating ? set_hydrate_node(get_first_child(parent_node)) : parent_node.appendChild(create_text());
  }
  if (hydrating) {
    hydrate_next();
  }
  var fallback3 = null;
  var each_array = derived_safe_equal(() => {
    var collection = get_collection();
    return is_array(collection) ? collection : collection == null ? [] : array_from(collection);
  });
  var array;
  var first_run = true;
  function commit() {
    state2.fallback = fallback3;
    reconcile(state2, array, anchor, flags2, get_key);
    if (fallback3 !== null) {
      if (array.length === 0) {
        if ((fallback3.f & EFFECT_OFFSCREEN) === 0) {
          resume_effect(fallback3);
        } else {
          fallback3.f ^= EFFECT_OFFSCREEN;
          move(fallback3, null, anchor);
        }
      } else {
        pause_effect(fallback3, () => {
          fallback3 = null;
        });
      }
    }
  }
  var effect2 = block(() => {
    array = /** @type {V[]} */
    get(each_array);
    var length2 = array.length;
    let mismatch = false;
    if (hydrating) {
      var is_else = read_hydration_instruction(anchor) === HYDRATION_START_ELSE;
      if (is_else !== (length2 === 0)) {
        anchor = skip_nodes();
        set_hydrate_node(anchor);
        set_hydrating(false);
        mismatch = true;
      }
    }
    var keys = /* @__PURE__ */ new Set();
    var batch = (
      /** @type {Batch} */
      current_batch
    );
    var defer = should_defer_append();
    for (var index4 = 0; index4 < length2; index4 += 1) {
      if (hydrating && hydrate_node.nodeType === COMMENT_NODE && /** @type {Comment} */
      hydrate_node.data === HYDRATION_END) {
        anchor = /** @type {Comment} */
        hydrate_node;
        mismatch = true;
        set_hydrating(false);
      }
      var value = array[index4];
      var key2 = get_key(value, index4);
      var item = first_run ? null : items.get(key2);
      if (item) {
        if (item.v)
          internal_set(item.v, value);
        if (item.i)
          internal_set(item.i, index4);
        if (defer) {
          batch.skipped_effects.delete(item.e);
        }
      } else {
        item = create_item(
          items,
          first_run ? anchor : offscreen_anchor != null ? offscreen_anchor : offscreen_anchor = create_text(),
          value,
          key2,
          index4,
          render_fn,
          flags2,
          get_collection
        );
        if (!first_run) {
          item.e.f |= EFFECT_OFFSCREEN;
        }
        items.set(key2, item);
      }
      keys.add(key2);
    }
    if (length2 === 0 && fallback_fn && !fallback3) {
      if (first_run) {
        fallback3 = branch(() => fallback_fn(anchor));
      } else {
        fallback3 = branch(() => fallback_fn(offscreen_anchor != null ? offscreen_anchor : offscreen_anchor = create_text()));
        fallback3.f |= EFFECT_OFFSCREEN;
      }
    }
    if (hydrating && length2 > 0) {
      set_hydrate_node(skip_nodes());
    }
    if (!first_run) {
      if (defer) {
        for (const [key3, item2] of items) {
          if (!keys.has(key3)) {
            batch.skipped_effects.add(item2.e);
          }
        }
        batch.oncommit(commit);
        batch.ondiscard(() => {
        });
      } else {
        commit();
      }
    }
    if (mismatch) {
      set_hydrating(true);
    }
    get(each_array);
  });
  var state2 = { effect: effect2, flags: flags2, items, outrogroups: null, fallback: fallback3 };
  first_run = false;
  if (hydrating) {
    anchor = hydrate_node;
  }
}
function reconcile(state2, array, anchor, flags2, get_key) {
  var _a3, _b3, _c2, _d, _e, _f, _g, _h, _i;
  var is_animated = (flags2 & EACH_IS_ANIMATED) !== 0;
  var length2 = array.length;
  var items = state2.items;
  var current = state2.effect.first;
  var seen;
  var prev = null;
  var to_animate;
  var matched = [];
  var stashed = [];
  var value;
  var key2;
  var effect2;
  var i3;
  if (is_animated) {
    for (i3 = 0; i3 < length2; i3 += 1) {
      value = array[i3];
      key2 = get_key(value, i3);
      effect2 = /** @type {EachItem} */
      items.get(key2).e;
      if ((effect2.f & EFFECT_OFFSCREEN) === 0) {
        (_b3 = (_a3 = effect2.nodes) == null ? void 0 : _a3.a) == null ? void 0 : _b3.measure();
        (to_animate != null ? to_animate : to_animate = /* @__PURE__ */ new Set()).add(effect2);
      }
    }
  }
  for (i3 = 0; i3 < length2; i3 += 1) {
    value = array[i3];
    key2 = get_key(value, i3);
    effect2 = /** @type {EachItem} */
    items.get(key2).e;
    if (state2.outrogroups !== null) {
      for (const group of state2.outrogroups) {
        group.pending.delete(effect2);
        group.done.delete(effect2);
      }
    }
    if ((effect2.f & EFFECT_OFFSCREEN) !== 0) {
      effect2.f ^= EFFECT_OFFSCREEN;
      if (effect2 === current) {
        move(effect2, null, anchor);
      } else {
        var next2 = prev ? prev.next : current;
        if (effect2 === state2.effect.last) {
          state2.effect.last = effect2.prev;
        }
        if (effect2.prev)
          effect2.prev.next = effect2.next;
        if (effect2.next)
          effect2.next.prev = effect2.prev;
        link(state2, prev, effect2);
        link(state2, effect2, next2);
        move(effect2, next2, anchor);
        prev = effect2;
        matched = [];
        stashed = [];
        current = prev.next;
        continue;
      }
    }
    if ((effect2.f & INERT) !== 0) {
      resume_effect(effect2);
      if (is_animated) {
        (_d = (_c2 = effect2.nodes) == null ? void 0 : _c2.a) == null ? void 0 : _d.unfix();
        (to_animate != null ? to_animate : to_animate = /* @__PURE__ */ new Set()).delete(effect2);
      }
    }
    if (effect2 !== current) {
      if (seen !== void 0 && seen.has(effect2)) {
        if (matched.length < stashed.length) {
          var start2 = stashed[0];
          var j2;
          prev = start2.prev;
          var a2 = matched[0];
          var b = matched[matched.length - 1];
          for (j2 = 0; j2 < matched.length; j2 += 1) {
            move(matched[j2], start2, anchor);
          }
          for (j2 = 0; j2 < stashed.length; j2 += 1) {
            seen.delete(stashed[j2]);
          }
          link(state2, a2.prev, b.next);
          link(state2, prev, a2);
          link(state2, b, start2);
          current = start2;
          prev = b;
          i3 -= 1;
          matched = [];
          stashed = [];
        } else {
          seen.delete(effect2);
          move(effect2, current, anchor);
          link(state2, effect2.prev, effect2.next);
          link(state2, effect2, prev === null ? state2.effect.first : prev.next);
          link(state2, prev, effect2);
          prev = effect2;
        }
        continue;
      }
      matched = [];
      stashed = [];
      while (current !== null && current !== effect2) {
        (seen != null ? seen : seen = /* @__PURE__ */ new Set()).add(current);
        stashed.push(current);
        current = current.next;
      }
      if (current === null) {
        continue;
      }
    }
    if ((effect2.f & EFFECT_OFFSCREEN) === 0) {
      matched.push(effect2);
    }
    prev = effect2;
    current = effect2.next;
  }
  if (state2.outrogroups !== null) {
    for (const group of state2.outrogroups) {
      if (group.pending.size === 0) {
        destroy_effects(array_from(group.done));
        (_e = state2.outrogroups) == null ? void 0 : _e.delete(group);
      }
    }
    if (state2.outrogroups.size === 0) {
      state2.outrogroups = null;
    }
  }
  if (current !== null || seen !== void 0) {
    var to_destroy = [];
    if (seen !== void 0) {
      for (effect2 of seen) {
        if ((effect2.f & INERT) === 0) {
          to_destroy.push(effect2);
        }
      }
    }
    while (current !== null) {
      if ((current.f & INERT) === 0 && current !== state2.fallback) {
        to_destroy.push(current);
      }
      current = current.next;
    }
    var destroy_length = to_destroy.length;
    if (destroy_length > 0) {
      var controlled_anchor = (flags2 & EACH_IS_CONTROLLED) !== 0 && length2 === 0 ? anchor : null;
      if (is_animated) {
        for (i3 = 0; i3 < destroy_length; i3 += 1) {
          (_g = (_f = to_destroy[i3].nodes) == null ? void 0 : _f.a) == null ? void 0 : _g.measure();
        }
        for (i3 = 0; i3 < destroy_length; i3 += 1) {
          (_i = (_h = to_destroy[i3].nodes) == null ? void 0 : _h.a) == null ? void 0 : _i.fix();
        }
      }
      pause_effects(state2, to_destroy, controlled_anchor);
    }
  }
  if (is_animated) {
    queue_micro_task(() => {
      var _a4, _b4;
      if (to_animate === void 0)
        return;
      for (effect2 of to_animate) {
        (_b4 = (_a4 = effect2.nodes) == null ? void 0 : _a4.a) == null ? void 0 : _b4.apply();
      }
    });
  }
}
function create_item(items, anchor, value, key2, index4, render_fn, flags2, get_collection) {
  var v2 = (flags2 & EACH_ITEM_REACTIVE) !== 0 ? (flags2 & EACH_ITEM_IMMUTABLE) === 0 ? mutable_source(value, false, false) : source(value) : null;
  var i3 = (flags2 & EACH_INDEX_REACTIVE) !== 0 ? source(index4) : null;
  if (dev_fallback_default && v2) {
    v2.trace = () => {
      var _a3;
      get_collection()[(_a3 = i3 == null ? void 0 : i3.v) != null ? _a3 : index4];
    };
  }
  return {
    v: v2,
    i: i3,
    e: branch(() => {
      render_fn(anchor, v2 != null ? v2 : value, i3 != null ? i3 : index4, get_collection);
      return () => {
        items.delete(key2);
      };
    })
  };
}
function move(effect2, next2, anchor) {
  if (!effect2.nodes)
    return;
  var node = effect2.nodes.start;
  var end2 = effect2.nodes.end;
  var dest = next2 && (next2.f & EFFECT_OFFSCREEN) === 0 ? (
    /** @type {EffectNodes} */
    next2.nodes.start
  ) : anchor;
  while (node !== null) {
    var next_node = (
      /** @type {TemplateNode} */
      get_next_sibling(node)
    );
    dest.before(node);
    if (node === end2) {
      return;
    }
    node = next_node;
  }
}
function link(state2, prev, next2) {
  if (prev === null) {
    state2.effect.first = next2;
  } else {
    prev.next = next2;
  }
  if (next2 === null) {
    state2.effect.last = prev;
  } else {
    next2.prev = prev;
  }
}

// node_modules/svelte/src/internal/client/timing.js
var now = true_default ? () => performance.now() : () => Date.now();
var raf = {
  // don't access requestAnimationFrame eagerly outside method
  // this allows basic testing of user code without JSDOM
  // bunder will eval and remove ternary when the user's app is built
  tick: (
    /** @param {any} _ */
    (_2) => (true_default ? requestAnimationFrame : noop)(_2)
  ),
  now: () => now(),
  tasks: /* @__PURE__ */ new Set()
};

// node_modules/svelte/src/internal/client/loop.js
function run_tasks() {
  const now2 = raf.now();
  raf.tasks.forEach((task) => {
    if (!task.c(now2)) {
      raf.tasks.delete(task);
      task.f();
    }
  });
  if (raf.tasks.size !== 0) {
    raf.tick(run_tasks);
  }
}
function loop(callback) {
  let task;
  if (raf.tasks.size === 0) {
    raf.tick(run_tasks);
  }
  return {
    promise: new Promise((fulfill) => {
      raf.tasks.add(task = { c: callback, f: fulfill });
    }),
    abort() {
      raf.tasks.delete(task);
    }
  };
}

// node_modules/svelte/src/internal/client/dom/elements/transitions.js
function dispatch_event(element2, type) {
  without_reactive_context(() => {
    element2.dispatchEvent(new CustomEvent(type));
  });
}
function css_property_to_camelcase(style) {
  if (style === "float")
    return "cssFloat";
  if (style === "offset")
    return "cssOffset";
  if (style.startsWith("--"))
    return style;
  const parts = style.split("-");
  if (parts.length === 1)
    return parts[0];
  return parts[0] + parts.slice(1).map(
    /** @param {any} word */
    (word) => word[0].toUpperCase() + word.slice(1)
  ).join("");
}
function css_to_keyframe(css) {
  const keyframe = {};
  const parts = css.split(";");
  for (const part of parts) {
    const [property, value] = part.split(":");
    if (!property || value === void 0)
      break;
    const formatted_property = css_property_to_camelcase(property.trim());
    keyframe[formatted_property] = value.trim();
  }
  return keyframe;
}
var linear = (t3) => t3;
var animation_effect_override = null;
function animation(element2, get_fn, get_params) {
  var _a3;
  var effect2 = animation_effect_override != null ? animation_effect_override : (
    /** @type {Effect} */
    active_effect
  );
  var nodes = (
    /** @type {EffectNodes} */
    effect2.nodes
  );
  var from;
  var to;
  var animation2;
  var original_styles = null;
  (_a3 = nodes.a) != null ? _a3 : nodes.a = {
    element: element2,
    measure() {
      from = this.element.getBoundingClientRect();
    },
    apply() {
      animation2 == null ? void 0 : animation2.abort();
      to = this.element.getBoundingClientRect();
      if (from.left !== to.left || from.right !== to.right || from.top !== to.top || from.bottom !== to.bottom) {
        const options = get_fn()(this.element, { from, to }, get_params == null ? void 0 : get_params());
        animation2 = animate(this.element, options, void 0, 1, () => {
          animation2 == null ? void 0 : animation2.abort();
          animation2 = void 0;
        });
      }
    },
    fix() {
      if (element2.getAnimations().length)
        return;
      var { position, width, height } = getComputedStyle(element2);
      if (position !== "absolute" && position !== "fixed") {
        var style = (
          /** @type {HTMLElement | SVGElement} */
          element2.style
        );
        original_styles = {
          position: style.position,
          width: style.width,
          height: style.height,
          transform: style.transform
        };
        style.position = "absolute";
        style.width = width;
        style.height = height;
        var to2 = element2.getBoundingClientRect();
        if (from.left !== to2.left || from.top !== to2.top) {
          var transform = `translate(${from.left - to2.left}px, ${from.top - to2.top}px)`;
          style.transform = style.transform ? `${style.transform} ${transform}` : transform;
        }
      }
    },
    unfix() {
      if (original_styles) {
        var style = (
          /** @type {HTMLElement | SVGElement} */
          element2.style
        );
        style.position = original_styles.position;
        style.width = original_styles.width;
        style.height = original_styles.height;
        style.transform = original_styles.transform;
      }
    }
  };
  nodes.a.element = element2;
}
function transition(flags2, element2, get_fn, get_params) {
  var _a3, _b3;
  var is_intro = (flags2 & TRANSITION_IN) !== 0;
  var is_outro = (flags2 & TRANSITION_OUT) !== 0;
  var is_both = is_intro && is_outro;
  var is_global = (flags2 & TRANSITION_GLOBAL) !== 0;
  var direction = is_both ? "both" : is_intro ? "in" : "out";
  var current_options;
  var inert = element2.inert;
  var overflow = element2.style.overflow;
  var intro;
  var outro;
  function get_options() {
    return without_reactive_context(() => {
      var _a4;
      return current_options != null ? current_options : current_options = get_fn()(element2, (_a4 = get_params == null ? void 0 : get_params()) != null ? _a4 : (
        /** @type {P} */
        {}
      ), {
        direction
      });
    });
  }
  var transition2 = {
    is_global,
    in() {
      var _a4;
      element2.inert = inert;
      if (!is_intro) {
        outro == null ? void 0 : outro.abort();
        (_a4 = outro == null ? void 0 : outro.reset) == null ? void 0 : _a4.call(outro);
        return;
      }
      if (!is_outro) {
        intro == null ? void 0 : intro.abort();
      }
      dispatch_event(element2, "introstart");
      intro = animate(element2, get_options(), outro, 1, () => {
        dispatch_event(element2, "introend");
        intro == null ? void 0 : intro.abort();
        intro = current_options = void 0;
        element2.style.overflow = overflow;
      });
    },
    out(fn) {
      if (!is_outro) {
        fn == null ? void 0 : fn();
        current_options = void 0;
        return;
      }
      element2.inert = true;
      dispatch_event(element2, "outrostart");
      outro = animate(element2, get_options(), intro, 0, () => {
        dispatch_event(element2, "outroend");
        fn == null ? void 0 : fn();
      });
    },
    stop: () => {
      intro == null ? void 0 : intro.abort();
      outro == null ? void 0 : outro.abort();
    }
  };
  var e2 = (
    /** @type {Effect & { nodes: EffectNodes }} */
    active_effect
  );
  ((_b3 = (_a3 = e2.nodes).t) != null ? _b3 : _a3.t = []).push(transition2);
  if (is_intro && should_intro) {
    var run3 = is_global;
    if (!run3) {
      var block2 = (
        /** @type {Effect | null} */
        e2.parent
      );
      while (block2 && (block2.f & EFFECT_TRANSPARENT) !== 0) {
        while (block2 = block2.parent) {
          if ((block2.f & BLOCK_EFFECT) !== 0)
            break;
        }
      }
      run3 = !block2 || (block2.f & EFFECT_RAN) !== 0;
    }
    if (run3) {
      effect(() => {
        untrack(() => transition2.in());
      });
    }
  }
}
function animate(element2, options, counterpart, t22, on_finish) {
  var is_intro = t22 === 1;
  if (is_function(options)) {
    var a2;
    var aborted2 = false;
    queue_micro_task(() => {
      if (aborted2)
        return;
      var o2 = options({ direction: is_intro ? "in" : "out" });
      a2 = animate(element2, o2, counterpart, t22, on_finish);
    });
    return {
      abort: () => {
        aborted2 = true;
        a2 == null ? void 0 : a2.abort();
      },
      deactivate: () => a2.deactivate(),
      reset: () => a2.reset(),
      t: () => a2.t()
    };
  }
  counterpart == null ? void 0 : counterpart.deactivate();
  if (!(options == null ? void 0 : options.duration)) {
    on_finish();
    return {
      abort: noop,
      deactivate: noop,
      reset: noop,
      t: () => t22
    };
  }
  const { delay = 0, css, tick: tick2, easing = linear } = options;
  var keyframes = [];
  if (is_intro && counterpart === void 0) {
    if (tick2) {
      tick2(0, 1);
    }
    if (css) {
      var styles = css_to_keyframe(css(0, 1));
      keyframes.push(styles, styles);
    }
  }
  var get_t = () => 1 - t22;
  var animation2 = element2.animate(keyframes, { duration: delay, fill: "forwards" });
  animation2.onfinish = () => {
    var _a3;
    animation2.cancel();
    var t1 = (_a3 = counterpart == null ? void 0 : counterpart.t()) != null ? _a3 : 1 - t22;
    counterpart == null ? void 0 : counterpart.abort();
    var delta = t22 - t1;
    var duration = (
      /** @type {number} */
      options.duration * Math.abs(delta)
    );
    var keyframes2 = [];
    if (duration > 0) {
      var needs_overflow_hidden = false;
      if (css) {
        var n3 = Math.ceil(duration / (1e3 / 60));
        for (var i3 = 0; i3 <= n3; i3 += 1) {
          var t3 = t1 + delta * easing(i3 / n3);
          var styles2 = css_to_keyframe(css(t3, 1 - t3));
          keyframes2.push(styles2);
          needs_overflow_hidden || (needs_overflow_hidden = styles2.overflow === "hidden");
        }
      }
      if (needs_overflow_hidden) {
        element2.style.overflow = "hidden";
      }
      get_t = () => {
        var time = (
          /** @type {number} */
          /** @type {globalThis.Animation} */
          animation2.currentTime
        );
        return t1 + delta * easing(time / duration);
      };
      if (tick2) {
        loop(() => {
          if (animation2.playState !== "running")
            return false;
          var t4 = get_t();
          tick2(t4, 1 - t4);
          return true;
        });
      }
    }
    animation2 = element2.animate(keyframes2, { duration, fill: "forwards" });
    animation2.onfinish = () => {
      get_t = () => t22;
      tick2 == null ? void 0 : tick2(t22, 1 - t22);
      on_finish();
    };
  };
  return {
    abort: () => {
      if (animation2) {
        animation2.cancel();
        animation2.effect = null;
        animation2.onfinish = noop;
      }
    },
    deactivate: () => {
      on_finish = noop;
    },
    reset: () => {
      if (t22 === 0) {
        tick2 == null ? void 0 : tick2(1, 0);
      }
    },
    t: () => get_t()
  };
}

// node_modules/svelte/src/internal/client/dom/css.js
function append_styles(anchor, css) {
  effect(() => {
    var _a3;
    var root6 = anchor.getRootNode();
    var target = (
      /** @type {ShadowRoot} */
      root6.host ? (
        /** @type {ShadowRoot} */
        root6
      ) : (
        /** @type {Document} */
        (_a3 = root6.head) != null ? _a3 : (
          /** @type {Document} */
          root6.ownerDocument.head
        )
      )
    );
    if (!target.querySelector("#" + css.hash)) {
      const style = document.createElement("style");
      style.id = css.hash;
      style.textContent = css.code;
      target.appendChild(style);
      if (dev_fallback_default) {
        register_style(css.hash, style);
      }
    }
  });
}

// node_modules/svelte/src/internal/client/dom/elements/actions.js
function action(dom, action2, get_value) {
  effect(() => {
    var payload = untrack(() => action2(dom, get_value == null ? void 0 : get_value()) || {});
    if (get_value && (payload == null ? void 0 : payload.update)) {
      var inited = false;
      var prev = (
        /** @type {any} */
        {}
      );
      render_effect(() => {
        var value = get_value();
        deep_read_state(value);
        if (inited && safe_not_equal(prev, value)) {
          prev = value;
          payload.update(value);
        }
      });
      inited = true;
    }
    if (payload == null ? void 0 : payload.destroy) {
      return () => (
        /** @type {Function} */
        payload.destroy()
      );
    }
  });
}

// node_modules/svelte/src/internal/shared/attributes.js
var whitespace = [..." 	\n\r\f\xA0\v\uFEFF"];
function to_class(value, hash2, directives) {
  var classname = value == null ? "" : "" + value;
  if (hash2) {
    classname = classname ? classname + " " + hash2 : hash2;
  }
  if (directives) {
    for (var key2 in directives) {
      if (directives[key2]) {
        classname = classname ? classname + " " + key2 : key2;
      } else if (classname.length) {
        var len = key2.length;
        var a2 = 0;
        while ((a2 = classname.indexOf(key2, a2)) >= 0) {
          var b = a2 + len;
          if ((a2 === 0 || whitespace.includes(classname[a2 - 1])) && (b === classname.length || whitespace.includes(classname[b]))) {
            classname = (a2 === 0 ? "" : classname.substring(0, a2)) + classname.substring(b + 1);
          } else {
            a2 = b;
          }
        }
      }
    }
  }
  return classname === "" ? null : classname;
}
function append_styles2(styles, important = false) {
  var separator = important ? " !important;" : ";";
  var css = "";
  for (var key2 in styles) {
    var value = styles[key2];
    if (value != null && value !== "") {
      css += " " + key2 + ": " + value + separator;
    }
  }
  return css;
}
function to_css_name(name) {
  if (name[0] !== "-" || name[1] !== "-") {
    return name.toLowerCase();
  }
  return name;
}
function to_style(value, styles) {
  if (styles) {
    var new_style = "";
    var normal_styles;
    var important_styles;
    if (Array.isArray(styles)) {
      normal_styles = styles[0];
      important_styles = styles[1];
    } else {
      normal_styles = styles;
    }
    if (value) {
      value = String(value).replaceAll(/\s*\/\*.*?\*\/\s*/g, "").trim();
      var in_str = false;
      var in_apo = 0;
      var in_comment = false;
      var reserved_names = [];
      if (normal_styles) {
        reserved_names.push(...Object.keys(normal_styles).map(to_css_name));
      }
      if (important_styles) {
        reserved_names.push(...Object.keys(important_styles).map(to_css_name));
      }
      var start_index = 0;
      var name_index = -1;
      const len = value.length;
      for (var i3 = 0; i3 < len; i3++) {
        var c2 = value[i3];
        if (in_comment) {
          if (c2 === "/" && value[i3 - 1] === "*") {
            in_comment = false;
          }
        } else if (in_str) {
          if (in_str === c2) {
            in_str = false;
          }
        } else if (c2 === "/" && value[i3 + 1] === "*") {
          in_comment = true;
        } else if (c2 === '"' || c2 === "'") {
          in_str = c2;
        } else if (c2 === "(") {
          in_apo++;
        } else if (c2 === ")") {
          in_apo--;
        }
        if (!in_comment && in_str === false && in_apo === 0) {
          if (c2 === ":" && name_index === -1) {
            name_index = i3;
          } else if (c2 === ";" || i3 === len - 1) {
            if (name_index !== -1) {
              var name = to_css_name(value.substring(start_index, name_index).trim());
              if (!reserved_names.includes(name)) {
                if (c2 !== ";") {
                  i3++;
                }
                var property = value.substring(start_index, i3).trim();
                new_style += " " + property + ";";
              }
            }
            start_index = i3 + 1;
            name_index = -1;
          }
        }
      }
    }
    if (normal_styles) {
      new_style += append_styles2(normal_styles);
    }
    if (important_styles) {
      new_style += append_styles2(important_styles, true);
    }
    new_style = new_style.trim();
    return new_style === "" ? null : new_style;
  }
  return value == null ? null : String(value);
}

// node_modules/svelte/src/internal/client/dom/elements/class.js
function set_class(dom, is_html, value, hash2, prev_classes, next_classes) {
  var prev = dom.__className;
  if (hydrating || prev !== value || prev === void 0) {
    var next_class_name = to_class(value, hash2, next_classes);
    if (!hydrating || next_class_name !== dom.getAttribute("class")) {
      if (next_class_name == null) {
        dom.removeAttribute("class");
      } else if (is_html) {
        dom.className = next_class_name;
      } else {
        dom.setAttribute("class", next_class_name);
      }
    }
    dom.__className = value;
  } else if (next_classes && prev_classes !== next_classes) {
    for (var key2 in next_classes) {
      var is_present = !!next_classes[key2];
      if (prev_classes == null || is_present !== !!prev_classes[key2]) {
        dom.classList.toggle(key2, is_present);
      }
    }
  }
  return next_classes;
}

// node_modules/svelte/src/internal/client/dom/elements/style.js
function update_styles(dom, prev = {}, next2, priority) {
  for (var key2 in next2) {
    var value = next2[key2];
    if (prev[key2] !== value) {
      if (next2[key2] == null) {
        dom.style.removeProperty(key2);
      } else {
        dom.style.setProperty(key2, value, priority);
      }
    }
  }
}
function set_style(dom, value, prev_styles, next_styles) {
  var prev = dom.__style;
  if (hydrating || prev !== value) {
    var next_style_attr = to_style(value, next_styles);
    if (!hydrating || next_style_attr !== dom.getAttribute("style")) {
      if (next_style_attr == null) {
        dom.removeAttribute("style");
      } else {
        dom.style.cssText = next_style_attr;
      }
    }
    dom.__style = value;
  } else if (next_styles) {
    if (Array.isArray(next_styles)) {
      update_styles(dom, prev_styles == null ? void 0 : prev_styles[0], next_styles[0]);
      update_styles(dom, prev_styles == null ? void 0 : prev_styles[1], next_styles[1], "important");
    } else {
      update_styles(dom, prev_styles, next_styles);
    }
  }
  return next_styles;
}

// node_modules/svelte/src/internal/client/dom/elements/bindings/select.js
function select_option(select, value, mounting = false) {
  if (select.multiple) {
    if (value == void 0) {
      return;
    }
    if (!is_array(value)) {
      return select_multiple_invalid_value();
    }
    for (var option of select.options) {
      option.selected = value.includes(get_option_value(option));
    }
    return;
  }
  for (option of select.options) {
    var option_value = get_option_value(option);
    if (is(option_value, value)) {
      option.selected = true;
      return;
    }
  }
  if (!mounting || value !== void 0) {
    select.selectedIndex = -1;
  }
}
function init_select(select) {
  var observer = new MutationObserver(() => {
    select_option(select, select.__value);
  });
  observer.observe(select, {
    // Listen to option element changes
    childList: true,
    subtree: true,
    // because of <optgroup>
    // Listen to option element value attribute changes
    // (doesn't get notified of select value changes,
    // because that property is not reflected as an attribute)
    attributes: true,
    attributeFilter: ["value"]
  });
  teardown(() => {
    observer.disconnect();
  });
}
function bind_select_value(select, get3, set2 = get3) {
  var batches2 = /* @__PURE__ */ new WeakSet();
  var mounting = true;
  listen_to_event_and_reset_event(select, "change", (is_reset) => {
    var _a3;
    var query = is_reset ? "[selected]" : ":checked";
    var value;
    if (select.multiple) {
      value = [].map.call(select.querySelectorAll(query), get_option_value);
    } else {
      var selected_option = (_a3 = select.querySelector(query)) != null ? _a3 : (
        // will fall back to first non-disabled option if no option is selected
        select.querySelector("option:not([disabled])")
      );
      value = selected_option && get_option_value(selected_option);
    }
    set2(value);
    if (current_batch !== null) {
      batches2.add(current_batch);
    }
  });
  effect(() => {
    var _a3;
    var value = get3();
    if (select === document.activeElement) {
      var batch = (
        /** @type {Batch} */
        (_a3 = previous_batch) != null ? _a3 : current_batch
      );
      if (batches2.has(batch)) {
        return;
      }
    }
    select_option(select, value, mounting);
    if (mounting && value === void 0) {
      var selected_option = select.querySelector(":checked");
      if (selected_option !== null) {
        value = get_option_value(selected_option);
        set2(value);
      }
    }
    select.__value = value;
    mounting = false;
  });
  init_select(select);
}
function get_option_value(option) {
  if ("__value" in option) {
    return option.__value;
  } else {
    return option.value;
  }
}

// node_modules/svelte/src/internal/client/dom/elements/attributes.js
var CLASS = Symbol("class");
var STYLE = Symbol("style");
var IS_CUSTOM_ELEMENT = Symbol("is custom element");
var IS_HTML = Symbol("is html");
function remove_input_defaults(input) {
  if (!hydrating)
    return;
  var already_removed = false;
  var remove_defaults = () => {
    if (already_removed)
      return;
    already_removed = true;
    if (input.hasAttribute("value")) {
      var value = input.value;
      set_attribute2(input, "value", null);
      input.value = value;
    }
    if (input.hasAttribute("checked")) {
      var checked = input.checked;
      set_attribute2(input, "checked", null);
      input.checked = checked;
    }
  };
  input.__on_r = remove_defaults;
  queue_micro_task(remove_defaults);
  add_form_reset_listener();
}
function set_attribute2(element2, attribute, value, skip_warning) {
  var attributes = get_attributes(element2);
  if (hydrating) {
    attributes[attribute] = element2.getAttribute(attribute);
    if (attribute === "src" || attribute === "srcset" || attribute === "href" && element2.nodeName === "LINK") {
      if (!skip_warning) {
        check_src_in_dev_hydration(element2, attribute, value != null ? value : "");
      }
      return;
    }
  }
  if (attributes[attribute] === (attributes[attribute] = value))
    return;
  if (attribute === "loading") {
    element2[LOADING_ATTR_SYMBOL] = value;
  }
  if (value == null) {
    element2.removeAttribute(attribute);
  } else if (typeof value !== "string" && get_setters(element2).includes(attribute)) {
    element2[attribute] = value;
  } else {
    element2.setAttribute(attribute, value);
  }
}
function get_attributes(element2) {
  var _a3;
  return (
    /** @type {Record<string | symbol, unknown>} **/
    // @ts-expect-error
    (_a3 = element2.__attributes) != null ? _a3 : element2.__attributes = {
      [IS_CUSTOM_ELEMENT]: element2.nodeName.includes("-"),
      [IS_HTML]: element2.namespaceURI === NAMESPACE_HTML
    }
  );
}
var setters_cache = /* @__PURE__ */ new Map();
function get_setters(element2) {
  var cache_key = element2.getAttribute("is") || element2.nodeName;
  var setters = setters_cache.get(cache_key);
  if (setters)
    return setters;
  setters_cache.set(cache_key, setters = []);
  var descriptors;
  var proto = element2;
  var element_proto = Element.prototype;
  while (element_proto !== proto) {
    descriptors = get_descriptors(proto);
    for (var key2 in descriptors) {
      if (descriptors[key2].set) {
        setters.push(key2);
      }
    }
    proto = get_prototype_of(proto);
  }
  return setters;
}
function check_src_in_dev_hydration(element2, attribute, value) {
  var _a3;
  if (!dev_fallback_default)
    return;
  if (attribute === "srcset" && srcset_url_equal(element2, value))
    return;
  if (src_url_equal((_a3 = element2.getAttribute(attribute)) != null ? _a3 : "", value))
    return;
  hydration_attribute_changed(
    attribute,
    element2.outerHTML.replace(element2.innerHTML, element2.innerHTML && "..."),
    String(value)
  );
}
function src_url_equal(element_src, url) {
  if (element_src === url)
    return true;
  return new URL(element_src, document.baseURI).href === new URL(url, document.baseURI).href;
}
function split_srcset(srcset) {
  return srcset.split(",").map((src) => src.trim().split(" ").filter(Boolean));
}
function srcset_url_equal(element2, srcset) {
  var element_urls = split_srcset(element2.srcset);
  var urls = split_srcset(srcset);
  return urls.length === element_urls.length && urls.every(
    ([url, width], i3) => width === element_urls[i3][1] && // We need to test both ways because Vite will create an a full URL with
    // `new URL(asset, import.meta.url).href` for the client when `base: './'`, and the
    // relative URLs inside srcset are not automatically resolved to absolute URLs by
    // browsers (in contrast to img.src). This means both SSR and DOM code could
    // contain relative or absolute URLs.
    (src_url_equal(element_urls[i3][0], url) || src_url_equal(url, element_urls[i3][0]))
  );
}

// node_modules/svelte/src/internal/client/dom/elements/bindings/input.js
function bind_value(input, get3, set2 = get3) {
  var batches2 = /* @__PURE__ */ new WeakSet();
  listen_to_event_and_reset_event(input, "input", async (is_reset) => {
    if (dev_fallback_default && input.type === "checkbox") {
      bind_invalid_checkbox_value();
    }
    var value = is_reset ? input.defaultValue : input.value;
    value = is_numberlike_input(input) ? to_number(value) : value;
    set2(value);
    if (current_batch !== null) {
      batches2.add(current_batch);
    }
    await tick();
    if (value !== (value = get3())) {
      var start2 = input.selectionStart;
      var end2 = input.selectionEnd;
      var length2 = input.value.length;
      input.value = value != null ? value : "";
      if (end2 !== null) {
        var new_length = input.value.length;
        if (start2 === end2 && end2 === length2 && new_length > length2) {
          input.selectionStart = new_length;
          input.selectionEnd = new_length;
        } else {
          input.selectionStart = start2;
          input.selectionEnd = Math.min(end2, new_length);
        }
      }
    }
  });
  if (
    // If we are hydrating and the value has since changed,
    // then use the updated value from the input instead.
    hydrating && input.defaultValue !== input.value || // If defaultValue is set, then value == defaultValue
    // TODO Svelte 6: remove input.value check and set to empty string?
    untrack(get3) == null && input.value
  ) {
    set2(is_numberlike_input(input) ? to_number(input.value) : input.value);
    if (current_batch !== null) {
      batches2.add(current_batch);
    }
  }
  render_effect(() => {
    var _a3;
    if (dev_fallback_default && input.type === "checkbox") {
      bind_invalid_checkbox_value();
    }
    var value = get3();
    if (input === document.activeElement) {
      var batch = (
        /** @type {Batch} */
        (_a3 = previous_batch) != null ? _a3 : current_batch
      );
      if (batches2.has(batch)) {
        return;
      }
    }
    if (is_numberlike_input(input) && value === to_number(input.value)) {
      return;
    }
    if (input.type === "date" && !value && !input.value) {
      return;
    }
    if (value !== input.value) {
      input.value = value != null ? value : "";
    }
  });
}
function is_numberlike_input(input) {
  var type = input.type;
  return type === "number" || type === "range";
}
function to_number(value) {
  return value === "" ? null : +value;
}

// node_modules/svelte/src/internal/client/reactivity/store.js
var is_store_binding = false;
var IS_UNMOUNTED = Symbol();
function store_get(store, store_name, stores) {
  var _a3;
  const entry = (_a3 = stores[store_name]) != null ? _a3 : stores[store_name] = {
    store: null,
    source: mutable_source(void 0),
    unsubscribe: noop
  };
  if (dev_fallback_default) {
    entry.source.label = store_name;
  }
  if (entry.store !== store && !(IS_UNMOUNTED in stores)) {
    entry.unsubscribe();
    entry.store = store != null ? store : null;
    if (store == null) {
      entry.source.v = void 0;
      entry.unsubscribe = noop;
    } else {
      var is_synchronous_callback = true;
      entry.unsubscribe = subscribe_to_store(store, (v2) => {
        if (is_synchronous_callback) {
          entry.source.v = v2;
        } else {
          set(entry.source, v2);
        }
      });
      is_synchronous_callback = false;
    }
  }
  if (store && IS_UNMOUNTED in stores) {
    return get2(store);
  }
  return get(entry.source);
}
function setup_stores() {
  const stores = {};
  function cleanup() {
    teardown(() => {
      for (var store_name in stores) {
        const ref = stores[store_name];
        ref.unsubscribe();
      }
      define_property(stores, IS_UNMOUNTED, {
        enumerable: false,
        value: true
      });
    });
  }
  return [stores, cleanup];
}
function capture_store_binding(fn) {
  var previous_is_store_binding = is_store_binding;
  try {
    is_store_binding = false;
    return [fn(), is_store_binding];
  } finally {
    is_store_binding = previous_is_store_binding;
  }
}

// node_modules/svelte/src/internal/client/reactivity/props.js
function prop(props, key2, flags2, fallback3) {
  var _a3, _b3;
  var runes = !legacy_mode_flag || (flags2 & PROPS_IS_RUNES) !== 0;
  var bindable = (flags2 & PROPS_IS_BINDABLE) !== 0;
  var lazy = (flags2 & PROPS_IS_LAZY_INITIAL) !== 0;
  var fallback_value = (
    /** @type {V} */
    fallback3
  );
  var fallback_dirty = true;
  var get_fallback = () => {
    if (fallback_dirty) {
      fallback_dirty = false;
      fallback_value = lazy ? untrack(
        /** @type {() => V} */
        fallback3
      ) : (
        /** @type {V} */
        fallback3
      );
    }
    return fallback_value;
  };
  var setter;
  if (bindable) {
    var is_entry_props = STATE_SYMBOL in props || LEGACY_PROPS in props;
    setter = (_b3 = (_a3 = get_descriptor(props, key2)) == null ? void 0 : _a3.set) != null ? _b3 : is_entry_props && key2 in props ? (v2) => props[key2] = v2 : void 0;
  }
  var initial_value;
  var is_store_sub = false;
  if (bindable) {
    [initial_value, is_store_sub] = capture_store_binding(() => (
      /** @type {V} */
      props[key2]
    ));
  } else {
    initial_value = /** @type {V} */
    props[key2];
  }
  if (initial_value === void 0 && fallback3 !== void 0) {
    initial_value = get_fallback();
    if (setter) {
      if (runes)
        props_invalid_value(key2);
      setter(initial_value);
    }
  }
  var getter;
  if (runes) {
    getter = () => {
      var value = (
        /** @type {V} */
        props[key2]
      );
      if (value === void 0)
        return get_fallback();
      fallback_dirty = true;
      return value;
    };
  } else {
    getter = () => {
      var value = (
        /** @type {V} */
        props[key2]
      );
      if (value !== void 0) {
        fallback_value = /** @type {V} */
        void 0;
      }
      return value === void 0 ? fallback_value : value;
    };
  }
  if (runes && (flags2 & PROPS_IS_UPDATED) === 0) {
    return getter;
  }
  if (setter) {
    var legacy_parent = props.$$legacy;
    return (
      /** @type {() => V} */
      function(value, mutation) {
        if (arguments.length > 0) {
          if (!runes || !mutation || legacy_parent || is_store_sub) {
            setter(mutation ? getter() : value);
          }
          return value;
        }
        return getter();
      }
    );
  }
  var overridden = false;
  var d2 = ((flags2 & PROPS_IS_IMMUTABLE) !== 0 ? derived : derived_safe_equal)(() => {
    overridden = false;
    return getter();
  });
  if (dev_fallback_default) {
    d2.label = key2;
  }
  if (bindable)
    get(d2);
  var parent_effect = (
    /** @type {Effect} */
    active_effect
  );
  return (
    /** @type {() => V} */
    function(value, mutation) {
      if (arguments.length > 0) {
        const new_value = mutation ? get(d2) : runes && bindable ? proxy(value) : value;
        set(d2, new_value);
        overridden = true;
        if (fallback_value !== void 0) {
          fallback_value = new_value;
        }
        return value;
      }
      if (is_destroying_effect && overridden || (parent_effect.f & DESTROYED) !== 0) {
        return d2.v;
      }
      return get(d2);
    }
  );
}

// node_modules/svelte/src/legacy/legacy-client.js
function createClassComponent(options) {
  return new Svelte4Component(options);
}
var _events, _instance;
var Svelte4Component = class {
  /**
   * @param {ComponentConstructorOptions & {
   *  component: any;
   * }} options
   */
  constructor(options) {
    /** @type {any} */
    __privateAdd(this, _events, void 0);
    /** @type {Record<string, any>} */
    __privateAdd(this, _instance, void 0);
    var _a3, _b3;
    var sources = /* @__PURE__ */ new Map();
    var add_source = (key2, value) => {
      var s3 = mutable_source(value, false, false);
      sources.set(key2, s3);
      return s3;
    };
    const props = new Proxy(
      { ...options.props || {}, $$events: {} },
      {
        get(target, prop2) {
          var _a4;
          return get((_a4 = sources.get(prop2)) != null ? _a4 : add_source(prop2, Reflect.get(target, prop2)));
        },
        has(target, prop2) {
          var _a4;
          if (prop2 === LEGACY_PROPS)
            return true;
          get((_a4 = sources.get(prop2)) != null ? _a4 : add_source(prop2, Reflect.get(target, prop2)));
          return Reflect.has(target, prop2);
        },
        set(target, prop2, value) {
          var _a4;
          set((_a4 = sources.get(prop2)) != null ? _a4 : add_source(prop2, value), value);
          return Reflect.set(target, prop2, value);
        }
      }
    );
    __privateSet(this, _instance, (options.hydrate ? hydrate : mount)(options.component, {
      target: options.target,
      anchor: options.anchor,
      props,
      context: options.context,
      intro: (_a3 = options.intro) != null ? _a3 : false,
      recover: options.recover
    }));
    if (!async_mode_flag && (!((_b3 = options == null ? void 0 : options.props) == null ? void 0 : _b3.$$host) || options.sync === false)) {
      flushSync();
    }
    __privateSet(this, _events, props.$$events);
    for (const key2 of Object.keys(__privateGet(this, _instance))) {
      if (key2 === "$set" || key2 === "$destroy" || key2 === "$on")
        continue;
      define_property(this, key2, {
        get() {
          return __privateGet(this, _instance)[key2];
        },
        /** @param {any} value */
        set(value) {
          __privateGet(this, _instance)[key2] = value;
        },
        enumerable: true
      });
    }
    __privateGet(this, _instance).$set = /** @param {Record<string, any>} next */
    (next2) => {
      Object.assign(props, next2);
    };
    __privateGet(this, _instance).$destroy = () => {
      unmount(__privateGet(this, _instance));
    };
  }
  /** @param {Record<string, any>} props */
  $set(props) {
    __privateGet(this, _instance).$set(props);
  }
  /**
   * @param {string} event
   * @param {(...args: any[]) => any} callback
   * @returns {any}
   */
  $on(event2, callback) {
    __privateGet(this, _events)[event2] = __privateGet(this, _events)[event2] || [];
    const cb = (...args) => callback.call(this, ...args);
    __privateGet(this, _events)[event2].push(cb);
    return () => {
      __privateGet(this, _events)[event2] = __privateGet(this, _events)[event2].filter(
        /** @param {any} fn */
        (fn) => fn !== cb
      );
    };
  }
  $destroy() {
    __privateGet(this, _instance).$destroy();
  }
};
_events = new WeakMap();
_instance = new WeakMap();

// node_modules/svelte/src/internal/client/dom/elements/custom-element.js
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    /**
     * @param {*} $$componentCtor
     * @param {*} $$slots
     * @param {*} use_shadow_dom
     */
    constructor($$componentCtor, $$slots, use_shadow_dom) {
      super();
      /** The Svelte component constructor */
      __publicField(this, "$$ctor");
      /** Slots */
      __publicField(this, "$$s");
      /** @type {any} The Svelte component instance */
      __publicField(this, "$$c");
      /** Whether or not the custom element is connected */
      __publicField(this, "$$cn", false);
      /** @type {Record<string, any>} Component props data */
      __publicField(this, "$$d", {});
      /** `true` if currently in the process of reflecting component props back to attributes */
      __publicField(this, "$$r", false);
      /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
      __publicField(this, "$$p_d", {});
      /** @type {Record<string, EventListenerOrEventListenerObject[]>} Event listeners */
      __publicField(this, "$$l", {});
      /** @type {Map<EventListenerOrEventListenerObject, Function>} Event listener unsubscribe functions */
      __publicField(this, "$$l_u", /* @__PURE__ */ new Map());
      /** @type {any} The managed render effect for reflecting attributes */
      __publicField(this, "$$me");
      this.$$ctor = $$componentCtor;
      this.$$s = $$slots;
      if (use_shadow_dom) {
        this.attachShadow({ mode: "open" });
      }
    }
    /**
     * @param {string} type
     * @param {EventListenerOrEventListenerObject} listener
     * @param {boolean | AddEventListenerOptions} [options]
     */
    addEventListener(type, listener, options) {
      this.$$l[type] = this.$$l[type] || [];
      this.$$l[type].push(listener);
      if (this.$$c) {
        const unsub = this.$$c.$on(type, listener);
        this.$$l_u.set(listener, unsub);
      }
      super.addEventListener(type, listener, options);
    }
    /**
     * @param {string} type
     * @param {EventListenerOrEventListenerObject} listener
     * @param {boolean | AddEventListenerOptions} [options]
     */
    removeEventListener(type, listener, options) {
      super.removeEventListener(type, listener, options);
      if (this.$$c) {
        const unsub = this.$$l_u.get(listener);
        if (unsub) {
          unsub();
          this.$$l_u.delete(listener);
        }
      }
    }
    async connectedCallback() {
      this.$$cn = true;
      if (!this.$$c) {
        let create_slot = function(name) {
          return (anchor) => {
            const slot2 = document.createElement("slot");
            if (name !== "default")
              slot2.name = name;
            append(anchor, slot2);
          };
        };
        await Promise.resolve();
        if (!this.$$cn || this.$$c) {
          return;
        }
        const $$slots = {};
        const existing_slots = get_custom_elements_slots(this);
        for (const name of this.$$s) {
          if (name in existing_slots) {
            if (name === "default" && !this.$$d.children) {
              this.$$d.children = create_slot(name);
              $$slots.default = true;
            } else {
              $$slots[name] = create_slot(name);
            }
          }
        }
        for (const attribute of this.attributes) {
          const name = this.$$g_p(attribute.name);
          if (!(name in this.$$d)) {
            this.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, "toProp");
          }
        }
        for (const key2 in this.$$p_d) {
          if (!(key2 in this.$$d) && this[key2] !== void 0) {
            this.$$d[key2] = this[key2];
            delete this[key2];
          }
        }
        this.$$c = createClassComponent({
          component: this.$$ctor,
          target: this.shadowRoot || this,
          props: {
            ...this.$$d,
            $$slots,
            $$host: this
          }
        });
        this.$$me = effect_root(() => {
          render_effect(() => {
            var _a3;
            this.$$r = true;
            for (const key2 of object_keys(this.$$c)) {
              if (!((_a3 = this.$$p_d[key2]) == null ? void 0 : _a3.reflect))
                continue;
              this.$$d[key2] = this.$$c[key2];
              const attribute_value = get_custom_element_value(
                key2,
                this.$$d[key2],
                this.$$p_d,
                "toAttribute"
              );
              if (attribute_value == null) {
                this.removeAttribute(this.$$p_d[key2].attribute || key2);
              } else {
                this.setAttribute(this.$$p_d[key2].attribute || key2, attribute_value);
              }
            }
            this.$$r = false;
          });
        });
        for (const type in this.$$l) {
          for (const listener of this.$$l[type]) {
            const unsub = this.$$c.$on(type, listener);
            this.$$l_u.set(listener, unsub);
          }
        }
        this.$$l = {};
      }
    }
    // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
    // and setting attributes through setAttribute etc, this is helpful
    /**
     * @param {string} attr
     * @param {string} _oldValue
     * @param {string} newValue
     */
    attributeChangedCallback(attr2, _oldValue, newValue) {
      var _a3;
      if (this.$$r)
        return;
      attr2 = this.$$g_p(attr2);
      this.$$d[attr2] = get_custom_element_value(attr2, newValue, this.$$p_d, "toProp");
      (_a3 = this.$$c) == null ? void 0 : _a3.$set({ [attr2]: this.$$d[attr2] });
    }
    disconnectedCallback() {
      this.$$cn = false;
      Promise.resolve().then(() => {
        if (!this.$$cn && this.$$c) {
          this.$$c.$destroy();
          this.$$me();
          this.$$c = void 0;
        }
      });
    }
    /**
     * @param {string} attribute_name
     */
    $$g_p(attribute_name) {
      return object_keys(this.$$p_d).find(
        (key2) => this.$$p_d[key2].attribute === attribute_name || !this.$$p_d[key2].attribute && key2.toLowerCase() === attribute_name
      ) || attribute_name;
    }
  };
}
function get_custom_element_value(prop2, value, props_definition, transform) {
  var _a3;
  const type = (_a3 = props_definition[prop2]) == null ? void 0 : _a3.type;
  value = type === "Boolean" && typeof value !== "boolean" ? value != null : value;
  if (!transform || !props_definition[prop2]) {
    return value;
  } else if (transform === "toAttribute") {
    switch (type) {
      case "Object":
      case "Array":
        return value == null ? null : JSON.stringify(value);
      case "Boolean":
        return value ? "" : null;
      case "Number":
        return value == null ? null : value;
      default:
        return value;
    }
  } else {
    switch (type) {
      case "Object":
      case "Array":
        return value && JSON.parse(value);
      case "Boolean":
        return value;
      case "Number":
        return value != null ? +value : value;
      default:
        return value;
    }
  }
}
function get_custom_elements_slots(element2) {
  const result = {};
  element2.childNodes.forEach((node) => {
    result[
      /** @type {Element} node */
      node.slot || "default"
    ] = true;
  });
  return result;
}

// node_modules/svelte/src/index-client.js
if (dev_fallback_default) {
  let throw_rune_error = function(rune) {
    if (!(rune in globalThis)) {
      let value;
      Object.defineProperty(globalThis, rune, {
        configurable: true,
        // eslint-disable-next-line getter-return
        get: () => {
          if (value !== void 0) {
            return value;
          }
          rune_outside_svelte(rune);
        },
        set: (v2) => {
          value = v2;
        }
      });
    }
  };
  throw_rune_error("$state");
  throw_rune_error("$effect");
  throw_rune_error("$derived");
  throw_rune_error("$inspect");
  throw_rune_error("$props");
  throw_rune_error("$bindable");
}
function onMount(fn) {
  if (component_context === null) {
    lifecycle_outside_component("onMount");
  }
  if (legacy_mode_flag && component_context.l !== null) {
    init_update_callbacks(component_context).m.push(fn);
  } else {
    user_effect(() => {
      const cleanup = untrack(fn);
      if (typeof cleanup === "function")
        return (
          /** @type {() => void} */
          cleanup
        );
    });
  }
}
function onDestroy(fn) {
  if (component_context === null) {
    lifecycle_outside_component("onDestroy");
  }
  onMount(() => () => untrack(fn));
}
function init_update_callbacks(context) {
  var _a3;
  var l2 = (
    /** @type {ComponentContextLegacy} */
    context.l
  );
  return (_a3 = l2.u) != null ? _a3 : l2.u = { a: [], b: [], m: [] };
}

// node_modules/svelte/src/store/utils.js
function subscribe_to_store(store, run3, invalidate) {
  if (store == null) {
    run3(void 0);
    if (invalidate)
      invalidate(void 0);
    return noop;
  }
  const unsub = untrack(
    () => store.subscribe(
      run3,
      // @ts-expect-error
      invalidate
    )
  );
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}

// node_modules/svelte/src/store/shared/index.js
var subscriber_queue = [];
function writable(value, start2 = noop) {
  let stop = null;
  const subscribers = /* @__PURE__ */ new Set();
  function set2(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i3 = 0; i3 < subscriber_queue.length; i3 += 2) {
            subscriber_queue[i3][0](subscriber_queue[i3 + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn) {
    set2(fn(
      /** @type {T} */
      value
    ));
  }
  function subscribe(run3, invalidate = noop) {
    const subscriber = [run3, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start2(set2, update2) || noop;
    }
    run3(
      /** @type {T} */
      value
    );
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0 && stop) {
        stop();
        stop = null;
      }
    };
  }
  return { set: set2, update: update2, subscribe };
}
function get2(store) {
  let value;
  subscribe_to_store(store, (_2) => value = _2)();
  return value;
}

// store.ts
var processRegistry = writable({});
var processOrigin = writable({});
var statusMessage = writable("PROCESSING...");
function setFileLoading(path, isLoading, originTab) {
  processRegistry.update((current) => ({
    ...current,
    [path]: isLoading
  }));
  if (isLoading && originTab) {
    processOrigin.update((current) => ({
      ...current,
      [path]: originTab
    }));
  } else if (!isLoading) {
    statusMessage.set("READY");
  }
}
function setStatus(msg) {
  statusMessage.set(msg);
}

// CloudGen.ts
var FORENSIC_CALIBRATION = `
[SYSTEM OVERRIDE: NARRATIVE GRANDMASTER]
[PROTOCOL: QUANTUM SCORING (-100 to +100)]

1. **START AT ZERO:** 0 is the baseline for a "technically competent but boring/generic" story.
2. **POSITIVE SCORES:** Awarded only for strengths (+1 to +100).
3. **NEGATIVE SCORES:** Deducted for weaknesses (-1 to -100).
4. **NO CAP:** Do not hesitate to give -100 or +100 if deserved.
5. **IGNORE INTENT:** Judge only what is on the page.
`;
var GeminiAdapter = class {
  constructor(apiKey, model5, settings) {
    this.apiKey = apiKey;
    this.model = model5;
    this.settings = settings;
  }
  async generate(text2, sys, json = true, useSearch = false, tempOverride) {
    var _a3, _b3;
    if (!this.apiKey)
      throw new Error("MISSING GEMINI API KEY");
    const targetModel = useSearch ? this.settings.searchModelId || this.model : this.model;
    const temp = tempOverride !== void 0 ? tempOverride : 0.7;
    const body = {
      contents: [{ role: "user", parts: [{ text: text2 }] }],
      generationConfig: {
        temperature: temp,
        maxOutputTokens: this.settings.maxOutputTokens
      }
    };
    const baseSys = sys || "";
    const userSys = this.settings.customSystemPrompt ? `[USER OVERRIDE]: ${this.settings.customSystemPrompt}` : FORENSIC_CALIBRATION;
    const thinkingLevel = this.settings.aiThinkingLevel || 3;
    let finalSys = `${baseSys}
${userSys}`;
    if (thinkingLevel >= 4) {
      finalSys += "\n[THOUGHT PROCESS]: Think deeply and step-by-step before answering. Consider multiple angles.";
    }
    if (finalSys)
      body.systemInstruction = { parts: [{ text: finalSys }] };
    if (json && !useSearch) {
      body.generationConfig.responseMimeType = "application/json";
    }
    const supportsThinking = targetModel.includes("2.0-flash-thinking") || targetModel.includes("thinking");
    if (this.settings.showThinking || thinkingLevel >= 4 && supportsThinking) {
      body.generationConfig.thinking_config = { include_thoughts: true };
    } else if (useSearch) {
      body.tools = [{ googleSearch: {} }];
    }
    setStatus(`QUERYING ${targetModel}...`);
    const res = await (0, import_obsidian.requestUrl)({
      url: `https://generativelanguage.googleapis.com/v1beta/models/${targetModel}:generateContent?key=${this.apiKey}`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body)
    });
    if (res.status >= 400)
      throw new Error(`GEMINI ERROR ${res.status}: ${res.text}`);
    const candidate = (_a3 = res.json.candidates) == null ? void 0 : _a3[0];
    if (!((_b3 = candidate == null ? void 0 : candidate.content) == null ? void 0 : _b3.parts))
      throw new Error("Empty Response");
    let finalOutput = "";
    let thoughtContent = "";
    for (const part of candidate.content.parts) {
      if (part.text)
        finalOutput += part.text;
      if (part.thought)
        thoughtContent += part.text + "\n";
    }
    if (json && thoughtContent && finalOutput.trim().endsWith("}")) {
      const trimmed = finalOutput.trim().replace(/```json/g, "").replace(/```/g, "");
      const lastBrace = trimmed.lastIndexOf("}");
      if (lastBrace > 0) {
        const base = trimmed.substring(0, lastBrace);
        return `${base}, "thought_process": ${JSON.stringify(thoughtContent)}}`;
      }
    }
    return finalOutput;
  }
};
var OpenAIAdapter = class {
  constructor(apiKey, model5, settings) {
    this.apiKey = apiKey;
    this.model = model5;
    this.settings = settings;
  }
  async generate(text2, sys, json = true, useSearch = false, tempOverride) {
    if (!this.apiKey)
      throw new Error("MISSING OPENAI API KEY");
    setStatus(`CONNECTING TO OPENAI (${this.model})...`);
    const baseSys = sys || "";
    const userSys = this.settings.customSystemPrompt ? `[USER OVERRIDE]: ${this.settings.customSystemPrompt}` : FORENSIC_CALIBRATION;
    const body = {
      model: this.model || "gpt-4o",
      messages: [{ role: "system", content: `${baseSys}
${userSys}` }, { role: "user", content: text2 }],
      temperature: tempOverride !== void 0 ? tempOverride : 0.7,
      max_tokens: this.settings.maxOutputTokens,
      response_format: json ? { type: "json_object" } : void 0
    };
    const res = await (0, import_obsidian.requestUrl)({
      url: "https://api.openai.com/v1/chat/completions",
      method: "POST",
      headers: { "Authorization": `Bearer ${this.apiKey}`, "Content-Type": "application/json" },
      body: JSON.stringify(body)
    });
    if (res.status >= 400)
      throw new Error(`OPENAI ERROR ${res.status}`);
    return res.json.choices[0].message.content;
  }
};
var AnthropicAdapter = class {
  constructor(apiKey, model5, settings) {
    this.apiKey = apiKey;
    this.model = model5;
    this.settings = settings;
  }
  async generate(text2, sys, json = true, useSearch = false, tempOverride) {
    if (!this.apiKey)
      throw new Error("MISSING ANTHROPIC API KEY");
    setStatus(`CONNECTING TO CLAUDE (${this.model})...`);
    const baseSys = sys || "";
    const userSys = this.settings.customSystemPrompt ? `[USER OVERRIDE]: ${this.settings.customSystemPrompt}` : FORENSIC_CALIBRATION;
    const body = {
      model: this.model || "claude-3-7-sonnet-20250219",
      max_tokens: this.settings.maxOutputTokens,
      system: `${baseSys}
${userSys}`,
      messages: [{ role: "user", content: text2 }],
      temperature: tempOverride !== void 0 ? tempOverride : 0.7
    };
    if (json)
      body.messages.push({ role: "assistant", content: "{" });
    const res = await (0, import_obsidian.requestUrl)({
      url: "https://api.anthropic.com/v1/messages",
      method: "POST",
      headers: { "x-api-key": this.apiKey, "anthropic-version": "2023-06-01", "Content-Type": "application/json" },
      body: JSON.stringify(body)
    });
    if (res.status >= 400)
      throw new Error(`ANTHROPIC ERROR ${res.status}`);
    let textOutput = "";
    for (const block2 of res.json.content) {
      if (block2.type === "text")
        textOutput += block2.text;
    }
    return json && !textOutput.trim().startsWith("{") ? "{" + textOutput : textOutput;
  }
};
var CloudGenService = class {
  constructor(app, settings) {
    this.app = app;
    this.settings = settings;
    this.autoFillWizard = async (concept, currentContext) => {
      setStatus("ARCHITECTING STORY BIBLE...");
      const nameRules = this.getNameProtocol();
      const prompt = `
        [INPUT CONCEPT]: "${concept}"
        [UPLOADED SOURCE MATERIAL]: ${currentContext}
        Using the concept above and the source material, generate the full JSON Story Bible.
        Ensure you generate the "philosopher" section (Theme/Moral Argument) based on the conflict.
        ${nameRules}
        `;
      const temp = this.getTemp(this.settings.tempWizard);
      const res = await this.callAI(prompt, NIGS_AUTOFILL_PROMPT, true, false, temp);
      return this.parseJson(res);
    };
    this.synthesizeDrives = async (drives, customTitle, targetQuality) => {
      var _a3;
      setStatus("FUSING NARRATIVE DRIVES...");
      let driveContext = "";
      drives.forEach((d2, i3) => {
        const safeContent = d2.content || "";
        driveContext += `
=== DRIVE ${i3 + 1}: ${d2.name} ===
${safeContent}
`;
      });
      const nameRules = this.getNameProtocol();
      let titleInstruction = "";
      if (customTitle && customTitle.trim().length > 0) {
        titleInstruction = `
[MANDATORY TITLE]: ${customTitle}
You MUST use the title provided above. Do not invent a new one.`;
      }
      const qualityInstruction = `
[TARGET QUALITY]: Aim for a quality score of ${targetQuality || this.settings.defaultTargetQuality}/100.`;
      const finalPrompt = `${driveContext}
${nameRules}${titleInstruction}${qualityInstruction}`;
      const temp = this.getTemp((_a3 = this.settings.tempSynth) != null ? _a3 : 1);
      return await this.callAI(finalPrompt, NIGS_DRIVE_SYNTHESIS_PROMPT, false, false, temp);
    };
    this.gradeContent = async (text2, context, nlpStats, wizardState) => {
      if (!this.settings.enableTribunal) {
        return this.gradeContentLegacy(text2, context, nlpStats);
      }
      setStatus("CONVENING THE TRIBUNAL...");
      const deepThought = this.settings.aiThinkingLevel >= 4 ? "\n[THOUGHT PROCESS]: Use logic chains to verify every claim. Ignore bias." : "";
      const sourceMaterial = (context == null ? void 0 : context.inspiration) ? `
[SOURCE MATERIAL]: "${context.inspiration}"
` : "";
      let statsBlock = "";
      if (nlpStats) {
        statsBlock = `
[FORENSIC EVIDENCE]:
- Word Count: ${nlpStats.wordCount}
- Pacing (Variance): ${nlpStats.sentenceVariance}
- Adverb Density: ${nlpStats.adverbDensity || 0}%
- Dialogue Ratio: ${nlpStats.dialogueRatio}%
`;
      }
      const inputPayload = `
=== NARRATIVE ARTIFACT ===
${text2}
=== END ARTIFACT ===
${statsBlock}
${sourceMaterial}
`;
      setStatus("DEPLOYING AGENTS (MARKET, LOGIC, LIT, FORENSIC)...");
      const strictTemp = this.getTemp(0.1, true);
      const [marketRaw, logicRaw, litRaw, forensicRaw] = await Promise.all([
        this.callAI(inputPayload + deepThought, NIGS_TRIBUNAL.MARKET, true, false, 0.7).catch((e2) => `{"error": "Market Agent Failed: ${e2.message}"}`),
        this.callAI(inputPayload + deepThought, NIGS_TRIBUNAL.LOGIC, true, false, strictTemp).catch((e2) => `{"error": "Logic Agent Failed: ${e2.message}"}`),
        this.callAI(inputPayload + deepThought, NIGS_TRIBUNAL.LITERARY, true, false, 0.9).catch((e2) => `{"error": "Lit Agent Failed: ${e2.message}"}`),
        this.callAI(inputPayload + deepThought, NIGS_SYSTEM_PROMPT, true, false, strictTemp).catch((e2) => `{"error": "Forensic Agent Failed: ${e2.message}"}`)
      ]);
      setStatus("SYNTHESIZING VERDICT...");
      const synthesisPayload = `
[TRIBUNAL REPORTS]:
1. MARKET ANALYST: ${marketRaw}
2. LOGIC ENGINE: ${logicRaw}
3. LITERARY CRITIC: ${litRaw}
4. FORENSIC SCAN (Legacy): ${forensicRaw}

[TASK]: Synthesize a FINAL NigsResponse JSON.
- **QUANTUM SCORING:** Range -100 to +100.
- **LOGIC VETO:** If Logic/Forensic found a Plot Hole, the final score MUST be negative.
`;
      const finalResStr = await this.callAI(synthesisPayload, NIGS_SYNTHESIS_PROMPT, true, false, strictTemp);
      const finalRes = this.parseJson(finalResStr);
      try {
        finalRes.tribunal_breakdown = {
          market: JSON.parse(marketRaw),
          logic: JSON.parse(logicRaw),
          lit: JSON.parse(litRaw)
        };
      } catch (e2) {
        console.warn("Agent raw data parse error", e2);
      }
      return finalRes;
    };
    this.gradeContentLegacy = async (text2, context, nlpStats) => {
      const passes = Math.max(1, Math.min(10, this.settings.analysisPasses));
      const contextBlock = (context == null ? void 0 : context.inspiration) ? `
[UPLOADED SOURCE CONTEXT]: "${context.inspiration}"
` : "";
      let statsBlock = "";
      if (nlpStats) {
        statsBlock = `
[FORENSIC EVIDENCE]:
- Word Count: ${nlpStats.wordCount}
- Pacing: ${nlpStats.sentenceVariance}
- Adverb Density: ${nlpStats.adverbDensity}%
- Dialogue Ratio: ${nlpStats.dialogueRatio}%
`;
      }
      const instructionBlock = `
[STRICT GRADING INSTRUCTION (-100 to +100)]:
If the story is generic, score 0.
If it has plot holes, score negative.
Only score positive if it is innovative.
        `;
      const wrapped = `
=== NARRATIVE TO ANALYZE ===
${text2}
=== END ===
${statsBlock}${contextBlock}
${instructionBlock}`;
      setStatus(`INITIALIZING ${passes} FORENSIC CORES...`);
      const temp = this.getTemp(this.settings.tempCritic, true);
      const promises = Array.from({ length: passes }, (_2, i3) => {
        return this.callAI(wrapped, NIGS_SYSTEM_PROMPT, true, false, temp).then((resStr) => this.parseJson(resStr)).catch((e2) => {
          console.error(`Core ${i3 + 1} Failed:`, e2);
          return null;
        });
      });
      const results = (await Promise.all(promises)).filter((r2) => r2 !== null);
      if (results.length === 0)
        throw new Error("ALL CORES FAILED.");
      setStatus("SYNTHESIZING FORENSIC REPORT...");
      const finalRes = this.averageResults(results);
      if (results[0].thought_process)
        finalRes.thought_process = results[0].thought_process;
      return finalRes;
    };
    this.generateOutline = async (text2, useSearch = false) => {
      setStatus("INITIALIZING ARCHIVIST PROTOCOL...");
      const prompt = this.settings.customOutlinePrompt ? this.settings.customOutlinePrompt : NIGS_OUTLINE_PROMPT;
      const temp = this.getTemp(this.settings.tempArchitect);
      return await this.callAI(text2, prompt, false, useSearch, temp);
    };
    this.getActionPlan = async (text2, focus, deepScan, quickScan) => {
      setStatus("ANALYZING WEAKNESSES...");
      let diagnosticBlock = "";
      if (deepScan) {
        diagnosticBlock += `
[DIAGNOSTIC TELEMETRY - DEEP SCAN]:
- Commercial Score: ${deepScan.commercial_score}
- Niche Score: ${deepScan.niche_score}
- Cohesion Score: ${deepScan.cohesion_score}
- Detected Issues: ${deepScan.content_warning}
`;
        if (deepScan.detailed_metrics) {
          diagnosticBlock += "\n[FAILED METRICS]:\n";
          for (const catKey in deepScan.detailed_metrics) {
            const cat = deepScan.detailed_metrics[catKey];
            if (cat.score < 0) {
              diagnosticBlock += `- ${catKey.toUpperCase()} (Avg: ${cat.score})
`;
              cat.items.forEach((i3) => {
                if (i3.score < 0)
                  diagnosticBlock += `  * ${i3.name}: ${i3.reason}
`;
              });
            }
          }
        }
      }
      if (quickScan) {
        diagnosticBlock += `
[DIAGNOSTIC TELEMETRY - QUICK SCAN]:
- Verdict: ${quickScan.letter_grade}
- Key Improvement: ${quickScan.key_improvement}
`;
      }
      let inputBlock = `TEXT TO ANALYZE:
${text2}`;
      if (diagnosticBlock)
        inputBlock = `${diagnosticBlock}

${inputBlock}`;
      if (focus && focus.trim().length > 0)
        inputBlock = `USER DIRECTIVE: Focus on "${focus}".

${inputBlock}`;
      const temp = this.getTemp(this.settings.tempArchitect);
      return this.parseJson(await this.callAI(inputBlock, NIGS_FORGE_PROMPT, true, false, temp));
    };
    this.autoRepair = async (text2, plan) => {
      setStatus("INITIATING REPAIR...");
      const prompt = this.settings.customRepairPrompt ? this.settings.customRepairPrompt : NIGS_AUTO_REPAIR_PROMPT;
      const temp = this.getTemp(this.settings.tempRepair, true);
      return await this.callAI(JSON.stringify(plan) + "\n\n" + text2, prompt, false, false, temp);
    };
    this.getMetaAnalysis = async (text2) => {
      setStatus("RUNNING DIAGNOSTICS...");
      const temp = this.getTemp(this.settings.tempCritic, true);
      return this.parseJson(await this.callAI(text2, NIGS_META_PROMPT, true, false, temp));
    };
    this.getLightGrade = async (text2) => {
      setStatus("PERFORMING QUICK SCAN...");
      const temp = this.getTemp(this.settings.tempCritic, true);
      return this.parseJson(await this.callAI(text2, NIGS_QUICK_SCAN_PROMPT, true, false, temp));
    };
    this.gradeCharacter = async (char, context) => {
      var _a3, _b3, _c2;
      setStatus(`ANALYZING ${char.name.toUpperCase()}...`);
      const prompt = `
        [TASK]: Calibrate Character Scales.
        [UPLOADED SOURCE]: ${context}...
        [PROFILE]:
        Name: ${char.name} (${char.role})
        Desc: ${char.description}
        Flaw: ${char.flaw}
        
        RETURN JSON: { "competence": number, "proactivity": number, "likability": number, "flaw": "Refined suggestion", "revelation": "Refined suggestion" }
        `;
      const temp = this.getTemp(this.settings.tempCritic, true);
      const res = await this.callAI(prompt, NIGS_WIZARD_ASSIST_PROMPT, true, false, temp);
      const data = this.parseJson(res);
      return {
        ...char,
        competence: (_a3 = data.competence) != null ? _a3 : char.competence,
        proactivity: (_b3 = data.proactivity) != null ? _b3 : char.proactivity,
        likability: (_c2 = data.likability) != null ? _c2 : char.likability,
        flaw: data.flaw || char.flaw,
        revelation: data.revelation || char.revelation
      };
    };
    this.gradeStructureBeat = async (beat, context) => {
      var _a3, _b3;
      setStatus(`ANALYZING STORY BEAT...`);
      const prompt = `
        Analyze this story beat. 
        1. CLASSIFY: Determine structural role.
        2. TENSION: Estimate narrative tension (-100 to +100).
        
        [UPLOADED SOURCE]: ${context}...
        [BEAT]: ${beat.title} - ${beat.description}

        RETURN JSON: { "tension": number, "type": "The determined type" }
        `;
      const temp = this.getTemp(this.settings.tempCritic, true);
      const res = await this.callAI(prompt, NIGS_WIZARD_ASSIST_PROMPT, true, false, temp);
      const data = this.parseJson(res);
      return {
        ...beat,
        tension: (_a3 = data.tension) != null ? _a3 : beat.tension,
        type: (_b3 = data.type) != null ? _b3 : beat.type
      };
    };
    this.assistWizard = async (field, state2) => {
      var _a3;
      setStatus("CONSULTING NARRATIVE DATABASE...");
      const sourceMaterial = state2.inspirationContext || "No source file loaded.";
      let targetContext = "";
      let specificInstruction = "";
      const parts = field.split(".");
      if (parts[0] === "characters" && parts.length >= 3) {
        const idx = parseInt(parts[1]);
        const char = state2.characters[idx];
        if (char) {
          targetContext = `
[TARGET CHARACTER]:
- Name: ${char.name}
- Role: ${char.role}
- Current Desc: ${char.description}
- Scales: Comp ${char.competence}%, Proac ${char.proactivity}%, Like ${char.likability}%
`;
          specificInstruction = `Suggest content for the '${parts[2]}' field of this specific character. Ensure it fits their Role (${char.role}).`;
        }
      } else if (parts[0] === "structure" && parts.length >= 3) {
        const idx = parseInt(parts[1]);
        const beat = state2.structure[idx];
        if (beat) {
          targetContext = `
[TARGET BEAT]:
- Title: ${beat.title}
- Type: ${beat.type}
- Current Desc: ${beat.description}
`;
          specificInstruction = `Suggest content for this specific story beat. Ensure it fulfills the structural function of a '${beat.type}'.`;
        }
      } else if (parts[0] === "structureDNA" && parts[1] === "tryFailCycles" && parts.length >= 4) {
        const idx = parseInt(parts[2]);
        const cycle = (_a3 = state2.structureDNA.tryFailCycles) == null ? void 0 : _a3[idx];
        if (cycle) {
          targetContext = `
[TARGET CYCLE ${idx + 1}]:
- Goal: ${cycle.goal}
- Attempt 1 (Fail): ${cycle.attempt1}
- Attempt 2 (Fail): ${cycle.attempt2}
- Success: ${cycle.success}
`;
          specificInstruction = `Suggest content for the '${parts[3]}' part of this Try/Fail cycle.`;
        }
      } else if (parts[0] === "threePs") {
        const map2 = {
          promise: "THE HOOK (Opening / Inciting Incident)",
          progress: "THE SHIFT (Middle / Investigation)",
          payoff: "THE CLIMAX (Ending / Resolution)"
        };
        const role = map2[parts[1]] || parts[1];
        targetContext = `[TARGET PLOT POINT]: ${role}`;
        specificInstruction = `Suggest a compelling '${role}' for this story concept.`;
      } else {
        specificInstruction = `Suggest content for the field: ${field}`;
      }
      const coreDna = {
        concept: state2.concept,
        structureDNA: state2.structureDNA,
        theme: state2.philosopher
      };
      const constraints = this.settings.wizardNegativeConstraints ? `
[NEGATIVE CONSTRAINTS (DO NOT USE)]: ${this.settings.wizardNegativeConstraints}
` : "";
      const nameRules = this.getNameProtocol();
      const prompt = `
        You are a narrative consultant. 
        [TASK]: ${specificInstruction}
        [GENRE & TONE CALIBRATION]:
        1. Analyze the [UPLOADED SOURCE MATERIAL] to determine the TONE.
        2. YOUR SUGGESTION MUST MATCH THIS TONE.
        ${constraints}
        ${nameRules}
        ${targetContext}
        [UPLOADED SOURCE MATERIAL]:
        ${sourceMaterial}
        [STORY DNA (Overview)]:
        ${JSON.stringify(coreDna, null, 2)}
        Return JSON ONLY: { "suggestion": "Your concise text suggestion." }
        `;
      const temp = this.getTemp(this.settings.tempWizard);
      const res = await this.callAI(prompt, NIGS_WIZARD_ASSIST_PROMPT, true, true, temp);
      const data = this.parseJson(res);
      return data.suggestion;
    };
    this.generateDeepNames = async (characters, context) => {
      setStatus("ETYMOLOGIST ACTIVE: DEEP RENAMING...");
      const charInput = characters.map((c2) => `- Name: ${c2.name} (Role: ${c2.role}) | Bio: ${c2.description}`).join("\n");
      const input = `
        [SOURCE MATERIAL CONTEXT]:
        ${context.substring(0, 1e3)}...
        [CHARACTERS TO RENAME]:
        ${charInput}
        `;
      const temp = this.getTemp(this.settings.tempWizard);
      const res = await this.callAI(input, NIGS_RENAME_PROMPT, true, false, temp);
      return this.parseJson(res);
    };
  }
  getAdapter() {
    switch (this.settings.aiProvider) {
      case "openai":
        return new OpenAIAdapter(this.settings.openaiKey, this.settings.openaiModel, this.settings);
      case "anthropic":
        return new AnthropicAdapter(this.settings.anthropicKey, this.settings.anthropicModel, this.settings);
      case "gemini":
      default:
        return new GeminiAdapter(this.settings.apiKey, this.settings.modelId, this.settings);
    }
  }
  getTemp(baseTemp, strictCap = false) {
    var _a3;
    const mult = (_a3 = this.settings.tempMultiplier) != null ? _a3 : 1;
    let val = baseTemp * mult;
    if (strictCap) {
      return Math.min(0.4, val);
    }
    return Math.max(0, Math.min(2, val));
  }
  estimateDuration(text2, taskType) {
    const tokenCount = Math.ceil(text2.length / 4);
    let baseTime = 3e3;
    let mult = taskType === "architect" ? 4 : 1.2;
    return Math.min(6e4, baseTime + tokenCount * 20 * mult);
  }
  async callAI(text2, sys, json = true, useSearch = false, tempOverride) {
    const adapter = this.getAdapter();
    return await adapter.generate(text2, sys, json, useSearch, tempOverride);
  }
  getNameProtocol() {
    let rules2 = "";
    if (this.settings.namePool && this.settings.namePool.trim().length > 0) {
      rules2 += `
- **PREFERRED NAMES (USE THESE):** ${this.settings.namePool}
`;
    }
    if (this.settings.negativeNamePool && this.settings.negativeNamePool.trim().length > 0) {
      rules2 += `
- **BANNED NAMES (DO NOT USE):** ${this.settings.negativeNamePool}
`;
    }
    if (rules2.length > 0) {
      return `
[NAME PROTOCOL]:${rules2}`;
    }
    return "";
  }
  averageResults(results) {
    if (results.length === 1)
      return results[0];
    const base = JSON.parse(JSON.stringify(results[0]));
    const count = results.length;
    const avg = (fn) => Math.round(results.reduce((a2, r2) => a2 + fn(r2), 0) / count);
    base.commercial_score = avg((r2) => r2.commercial_score);
    base.niche_score = avg((r2) => r2.niche_score);
    base.cohesion_score = avg((r2) => r2.cohesion_score);
    base.third_act_score = avg((r2) => r2.third_act_score);
    base.novelty_score = avg((r2) => r2.novelty_score);
    if (base.sanderson_metrics) {
      base.sanderson_metrics.promise_payoff = avg((r2) => {
        var _a3;
        return ((_a3 = r2.sanderson_metrics) == null ? void 0 : _a3.promise_payoff) || 0;
      });
      base.sanderson_metrics.laws_of_magic = avg((r2) => {
        var _a3;
        return ((_a3 = r2.sanderson_metrics) == null ? void 0 : _a3.laws_of_magic) || 0;
      });
      base.sanderson_metrics.character_agency = avg((r2) => {
        var _a3;
        return ((_a3 = r2.sanderson_metrics) == null ? void 0 : _a3.character_agency) || 0;
      });
    }
    const maxLen = results.reduce((max3, r2) => {
      var _a3;
      return Math.max(max3, ((_a3 = r2.tension_arc) == null ? void 0 : _a3.length) || 0);
    }, 0) || 6;
    base.tension_arc = Array.from(
      { length: maxLen },
      (_2, idx) => Math.round(results.reduce((sum, r2) => {
        var _a3;
        return sum + (((_a3 = r2.tension_arc) == null ? void 0 : _a3[idx]) || 0);
      }, 0) / count)
    );
    const longest = (fn) => results.reduce((a2, b) => fn(a2).length > fn(b).length ? a2 : b);
    base.content_warning = longest((r2) => r2.content_warning || "").content_warning;
    base.log_line = longest((r2) => r2.log_line || "").log_line;
    const longestMap = results.reduce((prev, curr) => {
      const prevLen = prev.structure_map ? prev.structure_map.length : 0;
      const currLen = curr.structure_map ? curr.structure_map.length : 0;
      return currLen > prevLen ? curr : prev;
    });
    base.structure_map = longestMap.structure_map;
    if (base.detailed_metrics) {
      for (const catKey in base.detailed_metrics) {
        const cat = base.detailed_metrics[catKey];
        cat.score = Math.round(results.reduce((acc, r2) => {
          var _a3, _b3;
          return acc + (((_b3 = (_a3 = r2.detailed_metrics) == null ? void 0 : _a3[catKey]) == null ? void 0 : _b3.score) || 0);
        }, 0) / count);
        if (Array.isArray(cat.items)) {
          cat.items = cat.items.map((item, idx) => {
            const itemScore = Math.round(results.reduce((acc, r2) => {
              var _a3, _b3, _c2, _d;
              return acc + (((_d = (_c2 = (_b3 = (_a3 = r2.detailed_metrics) == null ? void 0 : _a3[catKey]) == null ? void 0 : _b3.items) == null ? void 0 : _c2[idx]) == null ? void 0 : _d.score) || 0);
            }, 0) / count);
            const longestReason = results.reduce((best, r2) => {
              var _a3, _b3, _c2, _d;
              const current = ((_d = (_c2 = (_b3 = (_a3 = r2.detailed_metrics) == null ? void 0 : _a3[catKey]) == null ? void 0 : _b3.items) == null ? void 0 : _c2[idx]) == null ? void 0 : _d.reason) || "";
              return current.length > best.length ? current : best;
            }, "");
            return { ...item, score: itemScore, reason: longestReason };
          });
        }
      }
    }
    return base;
  }
  parseJson(text2) {
    try {
      const start2 = text2.indexOf("{");
      const end2 = text2.lastIndexOf("}");
      if (start2 === -1 || end2 === -1)
        throw new Error("No JSON found in response");
      const clean2 = text2.substring(start2, end2 + 1);
      const refined = clean2.replace(/```json/g, "").replace(/```/g, "");
      return JSON.parse(refined);
    } catch (e2) {
      console.error("JSON PARSE FAILURE", text2);
      throw new Error("AI returned invalid JSON. Check console.");
    }
  }
};

// CompuJudgeView.ts
var import_obsidian8 = require("obsidian");

// node_modules/svelte/src/version.js
var PUBLIC_VERSION = "5";

// node_modules/svelte/src/internal/disclose-version.js
var _a2, _b2, _c;
if (typeof window !== "undefined") {
  ((_c = (_b2 = (_a2 = window.__svelte) != null ? _a2 : window.__svelte = {}).v) != null ? _c : _b2.v = /* @__PURE__ */ new Set()).add(PUBLIC_VERSION);
}

// GradingPanel.svelte
var import_obsidian7 = require("obsidian");

// db.ts
var import_obsidian2 = require("obsidian");
var DATA_FOLDER = ".compu-judge";
var NigsDB = class {
  constructor() {
    this.plugin = null;
    this.memoryCache = /* @__PURE__ */ new Map();
  }
  connect(plugin5) {
    this.plugin = plugin5;
  }
  /**
   * Initialize DB: Create data folder and migrate legacy data if found.
   */
  async init() {
    if (!this.plugin)
      return;
    const adapter = this.plugin.app.vault.adapter;
    if (!await adapter.exists(DATA_FOLDER)) {
      await adapter.mkdir(DATA_FOLDER);
    }
    await this.migrateLegacyData();
  }
  /**
   * ONE-TIME MIGRATION: Moves data from data.json to individual files.
   */
  async migrateLegacyData() {
    if (!this.plugin || !this.plugin.settings.projects)
      return;
    const legacyProjects = this.plugin.settings.projects;
    const keys = Object.keys(legacyProjects);
    if (keys.length > 0) {
      console.log(`[Compu-Judge] Migrating ${keys.length} projects to ${DATA_FOLDER}...`);
      for (const path of keys) {
        const data = legacyProjects[path];
        if (data) {
          await this.saveProjectData(data);
        }
      }
      this.plugin.settings.projects = {};
      await this.plugin.saveSettings();
      console.log("[Compu-Judge] Migration Complete.");
    }
  }
  /**
   * Generates a safe filename for the data file based on the source note path.
   * e.g. "Folder/My Story.md" -> ".compu-judge/My_Story_md_<HASH>.json"
   */
  getStoragePath(filePath) {
    var _a3;
    let hash2 = 0;
    for (let i3 = 0; i3 < filePath.length; i3++) {
      hash2 = (hash2 << 5) - hash2 + filePath.charCodeAt(i3);
      hash2 |= 0;
    }
    const safeName = ((_a3 = filePath.split("/").pop()) == null ? void 0 : _a3.replace(/[^a-z0-9]/gi, "_")) || "untitled";
    return `${DATA_FOLDER}/${safeName}_${Math.abs(hash2)}.json`;
  }
  /**
   * Load project data from the hidden folder.
   */
  async getProjectData(filePath) {
    var _a3, _b3, _c2, _d;
    if (!this.plugin)
      throw new Error("DB Not Connected");
    if (this.memoryCache.has(filePath)) {
      return this.memoryCache.get(filePath);
    }
    const storagePath = this.getStoragePath(filePath);
    const adapter = this.plugin.app.vault.adapter;
    const cleanDefaults = {
      filePath,
      wizardState: JSON.parse(JSON.stringify(DEFAULT_WIZARD_STATE)),
      lastAiResult: null,
      lastLightResult: null,
      lastActionPlan: null,
      lastMetaResult: null,
      updatedAt: Date.now(),
      lastAnalysisMtime: null,
      archivistPrompt: "",
      archivistContext: "",
      repairFocus: ""
    };
    if (await adapter.exists(storagePath)) {
      try {
        const json = await adapter.read(storagePath);
        const stored = JSON.parse(json);
        const mergedWizard = {
          ...cleanDefaults.wizardState,
          ...stored.wizardState,
          // Ensure nested objects exist and merge defaults for safety
          structureDNA: { ...cleanDefaults.wizardState.structureDNA, ...((_a3 = stored.wizardState) == null ? void 0 : _a3.structureDNA) || {} },
          sandersonLaws: { ...cleanDefaults.wizardState.sandersonLaws, ...((_b3 = stored.wizardState) == null ? void 0 : _b3.sandersonLaws) || {} },
          threePs: { ...cleanDefaults.wizardState.threePs, ...((_c2 = stored.wizardState) == null ? void 0 : _c2.threePs) || {} },
          philosopher: { ...cleanDefaults.wizardState.philosopher, ...((_d = stored.wizardState) == null ? void 0 : _d.philosopher) || {} }
        };
        const finalData = {
          ...cleanDefaults,
          ...stored,
          wizardState: mergedWizard
        };
        this.memoryCache.set(filePath, finalData);
        return finalData;
      } catch (e2) {
        console.error(`[Compu-Judge] Corrupt data for ${filePath}`, e2);
        return cleanDefaults;
      }
    }
    return cleanDefaults;
  }
  /**
   * Save project data to the hidden folder.
   */
  async saveProjectData(data, fileMtime) {
    if (!this.plugin)
      return;
    const clean2 = JSON.parse(JSON.stringify(data));
    if (fileMtime)
      clean2.lastAnalysisMtime = fileMtime;
    clean2.updatedAt = Date.now();
    this.memoryCache.set(data.filePath, clean2);
    const storagePath = this.getStoragePath(data.filePath);
    const adapter = this.plugin.app.vault.adapter;
    try {
      await adapter.write(storagePath, JSON.stringify(clean2, null, 2));
    } catch (e2) {
      console.error(`[Compu-Judge] Save failed for ${data.filePath}`, e2);
    }
  }
  /**
   * Delete all data (Nuclear Option)
   */
  async deleteDatabase() {
    if (!this.plugin)
      return;
    const adapter = this.plugin.app.vault.adapter;
    if (await adapter.exists(DATA_FOLDER)) {
      const files = await adapter.list(DATA_FOLDER);
      for (const file of files.files) {
        await adapter.remove(file);
      }
    }
    this.memoryCache.clear();
    this.plugin.settings.projects = {};
    await this.plugin.saveSettings();
  }
};
var db = new NigsDB();

// node_modules/compromise/src/API/world.js
var methods = {
  one: {},
  two: {},
  three: {},
  four: {}
};
var model = {
  one: {},
  two: {},
  three: {}
};
var compute = {};
var hooks = [];
var world_default = { methods, model, compute, hooks };

// node_modules/compromise/src/API/methods/compute.js
var isArray = (input) => Object.prototype.toString.call(input) === "[object Array]";
var fns = {
  /** add metadata to term objects */
  compute: function(input) {
    const { world: world2 } = this;
    const compute4 = world2.compute;
    if (typeof input === "string" && compute4.hasOwnProperty(input)) {
      compute4[input](this);
    } else if (isArray(input)) {
      input.forEach((name) => {
        if (world2.compute.hasOwnProperty(name)) {
          compute4[name](this);
        } else {
          console.warn("no compute:", input);
        }
      });
    } else if (typeof input === "function") {
      input(this);
    } else {
      console.warn("no compute:", input);
    }
    return this;
  }
};
var compute_default = fns;

// node_modules/compromise/src/API/methods/loops.js
var forEach = function(cb) {
  let ptrs = this.fullPointer;
  ptrs.forEach((ptr, i3) => {
    let view = this.update([ptr]);
    cb(view, i3);
  });
  return this;
};
var map = function(cb, empty) {
  let ptrs = this.fullPointer;
  let res = ptrs.map((ptr, i3) => {
    let view = this.update([ptr]);
    let out2 = cb(view, i3);
    if (out2 === void 0) {
      return this.none();
    }
    return out2;
  });
  if (res.length === 0) {
    return empty || this.update([]);
  }
  if (res[0] !== void 0) {
    if (typeof res[0] === "string") {
      return res;
    }
    if (typeof res[0] === "object" && (res[0] === null || !res[0].isView)) {
      return res;
    }
  }
  let all4 = [];
  res.forEach((ptr) => {
    all4 = all4.concat(ptr.fullPointer);
  });
  return this.toView(all4);
};
var filter = function(cb) {
  let ptrs = this.fullPointer;
  ptrs = ptrs.filter((ptr, i3) => {
    let view = this.update([ptr]);
    return cb(view, i3);
  });
  let res = this.update(ptrs);
  return res;
};
var find = function(cb) {
  let ptrs = this.fullPointer;
  let found = ptrs.find((ptr, i3) => {
    let view = this.update([ptr]);
    return cb(view, i3);
  });
  return this.update([found]);
};
var some = function(cb) {
  let ptrs = this.fullPointer;
  return ptrs.some((ptr, i3) => {
    let view = this.update([ptr]);
    return cb(view, i3);
  });
};
var random = function(n3 = 1) {
  let ptrs = this.fullPointer;
  let r2 = Math.floor(Math.random() * ptrs.length);
  if (r2 + n3 > this.length) {
    r2 = this.length - n3;
    r2 = r2 < 0 ? 0 : r2;
  }
  ptrs = ptrs.slice(r2, r2 + n3);
  return this.update(ptrs);
};
var loops_default = { forEach, map, filter, find, some, random };

// node_modules/compromise/src/API/methods/utils.js
var utils = {
  /** */
  termList: function() {
    return this.methods.one.termList(this.docs);
  },
  /** return individual terms*/
  terms: function(n3) {
    let m3 = this.match(".");
    return typeof n3 === "number" ? m3.eq(n3) : m3;
  },
  /** */
  groups: function(group) {
    if (group || group === 0) {
      return this.update(this._groups[group] || []);
    }
    let res = {};
    Object.keys(this._groups).forEach((k2) => {
      res[k2] = this.update(this._groups[k2]);
    });
    return res;
  },
  /** */
  eq: function(n3) {
    let ptr = this.pointer;
    if (!ptr) {
      ptr = this.docs.map((_doc, i3) => [i3]);
    }
    if (ptr[n3]) {
      return this.update([ptr[n3]]);
    }
    return this.none();
  },
  /** */
  first: function() {
    return this.eq(0);
  },
  /** */
  last: function() {
    let n3 = this.fullPointer.length - 1;
    return this.eq(n3);
  },
  /** grab term[0] for every match */
  firstTerms: function() {
    return this.match("^.");
  },
  /** grab the last term for every match  */
  lastTerms: function() {
    return this.match(".$");
  },
  /** */
  slice: function(min2, max3) {
    let pntrs = this.pointer || this.docs.map((_o, n3) => [n3]);
    pntrs = pntrs.slice(min2, max3);
    return this.update(pntrs);
  },
  /** return a view of the entire document */
  all: function() {
    return this.update().toView();
  },
  /**  */
  fullSentences: function() {
    let ptrs = this.fullPointer.map((a2) => [a2[0]]);
    return this.update(ptrs).toView();
  },
  /** return a view of no parts of the document */
  none: function() {
    return this.update([]);
  },
  /** are these two views looking at the same words? */
  isDoc: function(b) {
    if (!b || !b.isView) {
      return false;
    }
    let aPtr = this.fullPointer;
    let bPtr = b.fullPointer;
    if (!aPtr.length === bPtr.length) {
      return false;
    }
    return aPtr.every((ptr, i3) => {
      if (!bPtr[i3]) {
        return false;
      }
      return ptr[0] === bPtr[i3][0] && ptr[1] === bPtr[i3][1] && ptr[2] === bPtr[i3][2];
    });
  },
  /** how many seperate terms does the document have? */
  wordCount: function() {
    return this.docs.reduce((count, terms) => {
      count += terms.filter((t3) => t3.text !== "").length;
      return count;
    }, 0);
  },
  // is the pointer the full sentence?
  isFull: function() {
    let ptrs = this.pointer;
    if (!ptrs) {
      return true;
    }
    if (ptrs.length === 0 || ptrs[0][0] !== 0) {
      return false;
    }
    let wantTerms = 0;
    let haveTerms = 0;
    this.document.forEach((terms) => wantTerms += terms.length);
    this.docs.forEach((terms) => haveTerms += terms.length);
    return wantTerms === haveTerms;
  },
  // return the nth elem of a doc
  getNth: function(n3) {
    if (typeof n3 === "number") {
      return this.eq(n3);
    } else if (typeof n3 === "string") {
      return this.if(n3);
    }
    return this;
  }
};
utils.group = utils.groups;
utils.fullSentence = utils.fullSentences;
utils.sentence = utils.fullSentences;
utils.lastTerm = utils.lastTerms;
utils.firstTerm = utils.firstTerms;
var utils_default = utils;

// node_modules/compromise/src/API/methods/index.js
var methods2 = Object.assign({}, utils_default, compute_default, loops_default);
methods2.get = methods2.eq;
var methods_default = methods2;

// node_modules/compromise/src/API/View.js
var View = class _View {
  constructor(document2, pointer, groups = {}) {
    let props = [
      ["document", document2],
      ["world", world_default],
      ["_groups", groups],
      ["_cache", null],
      ["viewType", "View"]
    ];
    props.forEach((a2) => {
      Object.defineProperty(this, a2[0], {
        value: a2[1],
        writable: true
      });
    });
    this.ptrs = pointer;
  }
  /* getters:  */
  get docs() {
    let docs = this.document;
    if (this.ptrs) {
      docs = world_default.methods.one.getDoc(this.ptrs, this.document);
    }
    return docs;
  }
  get pointer() {
    return this.ptrs;
  }
  get methods() {
    return this.world.methods;
  }
  get model() {
    return this.world.model;
  }
  get hooks() {
    return this.world.hooks;
  }
  get isView() {
    return true;
  }
  // is the view not-empty?
  get found() {
    return this.docs.length > 0;
  }
  // how many matches we have
  get length() {
    return this.docs.length;
  }
  // return a more-hackable pointer
  get fullPointer() {
    let { docs, ptrs, document: document2 } = this;
    let pointers = ptrs || docs.map((_d, n3) => [n3]);
    return pointers.map((a2) => {
      let [n3, start2, end2, id, endId] = a2;
      start2 = start2 || 0;
      end2 = end2 || (document2[n3] || []).length;
      if (document2[n3] && document2[n3][start2]) {
        id = id || document2[n3][start2].id;
        if (document2[n3][end2 - 1]) {
          endId = endId || document2[n3][end2 - 1].id;
        }
      }
      return [n3, start2, end2, id, endId];
    });
  }
  // create a new View, from this one
  update(pointer) {
    let m3 = new _View(this.document, pointer);
    if (this._cache && pointer && pointer.length > 0) {
      let cache2 = [];
      pointer.forEach((ptr, i3) => {
        let [n3, start2, end2] = ptr;
        if (ptr.length === 1) {
          cache2[i3] = this._cache[n3];
        } else if (start2 === 0 && this.document[n3].length === end2) {
          cache2[i3] = this._cache[n3];
        }
      });
      if (cache2.length > 0) {
        m3._cache = cache2;
      }
    }
    m3.world = this.world;
    return m3;
  }
  // create a new View, from this one
  toView(pointer) {
    return new _View(this.document, pointer || this.pointer);
  }
  fromText(input) {
    const { methods: methods17 } = this;
    let document2 = methods17.one.tokenize.fromString(input, this.world);
    let doc = new _View(document2);
    doc.world = this.world;
    doc.compute(["normal", "freeze", "lexicon"]);
    if (this.world.compute.preTagger) {
      doc.compute("preTagger");
    }
    doc.compute("unfreeze");
    return doc;
  }
  clone() {
    let document2 = this.document.slice(0);
    document2 = document2.map((terms) => {
      return terms.map((term) => {
        term = Object.assign({}, term);
        term.tags = new Set(term.tags);
        return term;
      });
    });
    let m3 = this.update(this.pointer);
    m3.document = document2;
    m3._cache = this._cache;
    return m3;
  }
};
Object.assign(View.prototype, methods_default);
var View_default = View;

// node_modules/compromise/src/_version.js
var version_default = "14.14.4";

// node_modules/compromise/src/API/extend.js
var isObject = function(item) {
  return item && typeof item === "object" && !Array.isArray(item);
};
function mergeDeep(model5, plugin5) {
  if (isObject(plugin5)) {
    for (const key2 in plugin5) {
      if (isObject(plugin5[key2])) {
        if (!model5[key2])
          Object.assign(model5, { [key2]: {} });
        mergeDeep(model5[key2], plugin5[key2]);
      } else {
        Object.assign(model5, { [key2]: plugin5[key2] });
      }
    }
  }
  return model5;
}
function mergeQuick(model5, plugin5) {
  for (const key2 in plugin5) {
    model5[key2] = model5[key2] || {};
    Object.assign(model5[key2], plugin5[key2]);
  }
  return model5;
}
var addIrregulars = function(model5, conj) {
  let m3 = model5.two.models || {};
  Object.keys(conj).forEach((k2) => {
    if (conj[k2].pastTense) {
      if (m3.toPast) {
        m3.toPast.ex[k2] = conj[k2].pastTense;
      }
      if (m3.fromPast) {
        m3.fromPast.ex[conj[k2].pastTense] = k2;
      }
    }
    if (conj[k2].presentTense) {
      if (m3.toPresent) {
        m3.toPresent.ex[k2] = conj[k2].presentTense;
      }
      if (m3.fromPresent) {
        m3.fromPresent.ex[conj[k2].presentTense] = k2;
      }
    }
    if (conj[k2].gerund) {
      if (m3.toGerund) {
        m3.toGerund.ex[k2] = conj[k2].gerund;
      }
      if (m3.fromGerund) {
        m3.fromGerund.ex[conj[k2].gerund] = k2;
      }
    }
    if (conj[k2].comparative) {
      if (m3.toComparative) {
        m3.toComparative.ex[k2] = conj[k2].comparative;
      }
      if (m3.fromComparative) {
        m3.fromComparative.ex[conj[k2].comparative] = k2;
      }
    }
    if (conj[k2].superlative) {
      if (m3.toSuperlative) {
        m3.toSuperlative.ex[k2] = conj[k2].superlative;
      }
      if (m3.fromSuperlative) {
        m3.fromSuperlative.ex[conj[k2].superlative] = k2;
      }
    }
  });
};
var extend = function(plugin5, world2, View2, nlp2) {
  const { methods: methods17, model: model5, compute: compute4, hooks: hooks2 } = world2;
  if (plugin5.methods) {
    mergeQuick(methods17, plugin5.methods);
  }
  if (plugin5.model) {
    mergeDeep(model5, plugin5.model);
  }
  if (plugin5.irregulars) {
    addIrregulars(model5, plugin5.irregulars);
  }
  if (plugin5.compute) {
    Object.assign(compute4, plugin5.compute);
  }
  if (hooks2) {
    world2.hooks = hooks2.concat(plugin5.hooks || []);
  }
  if (plugin5.api) {
    plugin5.api(View2);
  }
  if (plugin5.lib) {
    Object.keys(plugin5.lib).forEach((k2) => nlp2[k2] = plugin5.lib[k2]);
  }
  if (plugin5.tags) {
    nlp2.addTags(plugin5.tags);
  }
  if (plugin5.words) {
    nlp2.addWords(plugin5.words);
  }
  if (plugin5.frozen) {
    nlp2.addWords(plugin5.frozen, true);
  }
  if (plugin5.mutate) {
    plugin5.mutate(world2, nlp2);
  }
};
var extend_default = extend;

// node_modules/compromise/src/API/_lib.js
var verbose = function(set2) {
  const env2 = typeof process === "undefined" || !process.env ? self.env || {} : process.env;
  env2.DEBUG_TAGS = set2 === "tagger" || set2 === true ? true : "";
  env2.DEBUG_MATCH = set2 === "match" || set2 === true ? true : "";
  env2.DEBUG_CHUNKS = set2 === "chunker" || set2 === true ? true : "";
  return this;
};

// node_modules/compromise/src/API/inputs.js
var isObject2 = (val) => {
  return Object.prototype.toString.call(val) === "[object Object]";
};
var isArray2 = function(arr) {
  return Object.prototype.toString.call(arr) === "[object Array]";
};
var fromJson = function(json) {
  return json.map((o2) => {
    return o2.terms.map((term) => {
      if (isArray2(term.tags)) {
        term.tags = new Set(term.tags);
      }
      return term;
    });
  });
};
var preTokenized = function(arr) {
  return arr.map((a2) => {
    return a2.map((str) => {
      return {
        text: str,
        normal: str,
        //cleanup
        pre: "",
        post: " ",
        tags: /* @__PURE__ */ new Set()
      };
    });
  });
};
var inputs = function(input, View2, world2) {
  const { methods: methods17 } = world2;
  let doc = new View2([]);
  doc.world = world2;
  if (typeof input === "number") {
    input = String(input);
  }
  if (!input) {
    return doc;
  }
  if (typeof input === "string") {
    let document2 = methods17.one.tokenize.fromString(input, world2);
    return new View2(document2);
  }
  if (isObject2(input) && input.isView) {
    return new View2(input.document, input.ptrs);
  }
  if (isArray2(input)) {
    if (isArray2(input[0])) {
      let document3 = preTokenized(input);
      return new View2(document3);
    }
    let document2 = fromJson(input);
    return new View2(document2);
  }
  return doc;
};
var inputs_default = inputs;

// node_modules/compromise/src/nlp.js
var world = Object.assign({}, world_default);
var nlp = function(input, lex) {
  if (lex) {
    nlp.addWords(lex);
  }
  let doc = inputs_default(input, View_default, world);
  if (input) {
    doc.compute(world.hooks);
  }
  return doc;
};
Object.defineProperty(nlp, "_world", {
  value: world,
  writable: true
});
nlp.tokenize = function(input, lex) {
  const { compute: compute4 } = this._world;
  if (lex) {
    nlp.addWords(lex);
  }
  let doc = inputs_default(input, View_default, world);
  if (compute4.contractions) {
    doc.compute(["alias", "normal", "machine", "contractions"]);
  }
  return doc;
};
nlp.plugin = function(plugin5) {
  extend_default(plugin5, this._world, View_default, this);
  return this;
};
nlp.extend = nlp.plugin;
nlp.world = function() {
  return this._world;
};
nlp.model = function() {
  return this._world.model;
};
nlp.methods = function() {
  return this._world.methods;
};
nlp.hooks = function() {
  return this._world.hooks;
};
nlp.verbose = verbose;
nlp.version = version_default;
var nlp_default = nlp;

// node_modules/compromise/src/1-one/cache/methods/cacheDoc.js
var createCache = function(document2) {
  let cache2 = document2.map((terms) => {
    let items = /* @__PURE__ */ new Set();
    terms.forEach((term) => {
      if (term.normal !== "") {
        items.add(term.normal);
      }
      if (term.switch) {
        items.add(`%${term.switch}%`);
      }
      if (term.implicit) {
        items.add(term.implicit);
      }
      if (term.machine) {
        items.add(term.machine);
      }
      if (term.root) {
        items.add(term.root);
      }
      if (term.alias) {
        term.alias.forEach((str) => items.add(str));
      }
      let tags = Array.from(term.tags);
      for (let t3 = 0; t3 < tags.length; t3 += 1) {
        items.add("#" + tags[t3]);
      }
    });
    return items;
  });
  return cache2;
};
var cacheDoc_default = createCache;

// node_modules/compromise/src/1-one/cache/methods/index.js
var methods_default2 = {
  one: {
    cacheDoc: cacheDoc_default
  }
};

// node_modules/compromise/src/1-one/cache/api.js
var methods3 = {
  /** */
  cache: function() {
    this._cache = this.methods.one.cacheDoc(this.document);
    return this;
  },
  /** */
  uncache: function() {
    this._cache = null;
    return this;
  }
};
var addAPI = function(View2) {
  Object.assign(View2.prototype, methods3);
};
var api_default = addAPI;

// node_modules/compromise/src/1-one/cache/compute.js
var compute_default2 = {
  cache: function(view) {
    view._cache = view.methods.one.cacheDoc(view.document);
  }
};

// node_modules/compromise/src/1-one/cache/plugin.js
var plugin_default = {
  api: api_default,
  compute: compute_default2,
  methods: methods_default2
};

// node_modules/compromise/src/1-one/change/api/case.js
var case_default = {
  /** */
  toLowerCase: function() {
    this.termList().forEach((t3) => {
      t3.text = t3.text.toLowerCase();
    });
    return this;
  },
  /** */
  toUpperCase: function() {
    this.termList().forEach((t3) => {
      t3.text = t3.text.toUpperCase();
    });
    return this;
  },
  /** */
  toTitleCase: function() {
    this.termList().forEach((t3) => {
      t3.text = t3.text.replace(/^ *[a-z\u00C0-\u00FF]/, (x) => x.toUpperCase());
    });
    return this;
  },
  /** */
  toCamelCase: function() {
    this.docs.forEach((terms) => {
      terms.forEach((t3, i3) => {
        if (i3 !== 0) {
          t3.text = t3.text.replace(/^ *[a-z\u00C0-\u00FF]/, (x) => x.toUpperCase());
        }
        if (i3 !== terms.length - 1) {
          t3.post = "";
        }
      });
    });
    return this;
  }
};

// node_modules/compromise/src/1-one/change/api/lib/insert.js
var isTitleCase = (str) => /^\p{Lu}[\p{Ll}']/u.test(str) || /^\p{Lu}$/u.test(str);
var toTitleCase = (str) => str.replace(/^\p{Ll}/u, (x) => x.toUpperCase());
var toLowerCase = (str) => str.replace(/^\p{Lu}/u, (x) => x.toLowerCase());
var spliceArr = (parent, index4, child2) => {
  child2.forEach((term) => term.dirty = true);
  if (parent) {
    let args = [index4, 0].concat(child2);
    Array.prototype.splice.apply(parent, args);
  }
  return parent;
};
var endSpace = function(terms) {
  const hasSpace2 = / $/;
  const hasDash4 = /[-]/;
  let lastTerm = terms[terms.length - 1];
  if (lastTerm && !hasSpace2.test(lastTerm.post) && !hasDash4.test(lastTerm.post)) {
    lastTerm.post += " ";
  }
};
var movePunct = (source2, end2, needle) => {
  const juicy = /[-.?!,;:)'"]/g;
  let wasLast = source2[end2 - 1];
  if (!wasLast) {
    return;
  }
  let post = wasLast.post;
  if (juicy.test(post)) {
    let punct = post.match(juicy).join("");
    let last = needle[needle.length - 1];
    last.post = punct + last.post;
    wasLast.post = wasLast.post.replace(juicy, "");
  }
};
var moveTitleCase = function(home, start2, needle) {
  let from = home[start2];
  if (start2 !== 0 || !isTitleCase(from.text)) {
    return;
  }
  needle[0].text = toTitleCase(needle[0].text);
  let old = home[start2];
  if (old.tags.has("ProperNoun") || old.tags.has("Acronym")) {
    return;
  }
  if (isTitleCase(old.text) && old.text.length > 1) {
    old.text = toLowerCase(old.text);
  }
};
var cleanPrepend = function(home, ptr, needle, document2) {
  let [n3, start2, end2] = ptr;
  if (start2 === 0) {
    endSpace(needle);
  } else if (end2 === document2[n3].length) {
    endSpace(needle);
  } else {
    endSpace(needle);
    endSpace([home[ptr[1]]]);
  }
  moveTitleCase(home, start2, needle);
  spliceArr(home, start2, needle);
};
var cleanAppend = function(home, ptr, needle, document2) {
  let [n3, , end2] = ptr;
  let total = (document2[n3] || []).length;
  if (end2 < total) {
    movePunct(home, end2, needle);
    endSpace(needle);
  } else if (total === end2) {
    endSpace(home);
    movePunct(home, end2, needle);
    if (document2[n3 + 1]) {
      needle[needle.length - 1].post += " ";
    }
  }
  spliceArr(home, ptr[2], needle);
  ptr[4] = needle[needle.length - 1].id;
};

// node_modules/compromise/src/1-one/change/compute/uuid.js
var index2 = 0;
var pad3 = (str) => {
  str = str.length < 3 ? "0" + str : str;
  return str.length < 3 ? "0" + str : str;
};
var toId = function(term) {
  let [n3, i3] = term.index || [0, 0];
  index2 += 1;
  index2 = index2 > 46655 ? 0 : index2;
  n3 = n3 > 46655 ? 0 : n3;
  i3 = i3 > 1294 ? 0 : i3;
  let id = pad3(index2.toString(36));
  id += pad3(n3.toString(36));
  let tx = i3.toString(36);
  tx = tx.length < 2 ? "0" + tx : tx;
  id += tx;
  let r2 = parseInt(Math.random() * 36, 10);
  id += r2.toString(36);
  return term.normal + "|" + id.toUpperCase();
};
var uuid_default = toId;

// node_modules/compromise/src/1-one/change/api/insert.js
var expand = function(m3) {
  if (m3.has("@hasContraction") && typeof m3.contractions === "function") {
    let more = m3.grow("@hasContraction");
    more.contractions().expand();
  }
};
var isArray3 = (arr) => Object.prototype.toString.call(arr) === "[object Array]";
var addIds = function(terms) {
  terms = terms.map((term) => {
    term.id = uuid_default(term);
    return term;
  });
  return terms;
};
var getTerms = function(input, world2) {
  const { methods: methods17 } = world2;
  if (typeof input === "string") {
    return methods17.one.tokenize.fromString(input, world2)[0];
  }
  if (typeof input === "object" && input.isView) {
    return input.clone().docs[0] || [];
  }
  if (isArray3(input)) {
    return isArray3(input[0]) ? input[0] : input;
  }
  return [];
};
var insert = function(input, view, prepend) {
  const { document: document2, world: world2 } = view;
  view.uncache();
  let ptrs = view.fullPointer;
  let selfPtrs = view.fullPointer;
  view.forEach((m3, i3) => {
    let ptr = m3.fullPointer[0];
    let [n3] = ptr;
    let home = document2[n3];
    let terms = getTerms(input, world2);
    if (terms.length === 0) {
      return;
    }
    terms = addIds(terms);
    if (prepend) {
      expand(view.update([ptr]).firstTerm());
      cleanPrepend(home, ptr, terms, document2);
    } else {
      expand(view.update([ptr]).lastTerm());
      cleanAppend(home, ptr, terms, document2);
    }
    if (document2[n3] && document2[n3][ptr[1]]) {
      ptr[3] = document2[n3][ptr[1]].id;
    }
    selfPtrs[i3] = ptr;
    ptr[2] += terms.length;
    ptrs[i3] = ptr;
  });
  let doc = view.toView(ptrs);
  view.ptrs = selfPtrs;
  doc.compute(["id", "index", "freeze", "lexicon"]);
  if (doc.world.compute.preTagger) {
    doc.compute("preTagger");
  }
  doc.compute("unfreeze");
  return doc;
};
var fns2 = {
  insertAfter: function(input) {
    return insert(input, this, false);
  },
  insertBefore: function(input) {
    return insert(input, this, true);
  }
};
fns2.append = fns2.insertAfter;
fns2.prepend = fns2.insertBefore;
fns2.insert = fns2.insertAfter;
var insert_default = fns2;

// node_modules/compromise/src/1-one/change/api/replace.js
var dollarStub = /\$[0-9a-z]+/g;
var fns3 = {};
var isTitleCase2 = (str) => /^\p{Lu}[\p{Ll}']/u.test(str) || /^\p{Lu}$/u.test(str);
var toTitleCase2 = (str) => str.replace(/^\p{Ll}/u, (x) => x.toUpperCase());
var toLowerCase2 = (str) => str.replace(/^\p{Lu}/u, (x) => x.toLowerCase());
var replaceByFn = function(main, fn, keep9) {
  main.forEach((m3) => {
    let out2 = fn(m3);
    m3.replaceWith(out2, keep9);
  });
  return main;
};
var subDollarSign = function(input, main) {
  if (typeof input !== "string") {
    return input;
  }
  let groups = main.groups();
  input = input.replace(dollarStub, (a2) => {
    let num = a2.replace(/\$/, "");
    if (groups.hasOwnProperty(num)) {
      return groups[num].text();
    }
    return a2;
  });
  return input;
};
fns3.replaceWith = function(input, keep9 = {}) {
  let ptrs = this.fullPointer;
  let main = this;
  this.uncache();
  if (typeof input === "function") {
    return replaceByFn(main, input, keep9);
  }
  let terms = main.docs[0];
  if (!terms)
    return main;
  let isOriginalPossessive = keep9.possessives && terms[terms.length - 1].tags.has("Possessive");
  let isOriginalTitleCase = keep9.case && isTitleCase2(terms[0].text);
  input = subDollarSign(input, main);
  let original = this.update(ptrs);
  ptrs = ptrs.map((ptr) => ptr.slice(0, 3));
  let oldTags = (original.docs[0] || []).map((term) => Array.from(term.tags));
  let originalPre = original.docs[0][0].pre;
  let originalPost = original.docs[0][original.docs[0].length - 1].post;
  if (typeof input === "string") {
    input = this.fromText(input).compute("id");
  }
  main.insertAfter(input);
  if (original.has("@hasContraction") && main.contractions) {
    let more = main.grow("@hasContraction+");
    more.contractions().expand();
  }
  main.delete(original);
  if (isOriginalPossessive) {
    let tmp = main.docs[0];
    let term = tmp[tmp.length - 1];
    if (!term.tags.has("Possessive")) {
      term.text += "'s";
      term.normal += "'s";
      term.tags.add("Possessive");
    }
  }
  if (originalPre && main.docs[0]) {
    main.docs[0][0].pre = originalPre;
  }
  if (originalPost && main.docs[0]) {
    let lastOne = main.docs[0][main.docs[0].length - 1];
    if (!lastOne.post.trim()) {
      lastOne.post = originalPost;
    }
  }
  let m3 = main.toView(ptrs).compute(["index", "freeze", "lexicon"]);
  if (m3.world.compute.preTagger) {
    m3.compute("preTagger");
  }
  m3.compute("unfreeze");
  if (keep9.tags) {
    m3.terms().forEach((term, i3) => {
      term.tagSafe(oldTags[i3]);
    });
  }
  if (!m3.docs[0] || !m3.docs[0][0])
    return m3;
  if (keep9.case) {
    let transformCase = isOriginalTitleCase ? toTitleCase2 : toLowerCase2;
    m3.docs[0][0].text = transformCase(m3.docs[0][0].text);
  }
  return m3;
};
fns3.replace = function(match2, input, keep9) {
  if (match2 && !input) {
    return this.replaceWith(match2, keep9);
  }
  let m3 = this.match(match2);
  if (!m3.found) {
    return this;
  }
  this.soften();
  return m3.replaceWith(input, keep9);
};
var replace_default = fns3;

// node_modules/compromise/src/1-one/change/api/lib/remove.js
var repairPunct = function(terms, len) {
  let last = terms.length - 1;
  let from = terms[last];
  let to = terms[last - len];
  if (to && from) {
    to.post += from.post;
    to.post = to.post.replace(/ +([.?!,;:])/, "$1");
    to.post = to.post.replace(/[,;:]+([.?!])/, "$1");
  }
};
var pluckOut = function(document2, nots) {
  nots.forEach((ptr) => {
    let [n3, start2, end2] = ptr;
    let len = end2 - start2;
    if (!document2[n3]) {
      return;
    }
    if (end2 === document2[n3].length && end2 > 1) {
      repairPunct(document2[n3], len);
    }
    document2[n3].splice(start2, len);
  });
  for (let i3 = document2.length - 1; i3 >= 0; i3 -= 1) {
    if (document2[i3].length === 0) {
      document2.splice(i3, 1);
      if (i3 === document2.length && document2[i3 - 1]) {
        let terms = document2[i3 - 1];
        let lastTerm = terms[terms.length - 1];
        if (lastTerm) {
          lastTerm.post = lastTerm.post.trimEnd();
        }
      }
    }
  }
  return document2;
};
var remove_default = pluckOut;

// node_modules/compromise/src/1-one/change/api/remove.js
var fixPointers = function(ptrs, gonePtrs) {
  ptrs = ptrs.map((ptr) => {
    let [n3] = ptr;
    if (!gonePtrs[n3]) {
      return ptr;
    }
    gonePtrs[n3].forEach((no) => {
      let len = no[2] - no[1];
      if (ptr[1] <= no[1] && ptr[2] >= no[2]) {
        ptr[2] -= len;
      }
    });
    return ptr;
  });
  ptrs.forEach((ptr, i3) => {
    if (ptr[1] === 0 && ptr[2] == 0) {
      for (let n3 = i3 + 1; n3 < ptrs.length; n3 += 1) {
        ptrs[n3][0] -= 1;
        if (ptrs[n3][0] < 0) {
          ptrs[n3][0] = 0;
        }
      }
    }
  });
  ptrs = ptrs.filter((ptr) => ptr[2] - ptr[1] > 0);
  ptrs = ptrs.map((ptr) => {
    ptr[3] = null;
    ptr[4] = null;
    return ptr;
  });
  return ptrs;
};
var methods4 = {
  /** */
  remove: function(reg) {
    const { indexN: indexN2 } = this.methods.one.pointer;
    this.uncache();
    let self3 = this.all();
    let not = this;
    if (reg) {
      self3 = this;
      not = this.match(reg);
    }
    let isFull = !self3.ptrs;
    if (not.has("@hasContraction") && not.contractions) {
      let more = not.grow("@hasContraction");
      more.contractions().expand();
    }
    let ptrs = self3.fullPointer;
    let nots = not.fullPointer.reverse();
    let document2 = remove_default(this.document, nots);
    let gonePtrs = indexN2(nots);
    ptrs = fixPointers(ptrs, gonePtrs);
    self3.ptrs = ptrs;
    self3.document = document2;
    self3.compute("index");
    if (isFull) {
      self3.ptrs = void 0;
    }
    if (!reg) {
      this.ptrs = [];
      return self3.none();
    }
    let res = self3.toView(ptrs);
    return res;
  }
};
methods4.delete = methods4.remove;
var remove_default2 = methods4;

// node_modules/compromise/src/1-one/change/api/whitespace.js
var methods5 = {
  /** add this punctuation or whitespace before each match: */
  pre: function(str, concat) {
    if (str === void 0 && this.found) {
      return this.docs[0][0].pre;
    }
    this.docs.forEach((terms) => {
      let term = terms[0];
      if (concat === true) {
        term.pre += str;
      } else {
        term.pre = str;
      }
    });
    return this;
  },
  /** add this punctuation or whitespace after each match: */
  post: function(str, concat) {
    if (str === void 0) {
      let last = this.docs[this.docs.length - 1];
      return last[last.length - 1].post;
    }
    this.docs.forEach((terms) => {
      let term = terms[terms.length - 1];
      if (concat === true) {
        term.post += str;
      } else {
        term.post = str;
      }
    });
    return this;
  },
  /** remove whitespace from start/end */
  trim: function() {
    if (!this.found) {
      return this;
    }
    let docs = this.docs;
    let start2 = docs[0][0];
    start2.pre = start2.pre.trimStart();
    let last = docs[docs.length - 1];
    let end2 = last[last.length - 1];
    end2.post = end2.post.trimEnd();
    return this;
  },
  /** connect words with hyphen, and remove whitespace */
  hyphenate: function() {
    this.docs.forEach((terms) => {
      terms.forEach((t3, i3) => {
        if (i3 !== 0) {
          t3.pre = "";
        }
        if (terms[i3 + 1]) {
          t3.post = "-";
        }
      });
    });
    return this;
  },
  /** remove hyphens between words, and set whitespace */
  dehyphenate: function() {
    const hasHyphen3 = /[-]/;
    this.docs.forEach((terms) => {
      terms.forEach((t3) => {
        if (hasHyphen3.test(t3.post)) {
          t3.post = " ";
        }
      });
    });
    return this;
  },
  /** add quotations around these matches */
  toQuotations: function(start2, end2) {
    start2 = start2 || `"`;
    end2 = end2 || `"`;
    this.docs.forEach((terms) => {
      terms[0].pre = start2 + terms[0].pre;
      let last = terms[terms.length - 1];
      last.post = end2 + last.post;
    });
    return this;
  },
  /** add brackets around these matches */
  toParentheses: function(start2, end2) {
    start2 = start2 || `(`;
    end2 = end2 || `)`;
    this.docs.forEach((terms) => {
      terms[0].pre = start2 + terms[0].pre;
      let last = terms[terms.length - 1];
      last.post = end2 + last.post;
    });
    return this;
  }
};
methods5.deHyphenate = methods5.dehyphenate;
methods5.toQuotation = methods5.toQuotations;
var whitespace_default = methods5;

// node_modules/compromise/src/1-one/change/api/lib/_sort.js
var alpha = (a2, b) => {
  if (a2.normal < b.normal) {
    return -1;
  }
  if (a2.normal > b.normal) {
    return 1;
  }
  return 0;
};
var length = (a2, b) => {
  let left = a2.normal.trim().length;
  let right = b.normal.trim().length;
  if (left < right) {
    return 1;
  }
  if (left > right) {
    return -1;
  }
  return 0;
};
var wordCount = (a2, b) => {
  if (a2.words < b.words) {
    return 1;
  }
  if (a2.words > b.words) {
    return -1;
  }
  return 0;
};
var sequential = (a2, b) => {
  if (a2[0] < b[0]) {
    return 1;
  }
  if (a2[0] > b[0]) {
    return -1;
  }
  return a2[1] > b[1] ? 1 : -1;
};
var byFreq = function(arr) {
  let counts = {};
  arr.forEach((o2) => {
    counts[o2.normal] = counts[o2.normal] || 0;
    counts[o2.normal] += 1;
  });
  arr.sort((a2, b) => {
    let left = counts[a2.normal];
    let right = counts[b.normal];
    if (left < right) {
      return 1;
    }
    if (left > right) {
      return -1;
    }
    return 0;
  });
  return arr;
};
var sort_default = { alpha, length, wordCount, sequential, byFreq };

// node_modules/compromise/src/1-one/change/api/sort.js
var seqNames = /* @__PURE__ */ new Set(["index", "sequence", "seq", "sequential", "chron", "chronological"]);
var freqNames = /* @__PURE__ */ new Set(["freq", "frequency", "topk", "repeats"]);
var alphaNames = /* @__PURE__ */ new Set(["alpha", "alphabetical"]);
var customSort = function(view, fn) {
  let ptrs = view.fullPointer;
  ptrs = ptrs.sort((a2, b) => {
    a2 = view.update([a2]);
    b = view.update([b]);
    return fn(a2, b);
  });
  view.ptrs = ptrs;
  return view;
};
var sort = function(input) {
  let { docs, pointer } = this;
  this.uncache();
  if (typeof input === "function") {
    return customSort(this, input);
  }
  input = input || "alpha";
  let ptrs = pointer || docs.map((_d, n3) => [n3]);
  let arr = docs.map((terms, n3) => {
    return {
      index: n3,
      words: terms.length,
      normal: terms.map((t3) => t3.machine || t3.normal || "").join(" "),
      pointer: ptrs[n3]
    };
  });
  if (seqNames.has(input)) {
    input = "sequential";
  }
  if (alphaNames.has(input)) {
    input = "alpha";
  }
  if (freqNames.has(input)) {
    arr = sort_default.byFreq(arr);
    return this.update(arr.map((o2) => o2.pointer));
  }
  if (typeof sort_default[input] === "function") {
    arr = arr.sort(sort_default[input]);
    return this.update(arr.map((o2) => o2.pointer));
  }
  return this;
};
var reverse = function() {
  let ptrs = this.pointer || this.docs.map((_d, n3) => [n3]);
  ptrs = [].concat(ptrs);
  ptrs = ptrs.reverse();
  if (this._cache) {
    this._cache = this._cache.reverse();
  }
  return this.update(ptrs);
};
var unique = function() {
  let already = /* @__PURE__ */ new Set();
  let res = this.filter((m3) => {
    let txt = m3.text("machine");
    if (already.has(txt)) {
      return false;
    }
    already.add(txt);
    return true;
  });
  return res;
};
var sort_default2 = { unique, reverse, sort };

// node_modules/compromise/src/1-one/change/api/concat.js
var isArray4 = (arr) => Object.prototype.toString.call(arr) === "[object Array]";
var combineDocs = function(homeDocs, inputDocs) {
  if (homeDocs.length > 0) {
    let end2 = homeDocs[homeDocs.length - 1];
    let last = end2[end2.length - 1];
    if (/ /.test(last.post) === false) {
      last.post += " ";
    }
  }
  homeDocs = homeDocs.concat(inputDocs);
  return homeDocs;
};
var combineViews = function(home, input) {
  if (home.document === input.document) {
    let ptrs2 = home.fullPointer.concat(input.fullPointer);
    return home.toView(ptrs2).compute("index");
  }
  let ptrs = input.fullPointer;
  ptrs.forEach((a2) => {
    a2[0] += home.document.length;
  });
  home.document = combineDocs(home.document, input.docs);
  return home.all();
};
var concat_default = {
  // add string as new match/sentence
  concat: function(input) {
    if (typeof input === "string") {
      let more = this.fromText(input);
      if (!this.found || !this.ptrs) {
        this.document = this.document.concat(more.document);
      } else {
        let ptrs = this.fullPointer;
        let at = ptrs[ptrs.length - 1][0];
        this.document.splice(at, 0, ...more.document);
      }
      return this.all().compute("index");
    }
    if (typeof input === "object" && input.isView) {
      return combineViews(this, input);
    }
    if (isArray4(input)) {
      let docs = combineDocs(this.document, input);
      this.document = docs;
      return this.all();
    }
    return this;
  }
};

// node_modules/compromise/src/1-one/change/api/harden.js
var harden = function() {
  this.ptrs = this.fullPointer;
  return this;
};
var soften = function() {
  let ptr = this.ptrs;
  if (!ptr || ptr.length < 1) {
    return this;
  }
  ptr = ptr.map((a2) => a2.slice(0, 3));
  this.ptrs = ptr;
  return this;
};
var harden_default = { harden, soften };

// node_modules/compromise/src/1-one/change/api/index.js
var methods6 = Object.assign({}, case_default, insert_default, replace_default, remove_default2, whitespace_default, sort_default2, concat_default, harden_default);
var addAPI2 = function(View2) {
  Object.assign(View2.prototype, methods6);
};
var api_default2 = addAPI2;

// node_modules/compromise/src/1-one/change/compute/index.js
var compute2 = {
  id: function(view) {
    let docs = view.docs;
    for (let n3 = 0; n3 < docs.length; n3 += 1) {
      for (let i3 = 0; i3 < docs[n3].length; i3 += 1) {
        let term = docs[n3][i3];
        term.id = term.id || uuid_default(term);
      }
    }
  }
};
var compute_default3 = compute2;

// node_modules/compromise/src/1-one/change/plugin.js
var plugin_default2 = {
  api: api_default2,
  compute: compute_default3
};

// node_modules/compromise/src/1-one/contraction-one/model/contractions.js
var contractions_default = [
  // simple mappings
  { word: "@", out: ["at"] },
  { word: "arent", out: ["are", "not"] },
  { word: "alot", out: ["a", "lot"] },
  { word: "brb", out: ["be", "right", "back"] },
  { word: "cannot", out: ["can", "not"] },
  { word: "dun", out: ["do", "not"] },
  { word: "can't", out: ["can", "not"] },
  { word: "shan't", out: ["should", "not"] },
  { word: "won't", out: ["will", "not"] },
  { word: "that's", out: ["that", "is"] },
  { word: "what's", out: ["what", "is"] },
  { word: "let's", out: ["let", "us"] },
  // { word: "there's", out: ['there', 'is'] },
  { word: "dunno", out: ["do", "not", "know"] },
  { word: "gonna", out: ["going", "to"] },
  { word: "gotta", out: ["have", "got", "to"] },
  //hmm
  { word: "gimme", out: ["give", "me"] },
  { word: "outta", out: ["out", "of"] },
  { word: "tryna", out: ["trying", "to"] },
  { word: "gtg", out: ["got", "to", "go"] },
  { word: "im", out: ["i", "am"] },
  { word: "imma", out: ["I", "will"] },
  { word: "imo", out: ["in", "my", "opinion"] },
  { word: "irl", out: ["in", "real", "life"] },
  { word: "ive", out: ["i", "have"] },
  { word: "rn", out: ["right", "now"] },
  { word: "tbh", out: ["to", "be", "honest"] },
  { word: "wanna", out: ["want", "to"] },
  { word: `c'mere`, out: ["come", "here"] },
  { word: `c'mon`, out: ["come", "on"] },
  // shoulda, coulda
  { word: "shoulda", out: ["should", "have"] },
  { word: "coulda", out: ["coulda", "have"] },
  { word: "woulda", out: ["woulda", "have"] },
  { word: "musta", out: ["must", "have"] },
  { word: "tis", out: ["it", "is"] },
  { word: "twas", out: ["it", "was"] },
  { word: `y'know`, out: ["you", "know"] },
  { word: "ne'er", out: ["never"] },
  { word: "o'er", out: ["over"] },
  // contraction-part mappings
  { after: "ll", out: ["will"] },
  { after: "ve", out: ["have"] },
  { after: "re", out: ["are"] },
  { after: "m", out: ["am"] },
  // french contractions
  { before: "c", out: ["ce"] },
  { before: "m", out: ["me"] },
  { before: "n", out: ["ne"] },
  { before: "qu", out: ["que"] },
  { before: "s", out: ["se"] },
  { before: "t", out: ["tu"] },
  // t'aime
  // missing apostrophes
  { word: "shouldnt", out: ["should", "not"] },
  { word: "couldnt", out: ["could", "not"] },
  { word: "wouldnt", out: ["would", "not"] },
  { word: "hasnt", out: ["has", "not"] },
  { word: "wasnt", out: ["was", "not"] },
  { word: "isnt", out: ["is", "not"] },
  { word: "cant", out: ["can", "not"] },
  { word: "dont", out: ["do", "not"] },
  { word: "wont", out: ["will", "not"] },
  // apostrophe d
  { word: "howd", out: ["how", "did"] },
  { word: "whatd", out: ["what", "did"] },
  { word: "whend", out: ["when", "did"] },
  { word: "whered", out: ["where", "did"] }
];

// node_modules/compromise/src/1-one/contraction-one/model/number-suffix.js
var t = true;
var number_suffix_default = {
  "st": t,
  "nd": t,
  "rd": t,
  "th": t,
  "am": t,
  "pm": t,
  "max": t,
  "\xB0": t,
  "s": t,
  // 1990s
  "e": t,
  // 18e - french/spanish ordinal
  "er": t,
  //french 1er
  "\xE8re": t,
  //''
  "\xE8me": t
  //french 2me
};

// node_modules/compromise/src/1-one/contraction-one/model/index.js
var model_default = {
  one: {
    contractions: contractions_default,
    numberSuffixes: number_suffix_default
  }
};

// node_modules/compromise/src/1-one/contraction-one/compute/contractions/_splice.js
var insertContraction = function(document2, point, words) {
  let [n3, w] = point;
  if (!words || words.length === 0) {
    return;
  }
  words = words.map((word, i3) => {
    word.implicit = word.text;
    word.machine = word.text;
    word.pre = "";
    word.post = "";
    word.text = "";
    word.normal = "";
    word.index = [n3, w + i3];
    return word;
  });
  if (words[0]) {
    words[0].pre = document2[n3][w].pre;
    words[words.length - 1].post = document2[n3][w].post;
    words[0].text = document2[n3][w].text;
    words[0].normal = document2[n3][w].normal;
  }
  document2[n3].splice(w, 1, ...words);
};
var splice_default = insertContraction;

// node_modules/compromise/src/1-one/contraction-one/compute/contractions/apostrophe-d.js
var hasContraction = /'/;
var alwaysDid = /* @__PURE__ */ new Set([
  "what",
  "how",
  "when",
  "where",
  "why"
]);
var useWould = /* @__PURE__ */ new Set([
  "be",
  "go",
  "start",
  "think",
  "need"
]);
var useHad = /* @__PURE__ */ new Set([
  "been",
  "gone"
]);
var _apostropheD = function(terms, i3) {
  let before2 = terms[i3].normal.split(hasContraction)[0];
  if (alwaysDid.has(before2)) {
    return [before2, "did"];
  }
  if (terms[i3 + 1]) {
    if (useHad.has(terms[i3 + 1].normal)) {
      return [before2, "had"];
    }
    if (useWould.has(terms[i3 + 1].normal)) {
      return [before2, "would"];
    }
  }
  return null;
};
var apostrophe_d_default = _apostropheD;

// node_modules/compromise/src/1-one/contraction-one/compute/contractions/apostrophe-t.js
var apostropheT = function(terms, i3) {
  if (terms[i3].normal === "ain't" || terms[i3].normal === "aint") {
    return null;
  }
  let before2 = terms[i3].normal.replace(/n't/, "");
  return [before2, "not"];
};
var apostrophe_t_default = apostropheT;

// node_modules/compromise/src/1-one/contraction-one/compute/contractions/french.js
var hasContraction2 = /'/;
var isFeminine = /(e||aison|sion|tion)$/;
var isMasculine = /(age|isme|acle|ege|oire)$/;
var preL = (terms, i3) => {
  let after2 = terms[i3].normal.split(hasContraction2)[1];
  if (after2 && after2.endsWith("e")) {
    return ["la", after2];
  }
  return ["le", after2];
};
var preD = (terms, i3) => {
  let after2 = terms[i3].normal.split(hasContraction2)[1];
  if (after2 && isFeminine.test(after2) && !isMasculine.test(after2)) {
    return ["du", after2];
  } else if (after2 && after2.endsWith("s")) {
    return ["des", after2];
  }
  return ["de", after2];
};
var preJ = (terms, i3) => {
  let after2 = terms[i3].normal.split(hasContraction2)[1];
  return ["je", after2];
};
var french_default = {
  preJ,
  preL,
  preD
};

// node_modules/compromise/src/1-one/contraction-one/compute/contractions/number-range.js
var isRange = /^([0-9.]{1,4}[a-z]{0,2}) ?[-] ?([0-9]{1,4}[a-z]{0,2})$/i;
var timeRange = /^([0-9]{1,2}(:[0-9][0-9])?(am|pm)?) ?[-] ?([0-9]{1,2}(:[0-9][0-9])?(am|pm)?)$/i;
var phoneNum = /^[0-9]{3}-[0-9]{4}$/;
var numberRange = function(terms, i3) {
  let term = terms[i3];
  let parts = term.text.match(isRange);
  if (parts !== null) {
    if (term.tags.has("PhoneNumber") === true || phoneNum.test(term.text)) {
      return null;
    }
    return [parts[1], "to", parts[2]];
  } else {
    parts = term.text.match(timeRange);
    if (parts !== null) {
      return [parts[1], "to", parts[4]];
    }
  }
  return null;
};
var number_range_default = numberRange;

// node_modules/compromise/src/1-one/contraction-one/compute/contractions/number-unit.js
var numUnit = /^([+-]?[0-9][.,0-9]*)([a-z/]+)$/;
var numberUnit = function(terms, i3, world2) {
  const notUnit = world2.model.one.numberSuffixes || {};
  let term = terms[i3];
  let parts = term.text.match(numUnit);
  if (parts !== null) {
    let unit = parts[2].toLowerCase().trim();
    if (notUnit.hasOwnProperty(unit)) {
      return null;
    }
    return [parts[1], unit];
  }
  return null;
};
var number_unit_default = numberUnit;

// node_modules/compromise/src/1-one/contraction-one/compute/contractions/index.js
var byApostrophe = /'/;
var numDash = /^[0-9][^-]*[-].*?[0-9]/;
var reTag = function(terms, view, start2, len) {
  let tmp = view.update();
  tmp.document = [terms];
  let end2 = start2 + len;
  if (start2 > 0) {
    start2 -= 1;
  }
  if (terms[end2]) {
    end2 += 1;
  }
  tmp.ptrs = [[0, start2, end2]];
};
var byEnd = {
  // ain't
  t: (terms, i3) => apostrophe_t_default(terms, i3),
  // how'd
  d: (terms, i3) => apostrophe_d_default(terms, i3)
};
var byStart = {
  // j'aime
  j: (terms, i3) => french_default.preJ(terms, i3),
  // l'amour
  l: (terms, i3) => french_default.preL(terms, i3),
  // d'amerique
  d: (terms, i3) => french_default.preD(terms, i3)
};
var knownOnes = function(list4, term, before2, after2) {
  for (let i3 = 0; i3 < list4.length; i3 += 1) {
    let o2 = list4[i3];
    if (o2.word === term.normal) {
      return o2.out;
    } else if (after2 !== null && after2 === o2.after) {
      return [before2].concat(o2.out);
    } else if (before2 !== null && before2 === o2.before && after2 && after2.length > 2) {
      return o2.out.concat(after2);
    }
  }
  return null;
};
var toDocs = function(words, view) {
  let doc = view.fromText(words.join(" "));
  doc.compute(["id", "alias"]);
  return doc.docs[0];
};
var thereHas = function(terms, i3) {
  for (let k2 = i3 + 1; k2 < 5; k2 += 1) {
    if (!terms[k2]) {
      break;
    }
    if (terms[k2].normal === "been") {
      return ["there", "has"];
    }
  }
  return ["there", "is"];
};
var contractions = (view) => {
  let { world: world2, document: document2 } = view;
  const { model: model5, methods: methods17 } = world2;
  let list4 = model5.one.contractions || [];
  document2.forEach((terms, n3) => {
    for (let i3 = terms.length - 1; i3 >= 0; i3 -= 1) {
      let before2 = null;
      let after2 = null;
      if (byApostrophe.test(terms[i3].normal) === true) {
        let res = terms[i3].normal.split(byApostrophe);
        before2 = res[0];
        after2 = res[1];
      }
      let words = knownOnes(list4, terms[i3], before2, after2);
      if (!words && byEnd.hasOwnProperty(after2)) {
        words = byEnd[after2](terms, i3, world2);
      }
      if (!words && byStart.hasOwnProperty(before2)) {
        words = byStart[before2](terms, i3);
      }
      if (before2 === "there" && after2 === "s") {
        words = thereHas(terms, i3);
      }
      if (words) {
        words = toDocs(words, view);
        splice_default(document2, [n3, i3], words);
        reTag(document2[n3], view, i3, words.length);
        continue;
      }
      if (numDash.test(terms[i3].normal)) {
        words = number_range_default(terms, i3);
        if (words) {
          words = toDocs(words, view);
          splice_default(document2, [n3, i3], words);
          methods17.one.setTag(words, "NumberRange", world2);
          if (words[2] && words[2].tags.has("Time")) {
            methods17.one.setTag([words[0]], "Time", world2, null, "time-range");
          }
          reTag(document2[n3], view, i3, words.length);
        }
        continue;
      }
      words = number_unit_default(terms, i3, world2);
      if (words) {
        words = toDocs(words, view);
        splice_default(document2, [n3, i3], words);
        methods17.one.setTag([words[1]], "Unit", world2, null, "contraction-unit");
      }
    }
  });
};
var contractions_default2 = contractions;

// node_modules/compromise/src/1-one/contraction-one/compute/index.js
var compute_default4 = { contractions: contractions_default2 };

// node_modules/compromise/src/1-one/contraction-one/plugin.js
var plugin = {
  model: model_default,
  compute: compute_default4,
  hooks: ["contractions"]
};
var plugin_default3 = plugin;

// node_modules/compromise/src/1-one/freeze/compute.js
var freeze = function(view) {
  const world2 = view.world;
  const { model: model5, methods: methods17 } = view.world;
  const setTag2 = methods17.one.setTag;
  const { frozenLex } = model5.one;
  const multi = model5.one._multiCache || {};
  view.docs.forEach((terms) => {
    for (let i3 = 0; i3 < terms.length; i3 += 1) {
      let t3 = terms[i3];
      let word = t3.machine || t3.normal;
      if (multi[word] !== void 0 && terms[i3 + 1]) {
        let end2 = i3 + multi[word] - 1;
        for (let k2 = end2; k2 > i3; k2 -= 1) {
          let words = terms.slice(i3, k2 + 1);
          let str = words.map((term) => term.machine || term.normal).join(" ");
          if (frozenLex.hasOwnProperty(str) === true) {
            setTag2(words, frozenLex[str], world2, false, "1-frozen-multi-lexicon");
            words.forEach((term) => term.frozen = true);
            continue;
          }
        }
      }
      if (frozenLex[word] !== void 0 && frozenLex.hasOwnProperty(word)) {
        setTag2([t3], frozenLex[word], world2, false, "1-freeze-lexicon");
        t3.frozen = true;
        continue;
      }
    }
  });
};
var unfreeze = function(view) {
  view.docs.forEach((ts) => {
    ts.forEach((term) => {
      delete term.frozen;
    });
  });
  return view;
};
var compute_default5 = { frozen: freeze, freeze, unfreeze };

// node_modules/compromise/src/1-one/freeze/debug.js
var blue = (str) => "\x1B[34m" + str + "\x1B[0m";
var dim = (str) => "\x1B[3m\x1B[2m" + str + "\x1B[0m";
var debug = function(view) {
  view.docs.forEach((terms) => {
    console.log(blue("\n  \u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500"));
    terms.forEach((t3) => {
      let str = `  ${dim("\u2502")}  `;
      let txt = t3.implicit || t3.text || "-";
      if (t3.frozen === true) {
        str += `${blue(txt)} \u2744\uFE0F`;
      } else {
        str += dim(txt);
      }
      console.log(str);
    });
  });
};
var debug_default = debug;

// node_modules/compromise/src/1-one/freeze/plugin.js
var plugin_default4 = {
  // add .compute('freeze')
  compute: compute_default5,
  mutate: (world2) => {
    const methods17 = world2.methods.one;
    methods17.termMethods.isFrozen = (term) => term.frozen === true;
    methods17.debug.freeze = debug_default;
    methods17.debug.frozen = debug_default;
  },
  api: function(View2) {
    View2.prototype.freeze = function() {
      this.docs.forEach((ts) => {
        ts.forEach((term) => {
          term.frozen = true;
        });
      });
      return this;
    };
    View2.prototype.unfreeze = function() {
      this.compute("unfreeze");
    };
    View2.prototype.isFrozen = function() {
      return this.match("@isFrozen+");
    };
  },
  // run it in init
  hooks: ["freeze"]
};

// node_modules/compromise/src/1-one/lexicon/compute/multi-word.js
var multiWord = function(terms, start_i, world2) {
  const { model: model5, methods: methods17 } = world2;
  const setTag2 = methods17.one.setTag;
  const multi = model5.one._multiCache || {};
  const { lexicon: lexicon4 } = model5.one || {};
  let t3 = terms[start_i];
  let word = t3.machine || t3.normal;
  if (multi[word] !== void 0 && terms[start_i + 1]) {
    let end2 = start_i + multi[word] - 1;
    for (let i3 = end2; i3 > start_i; i3 -= 1) {
      let words = terms.slice(start_i, i3 + 1);
      if (words.length <= 1) {
        return false;
      }
      let str = words.map((term) => term.machine || term.normal).join(" ");
      if (lexicon4.hasOwnProperty(str) === true) {
        let tag2 = lexicon4[str];
        setTag2(words, tag2, world2, false, "1-multi-lexicon");
        if (tag2 && tag2.length === 2 && (tag2[0] === "PhrasalVerb" || tag2[1] === "PhrasalVerb")) {
          setTag2([words[1]], "Particle", world2, false, "1-phrasal-particle");
        }
        return true;
      }
    }
    return false;
  }
  return null;
};
var multi_word_default = multiWord;

// node_modules/compromise/src/1-one/lexicon/compute/single-word.js
var prefix = /^(under|over|mis|re|un|dis|semi|pre|post)-?/;
var allowPrefix = /* @__PURE__ */ new Set(["Verb", "Infinitive", "PastTense", "Gerund", "PresentTense", "Adjective", "Participle"]);
var checkLexicon = function(terms, i3, world2) {
  const { model: model5, methods: methods17 } = world2;
  const setTag2 = methods17.one.setTag;
  const { lexicon: lexicon4 } = model5.one;
  let t3 = terms[i3];
  let word = t3.machine || t3.normal;
  if (lexicon4[word] !== void 0 && lexicon4.hasOwnProperty(word)) {
    setTag2([t3], lexicon4[word], world2, false, "1-lexicon");
    return true;
  }
  if (t3.alias) {
    let found = t3.alias.find((str) => lexicon4.hasOwnProperty(str));
    if (found) {
      setTag2([t3], lexicon4[found], world2, false, "1-lexicon-alias");
      return true;
    }
  }
  if (prefix.test(word) === true) {
    let stem = word.replace(prefix, "");
    if (lexicon4.hasOwnProperty(stem) && stem.length > 3) {
      if (allowPrefix.has(lexicon4[stem])) {
        setTag2([t3], lexicon4[stem], world2, false, "1-lexicon-prefix");
        return true;
      }
    }
  }
  return null;
};
var single_word_default = checkLexicon;

// node_modules/compromise/src/1-one/lexicon/compute/index.js
var lexicon = function(view) {
  const world2 = view.world;
  view.docs.forEach((terms) => {
    for (let i3 = 0; i3 < terms.length; i3 += 1) {
      if (terms[i3].tags.size === 0) {
        let found = null;
        found = found || multi_word_default(terms, i3, world2);
        found = found || single_word_default(terms, i3, world2);
      }
    }
  });
};
var compute_default6 = {
  lexicon
};

// node_modules/compromise/src/1-one/lexicon/methods/expand.js
var expand2 = function(words) {
  let lex = {};
  let _multi = {};
  Object.keys(words).forEach((word) => {
    let tag2 = words[word];
    word = word.toLowerCase().trim();
    word = word.replace(/'s\b/, "");
    let split3 = word.split(/ /);
    if (split3.length > 1) {
      if (_multi[split3[0]] === void 0 || split3.length > _multi[split3[0]]) {
        _multi[split3[0]] = split3.length;
      }
    }
    lex[word] = lex[word] || tag2;
  });
  delete lex[""];
  delete lex[null];
  delete lex[" "];
  return { lex, _multi };
};
var expand_default = expand2;

// node_modules/compromise/src/1-one/lexicon/methods/index.js
var methods_default3 = {
  one: {
    expandLexicon: expand_default
  }
};

// node_modules/compromise/src/1-one/lexicon/lib.js
var addWords = function(words, isFrozen = false) {
  const world2 = this.world();
  const { methods: methods17, model: model5 } = world2;
  if (!words) {
    return;
  }
  Object.keys(words).forEach((k2) => {
    if (typeof words[k2] === "string" && words[k2].startsWith("#")) {
      words[k2] = words[k2].replace(/^#/, "");
    }
  });
  if (isFrozen === true) {
    let { lex: lex2, _multi: _multi2 } = methods17.one.expandLexicon(words, world2);
    Object.assign(model5.one._multiCache, _multi2);
    Object.assign(model5.one.frozenLex, lex2);
    return;
  }
  if (methods17.two.expandLexicon) {
    let { lex: lex2, _multi: _multi2 } = methods17.two.expandLexicon(words, world2);
    Object.assign(model5.one.lexicon, lex2);
    Object.assign(model5.one._multiCache, _multi2);
  }
  let { lex, _multi } = methods17.one.expandLexicon(words, world2);
  Object.assign(model5.one.lexicon, lex);
  Object.assign(model5.one._multiCache, _multi);
};
var lib_default = { addWords };

// node_modules/compromise/src/1-one/lexicon/plugin.js
var model2 = {
  one: {
    lexicon: {},
    //setup blank lexicon
    _multiCache: {},
    frozenLex: {}
    //2nd lexicon
  }
};
var plugin_default5 = {
  model: model2,
  methods: methods_default3,
  compute: compute_default6,
  lib: lib_default,
  hooks: ["lexicon"]
};

// node_modules/compromise/src/1-one/lookup/api/buildTrie/index.js
var tokenize = function(phrase, world2) {
  const { methods: methods17, model: model5 } = world2;
  let terms = methods17.one.tokenize.splitTerms(phrase, model5).map((t3) => methods17.one.tokenize.splitWhitespace(t3, model5));
  return terms.map((term) => term.text.toLowerCase());
};
var buildTrie = function(phrases, world2) {
  let goNext = [{}];
  let endAs = [null];
  let failTo = [0];
  let xs = [];
  let n3 = 0;
  phrases.forEach(function(phrase) {
    let curr = 0;
    let words = tokenize(phrase, world2);
    for (let i3 = 0; i3 < words.length; i3++) {
      let word = words[i3];
      if (goNext[curr] && goNext[curr].hasOwnProperty(word)) {
        curr = goNext[curr][word];
      } else {
        n3++;
        goNext[curr][word] = n3;
        goNext[n3] = {};
        curr = n3;
        endAs[n3] = null;
      }
    }
    endAs[curr] = [words.length];
  });
  for (let word in goNext[0]) {
    n3 = goNext[0][word];
    failTo[n3] = 0;
    xs.push(n3);
  }
  while (xs.length) {
    let r2 = xs.shift();
    let keys = Object.keys(goNext[r2]);
    for (let i3 = 0; i3 < keys.length; i3 += 1) {
      let word = keys[i3];
      let s3 = goNext[r2][word];
      xs.push(s3);
      n3 = failTo[r2];
      while (n3 > 0 && !goNext[n3].hasOwnProperty(word)) {
        n3 = failTo[n3];
      }
      if (goNext.hasOwnProperty(n3)) {
        let fs = goNext[n3][word];
        failTo[s3] = fs;
        if (endAs[fs]) {
          endAs[s3] = endAs[s3] || [];
          endAs[s3] = endAs[s3].concat(endAs[fs]);
        }
      } else {
        failTo[s3] = 0;
      }
    }
  }
  return { goNext, endAs, failTo };
};
var buildTrie_default = buildTrie;

// node_modules/compromise/src/1-one/lookup/api/scan.js
var scanWords = function(terms, trie, opts2) {
  let n3 = 0;
  let results = [];
  for (let i3 = 0; i3 < terms.length; i3++) {
    let word = terms[i3][opts2.form] || terms[i3].normal;
    while (n3 > 0 && (trie.goNext[n3] === void 0 || !trie.goNext[n3].hasOwnProperty(word))) {
      n3 = trie.failTo[n3] || 0;
    }
    if (!trie.goNext[n3].hasOwnProperty(word)) {
      continue;
    }
    n3 = trie.goNext[n3][word];
    if (trie.endAs[n3]) {
      let arr = trie.endAs[n3];
      for (let o2 = 0; o2 < arr.length; o2++) {
        let len = arr[o2];
        let term = terms[i3 - len + 1];
        let [no, start2] = term.index;
        results.push([no, start2, start2 + len, term.id]);
      }
    }
  }
  return results;
};
var cacheMiss = function(words, cache2) {
  for (let i3 = 0; i3 < words.length; i3 += 1) {
    if (cache2.has(words[i3]) === true) {
      return false;
    }
  }
  return true;
};
var scan = function(view, trie, opts2) {
  let results = [];
  opts2.form = opts2.form || "normal";
  let docs = view.docs;
  if (!trie.goNext || !trie.goNext[0]) {
    console.error("Compromise invalid lookup trie");
    return view.none();
  }
  let firstWords = Object.keys(trie.goNext[0]);
  for (let i3 = 0; i3 < docs.length; i3++) {
    if (view._cache && view._cache[i3] && cacheMiss(firstWords, view._cache[i3]) === true) {
      continue;
    }
    let terms = docs[i3];
    let found = scanWords(terms, trie, opts2);
    if (found.length > 0) {
      results = results.concat(found);
    }
  }
  return view.update(results);
};
var scan_default = scan;

// node_modules/compromise/src/1-one/lookup/api/index.js
var isObject3 = (val) => {
  return Object.prototype.toString.call(val) === "[object Object]";
};
function api_default3(View2) {
  View2.prototype.lookup = function(input, opts2 = {}) {
    if (!input) {
      return this.none();
    }
    if (typeof input === "string") {
      input = [input];
    }
    let trie = isObject3(input) ? input : buildTrie_default(input, this.world);
    let res = scan_default(this, trie, opts2);
    res = res.settle();
    return res;
  };
}

// node_modules/compromise/src/1-one/lookup/api/buildTrie/compress.js
var truncate = (list4, val) => {
  for (let i3 = list4.length - 1; i3 >= 0; i3 -= 1) {
    if (list4[i3] !== val) {
      list4 = list4.slice(0, i3 + 1);
      return list4;
    }
  }
  return list4;
};
var compress = function(trie) {
  trie.goNext = trie.goNext.map((o2) => {
    if (Object.keys(o2).length === 0) {
      return void 0;
    }
    return o2;
  });
  trie.goNext = truncate(trie.goNext, void 0);
  trie.failTo = truncate(trie.failTo, 0);
  trie.endAs = truncate(trie.endAs, null);
  return trie;
};
var compress_default = compress;

// node_modules/compromise/src/1-one/lookup/plugin.js
var lib = {
  /** turn an array or object into a compressed trie*/
  buildTrie: function(input) {
    const trie = buildTrie_default(input, this.world());
    return compress_default(trie);
  }
};
lib.compile = lib.buildTrie;
var plugin_default6 = {
  api: api_default3,
  lib
};

// node_modules/compromise/src/1-one/match/api/_lib.js
var relPointer = function(ptrs, parent) {
  if (!parent) {
    return ptrs;
  }
  ptrs.forEach((ptr) => {
    let n3 = ptr[0];
    if (parent[n3]) {
      ptr[0] = parent[n3][0];
      ptr[1] += parent[n3][1];
      ptr[2] += parent[n3][1];
    }
  });
  return ptrs;
};
var fixPointers2 = function(res, parent) {
  let { ptrs, byGroup } = res;
  ptrs = relPointer(ptrs, parent);
  Object.keys(byGroup).forEach((k2) => {
    byGroup[k2] = relPointer(byGroup[k2], parent);
  });
  return { ptrs, byGroup };
};
var parseRegs = function(regs, opts2, world2) {
  const one = world2.methods.one;
  if (typeof regs === "number") {
    regs = String(regs);
  }
  if (typeof regs === "string") {
    regs = one.killUnicode(regs, world2);
    regs = one.parseMatch(regs, opts2, world2);
  }
  return regs;
};
var isObject4 = (val) => {
  return Object.prototype.toString.call(val) === "[object Object]";
};
var isView = (val) => val && isObject4(val) && val.isView === true;
var isNet = (val) => val && isObject4(val) && val.isNet === true;

// node_modules/compromise/src/1-one/match/api/match.js
var match = function(regs, group, opts2) {
  const one = this.methods.one;
  if (isView(regs)) {
    return this.intersection(regs);
  }
  if (isNet(regs)) {
    return this.sweep(regs, { tagger: false }).view.settle();
  }
  regs = parseRegs(regs, opts2, this.world);
  let todo = { regs, group };
  let res = one.match(this.docs, todo, this._cache);
  let { ptrs, byGroup } = fixPointers2(res, this.fullPointer);
  let view = this.toView(ptrs);
  view._groups = byGroup;
  return view;
};
var matchOne = function(regs, group, opts2) {
  const one = this.methods.one;
  if (isView(regs)) {
    return this.intersection(regs).eq(0);
  }
  if (isNet(regs)) {
    return this.sweep(regs, { tagger: false, matchOne: true }).view;
  }
  regs = parseRegs(regs, opts2, this.world);
  let todo = { regs, group, justOne: true };
  let res = one.match(this.docs, todo, this._cache);
  let { ptrs, byGroup } = fixPointers2(res, this.fullPointer);
  let view = this.toView(ptrs);
  view._groups = byGroup;
  return view;
};
var has = function(regs, group, opts2) {
  const one = this.methods.one;
  if (isView(regs)) {
    let ptrs2 = this.intersection(regs).fullPointer;
    return ptrs2.length > 0;
  }
  if (isNet(regs)) {
    return this.sweep(regs, { tagger: false }).view.found;
  }
  regs = parseRegs(regs, opts2, this.world);
  let todo = { regs, group, justOne: true };
  let ptrs = one.match(this.docs, todo, this._cache).ptrs;
  return ptrs.length > 0;
};
var ifFn = function(regs, group, opts2) {
  const one = this.methods.one;
  if (isView(regs)) {
    return this.filter((m3) => m3.intersection(regs).found);
  }
  if (isNet(regs)) {
    let m3 = this.sweep(regs, { tagger: false }).view.settle();
    return this.if(m3);
  }
  regs = parseRegs(regs, opts2, this.world);
  let todo = { regs, group, justOne: true };
  let ptrs = this.fullPointer;
  let cache2 = this._cache || [];
  ptrs = ptrs.filter((ptr, i3) => {
    let m3 = this.update([ptr]);
    let res = one.match(m3.docs, todo, cache2[i3]).ptrs;
    return res.length > 0;
  });
  let view = this.update(ptrs);
  if (this._cache) {
    view._cache = ptrs.map((ptr) => cache2[ptr[0]]);
  }
  return view;
};
var ifNo = function(regs, group, opts2) {
  const { methods: methods17 } = this;
  const one = methods17.one;
  if (isView(regs)) {
    return this.filter((m3) => !m3.intersection(regs).found);
  }
  if (isNet(regs)) {
    let m3 = this.sweep(regs, { tagger: false }).view.settle();
    return this.ifNo(m3);
  }
  regs = parseRegs(regs, opts2, this.world);
  let cache2 = this._cache || [];
  let view = this.filter((m3, i3) => {
    let todo = { regs, group, justOne: true };
    let ptrs = one.match(m3.docs, todo, cache2[i3]).ptrs;
    return ptrs.length === 0;
  });
  if (this._cache) {
    view._cache = view.ptrs.map((ptr) => cache2[ptr[0]]);
  }
  return view;
};
var match_default = { matchOne, match, has, if: ifFn, ifNo };

// node_modules/compromise/src/1-one/match/api/lookaround.js
var before = function(regs, group, opts2) {
  const { indexN: indexN2 } = this.methods.one.pointer;
  let pre = [];
  let byN = indexN2(this.fullPointer);
  Object.keys(byN).forEach((k2) => {
    let first = byN[k2].sort((a2, b) => a2[1] > b[1] ? 1 : -1)[0];
    if (first[1] > 0) {
      pre.push([first[0], 0, first[1]]);
    }
  });
  let preWords = this.toView(pre);
  if (!regs) {
    return preWords;
  }
  return preWords.match(regs, group, opts2);
};
var after = function(regs, group, opts2) {
  const { indexN: indexN2 } = this.methods.one.pointer;
  let post = [];
  let byN = indexN2(this.fullPointer);
  let document2 = this.document;
  Object.keys(byN).forEach((k2) => {
    let last = byN[k2].sort((a2, b) => a2[1] > b[1] ? -1 : 1)[0];
    let [n3, , end2] = last;
    if (end2 < document2[n3].length) {
      post.push([n3, end2, document2[n3].length]);
    }
  });
  let postWords = this.toView(post);
  if (!regs) {
    return postWords;
  }
  return postWords.match(regs, group, opts2);
};
var growLeft = function(regs, group, opts2) {
  if (typeof regs === "string") {
    regs = this.world.methods.one.parseMatch(regs, opts2, this.world);
  }
  regs[regs.length - 1].end = true;
  let ptrs = this.fullPointer;
  this.forEach((m3, n3) => {
    let more = m3.before(regs, group);
    if (more.found) {
      let terms = more.terms();
      ptrs[n3][1] -= terms.length;
      ptrs[n3][3] = terms.docs[0][0].id;
    }
  });
  return this.update(ptrs);
};
var growRight = function(regs, group, opts2) {
  if (typeof regs === "string") {
    regs = this.world.methods.one.parseMatch(regs, opts2, this.world);
  }
  regs[0].start = true;
  let ptrs = this.fullPointer;
  this.forEach((m3, n3) => {
    let more = m3.after(regs, group);
    if (more.found) {
      let terms = more.terms();
      ptrs[n3][2] += terms.length;
      ptrs[n3][4] = null;
    }
  });
  return this.update(ptrs);
};
var grow = function(regs, group, opts2) {
  return this.growRight(regs, group, opts2).growLeft(regs, group, opts2);
};
var lookaround_default = { before, after, growLeft, growRight, grow };

// node_modules/compromise/src/1-one/match/api/split.js
var combine = function(left, right) {
  return [left[0], left[1], right[2]];
};
var isArray5 = function(arr) {
  return Object.prototype.toString.call(arr) === "[object Array]";
};
var getDoc = (reg, view, group) => {
  if (typeof reg === "string" || isArray5(reg)) {
    return view.match(reg, group);
  }
  if (!reg) {
    return view.none();
  }
  return reg;
};
var addIds2 = function(ptr, view) {
  let [n3, start2, end2] = ptr;
  if (view.document[n3] && view.document[n3][start2]) {
    ptr[3] = ptr[3] || view.document[n3][start2].id;
    if (view.document[n3][end2 - 1]) {
      ptr[4] = ptr[4] || view.document[n3][end2 - 1].id;
    }
  }
  return ptr;
};
var methods7 = {};
methods7.splitOn = function(m3, group) {
  const { splitAll: splitAll2 } = this.methods.one.pointer;
  let splits = getDoc(m3, this, group).fullPointer;
  let all4 = splitAll2(this.fullPointer, splits);
  let res = [];
  all4.forEach((o2) => {
    res.push(o2.passthrough);
    res.push(o2.before);
    res.push(o2.match);
    res.push(o2.after);
  });
  res = res.filter((p5) => p5);
  res = res.map((p5) => addIds2(p5, this));
  return this.update(res);
};
methods7.splitBefore = function(m3, group) {
  const { splitAll: splitAll2 } = this.methods.one.pointer;
  let splits = getDoc(m3, this, group).fullPointer;
  let all4 = splitAll2(this.fullPointer, splits);
  for (let i3 = 0; i3 < all4.length; i3 += 1) {
    if (!all4[i3].after && all4[i3 + 1] && all4[i3 + 1].before) {
      if (all4[i3].match && all4[i3].match[0] === all4[i3 + 1].before[0]) {
        all4[i3].after = all4[i3 + 1].before;
        delete all4[i3 + 1].before;
      }
    }
  }
  let res = [];
  all4.forEach((o2) => {
    res.push(o2.passthrough);
    res.push(o2.before);
    if (o2.match && o2.after) {
      res.push(combine(o2.match, o2.after));
    } else {
      res.push(o2.match);
    }
  });
  res = res.filter((p5) => p5);
  res = res.map((p5) => addIds2(p5, this));
  return this.update(res);
};
methods7.splitAfter = function(m3, group) {
  const { splitAll: splitAll2 } = this.methods.one.pointer;
  let splits = getDoc(m3, this, group).fullPointer;
  let all4 = splitAll2(this.fullPointer, splits);
  let res = [];
  all4.forEach((o2) => {
    res.push(o2.passthrough);
    if (o2.before && o2.match) {
      res.push(combine(o2.before, o2.match));
    } else {
      res.push(o2.before);
      res.push(o2.match);
    }
    res.push(o2.after);
  });
  res = res.filter((p5) => p5);
  res = res.map((p5) => addIds2(p5, this));
  return this.update(res);
};
methods7.split = methods7.splitAfter;
var split_default = methods7;

// node_modules/compromise/src/1-one/match/api/join.js
var isNeighbour = function(ptrL, ptrR) {
  if (!ptrL || !ptrR) {
    return false;
  }
  if (ptrL[0] !== ptrR[0]) {
    return false;
  }
  return ptrL[2] === ptrR[1];
};
var mergeIf = function(doc, lMatch, rMatch) {
  const world2 = doc.world;
  const parseMatch = world2.methods.one.parseMatch;
  lMatch = lMatch || ".$";
  rMatch = rMatch || "^.";
  let leftMatch = parseMatch(lMatch, {}, world2);
  let rightMatch = parseMatch(rMatch, {}, world2);
  leftMatch[leftMatch.length - 1].end = true;
  rightMatch[0].start = true;
  let ptrs = doc.fullPointer;
  let res = [ptrs[0]];
  for (let i3 = 1; i3 < ptrs.length; i3 += 1) {
    let ptrL = res[res.length - 1];
    let ptrR = ptrs[i3];
    let left = doc.update([ptrL]);
    let right = doc.update([ptrR]);
    if (isNeighbour(ptrL, ptrR) && left.has(leftMatch) && right.has(rightMatch)) {
      res[res.length - 1] = [ptrL[0], ptrL[1], ptrR[2], ptrL[3], ptrR[4]];
    } else {
      res.push(ptrR);
    }
  }
  return doc.update(res);
};
var methods8 = {
  //  merge only if conditions are met
  joinIf: function(lMatch, rMatch) {
    return mergeIf(this, lMatch, rMatch);
  },
  // merge all neighbouring matches
  join: function() {
    return mergeIf(this);
  }
};
var join_default = methods8;

// node_modules/compromise/src/1-one/match/api/index.js
var methods9 = Object.assign({}, match_default, lookaround_default, split_default, join_default);
methods9.lookBehind = methods9.before;
methods9.lookBefore = methods9.before;
methods9.lookAhead = methods9.after;
methods9.lookAfter = methods9.after;
methods9.notIf = methods9.ifNo;
var matchAPI = function(View2) {
  Object.assign(View2.prototype, methods9);
};
var api_default4 = matchAPI;

// node_modules/compromise/src/1-one/match/methods/parseMatch/01-parseBlocks.js
var bySlashes = /(?:^|\s)([![^]*(?:<[^<]*>)?\/.*?[^\\/]\/[?\]+*$~]*)(?:\s|$)/;
var byParentheses = /([!~[^]*(?:<[^<]*>)?\([^)]+[^\\)]\)[?\]+*$~]*)(?:\s|$)/;
var byWord = / /g;
var isBlock = (str) => {
  return /^[![^]*(<[^<]*>)?\(/.test(str) && /\)[?\]+*$~]*$/.test(str);
};
var isReg = (str) => {
  return /^[![^]*(<[^<]*>)?\//.test(str) && /\/[?\]+*$~]*$/.test(str);
};
var cleanUp = function(arr) {
  arr = arr.map((str) => str.trim());
  arr = arr.filter((str) => str);
  return arr;
};
var parseBlocks = function(txt) {
  let arr = txt.split(bySlashes);
  let res = [];
  arr.forEach((str) => {
    if (isReg(str)) {
      res.push(str);
      return;
    }
    res = res.concat(str.split(byParentheses));
  });
  res = cleanUp(res);
  let final = [];
  res.forEach((str) => {
    if (isBlock(str)) {
      final.push(str);
    } else if (isReg(str)) {
      final.push(str);
    } else {
      final = final.concat(str.split(byWord));
    }
  });
  final = cleanUp(final);
  return final;
};
var parseBlocks_default = parseBlocks;

// node_modules/compromise/src/1-one/match/methods/parseMatch/02-parseToken.js
var hasMinMax = /\{([0-9]+)?(, *[0-9]*)?\}/;
var andSign = /&&/;
var captureName = new RegExp(/^<\s*(\S+)\s*>/);
var titleCase = (str) => str.charAt(0).toUpperCase() + str.substring(1);
var end = (str) => str.charAt(str.length - 1);
var start = (str) => str.charAt(0);
var stripStart = (str) => str.substring(1);
var stripEnd = (str) => str.substring(0, str.length - 1);
var stripBoth = function(str) {
  str = stripStart(str);
  str = stripEnd(str);
  return str;
};
var parseToken = function(w, opts2) {
  let obj = {};
  for (let i3 = 0; i3 < 2; i3 += 1) {
    if (end(w) === "$") {
      obj.end = true;
      w = stripEnd(w);
    }
    if (start(w) === "^") {
      obj.start = true;
      w = stripStart(w);
    }
    if (end(w) === "?") {
      obj.optional = true;
      w = stripEnd(w);
    }
    if (start(w) === "[" || end(w) === "]") {
      obj.group = null;
      if (start(w) === "[") {
        obj.groupStart = true;
      }
      if (end(w) === "]") {
        obj.groupEnd = true;
      }
      w = w.replace(/^\[/, "");
      w = w.replace(/\]$/, "");
      if (start(w) === "<") {
        const res = captureName.exec(w);
        if (res.length >= 2) {
          obj.group = res[1];
          w = w.replace(res[0], "");
        }
      }
    }
    if (end(w) === "+") {
      obj.greedy = true;
      w = stripEnd(w);
    }
    if (w !== "*" && end(w) === "*" && w !== "\\*") {
      obj.greedy = true;
      w = stripEnd(w);
    }
    if (start(w) === "!") {
      obj.negative = true;
      w = stripStart(w);
    }
    if (start(w) === "~" && end(w) === "~" && w.length > 2) {
      w = stripBoth(w);
      obj.fuzzy = true;
      obj.min = opts2.fuzzy || 0.85;
      if (/\(/.test(w) === false) {
        obj.word = w;
        return obj;
      }
    }
    if (start(w) === "/" && end(w) === "/") {
      w = stripBoth(w);
      if (opts2.caseSensitive) {
        obj.use = "text";
      }
      obj.regex = new RegExp(w);
      return obj;
    }
    if (hasMinMax.test(w) === true) {
      w = w.replace(hasMinMax, (_a3, b, c2) => {
        if (c2 === void 0) {
          obj.min = Number(b);
          obj.max = Number(b);
        } else {
          c2 = c2.replace(/, */, "");
          if (b === void 0) {
            obj.min = 0;
            obj.max = Number(c2);
          } else {
            obj.min = Number(b);
            obj.max = Number(c2 || 999);
          }
        }
        obj.greedy = true;
        if (!obj.min) {
          obj.optional = true;
        }
        return "";
      });
    }
    if (start(w) === "(" && end(w) === ")") {
      if (andSign.test(w)) {
        obj.choices = w.split(andSign);
        obj.operator = "and";
      } else {
        obj.choices = w.split("|");
        obj.operator = "or";
      }
      obj.choices[0] = stripStart(obj.choices[0]);
      let last = obj.choices.length - 1;
      obj.choices[last] = stripEnd(obj.choices[last]);
      obj.choices = obj.choices.map((s3) => s3.trim());
      obj.choices = obj.choices.filter((s3) => s3);
      obj.choices = obj.choices.map((str) => {
        return str.split(/ /g).map((s3) => parseToken(s3, opts2));
      });
      w = "";
    }
    if (start(w) === "{" && end(w) === "}") {
      w = stripBoth(w);
      obj.root = w;
      if (/\//.test(w)) {
        let split3 = obj.root.split(/\//);
        obj.root = split3[0];
        obj.pos = split3[1];
        if (obj.pos === "adj") {
          obj.pos = "Adjective";
        }
        obj.pos = obj.pos.charAt(0).toUpperCase() + obj.pos.substr(1).toLowerCase();
        if (split3[2] !== void 0) {
          obj.sense = split3[2];
        }
      }
      return obj;
    }
    if (start(w) === "<" && end(w) === ">") {
      w = stripBoth(w);
      obj.chunk = titleCase(w);
      obj.greedy = true;
      return obj;
    }
    if (start(w) === "%" && end(w) === "%") {
      w = stripBoth(w);
      obj.switch = w;
      return obj;
    }
  }
  if (start(w) === "#") {
    obj.tag = stripStart(w);
    obj.tag = titleCase(obj.tag);
    return obj;
  }
  if (start(w) === "@") {
    obj.method = stripStart(w);
    return obj;
  }
  if (w === ".") {
    obj.anything = true;
    return obj;
  }
  if (w === "*") {
    obj.anything = true;
    obj.greedy = true;
    obj.optional = true;
    return obj;
  }
  if (w) {
    w = w.replace("\\*", "*");
    w = w.replace("\\.", ".");
    if (opts2.caseSensitive) {
      obj.use = "text";
    } else {
      w = w.toLowerCase();
    }
    obj.word = w;
  }
  return obj;
};
var parseToken_default = parseToken;

// node_modules/compromise/src/1-one/match/methods/parseMatch/03-splitHyphens.js
var hasDash = /[a-z0-9][-][a-z]/i;
var splitHyphens = function(regs, world2) {
  let prefixes2 = world2.model.one.prefixes;
  for (let i3 = regs.length - 1; i3 >= 0; i3 -= 1) {
    let reg = regs[i3];
    if (reg.word && hasDash.test(reg.word)) {
      let words = reg.word.split(/[-]/g);
      if (prefixes2.hasOwnProperty(words[0])) {
        continue;
      }
      words = words.filter((w) => w).reverse();
      regs.splice(i3, 1);
      words.forEach((w) => {
        let obj = Object.assign({}, reg);
        obj.word = w;
        regs.splice(i3, 0, obj);
      });
    }
  }
  return regs;
};
var splitHyphens_default = splitHyphens;

// node_modules/compromise/src/1-one/match/methods/parseMatch/04-inflect-root.js
var addVerbs = function(token, world2) {
  let { all: all4 } = world2.methods.two.transform.verb || {};
  let str = token.root;
  if (!all4) {
    return [];
  }
  return all4(str, world2.model);
};
var addNoun = function(token, world2) {
  let { all: all4 } = world2.methods.two.transform.noun || {};
  if (!all4) {
    return [token.root];
  }
  return all4(token.root, world2.model);
};
var addAdjective = function(token, world2) {
  let { all: all4 } = world2.methods.two.transform.adjective || {};
  if (!all4) {
    return [token.root];
  }
  return all4(token.root, world2.model);
};
var inflectRoot = function(regs, world2) {
  regs = regs.map((token) => {
    if (token.root) {
      if (world2.methods.two && world2.methods.two.transform) {
        let choices = [];
        if (token.pos) {
          if (token.pos === "Verb") {
            choices = choices.concat(addVerbs(token, world2));
          } else if (token.pos === "Noun") {
            choices = choices.concat(addNoun(token, world2));
          } else if (token.pos === "Adjective") {
            choices = choices.concat(addAdjective(token, world2));
          }
        } else {
          choices = choices.concat(addVerbs(token, world2));
          choices = choices.concat(addNoun(token, world2));
          choices = choices.concat(addAdjective(token, world2));
        }
        choices = choices.filter((str) => str);
        if (choices.length > 0) {
          token.operator = "or";
          token.fastOr = new Set(choices);
        }
      } else {
        token.machine = token.root;
        delete token.id;
        delete token.root;
      }
    }
    return token;
  });
  return regs;
};
var inflect_root_default = inflectRoot;

// node_modules/compromise/src/1-one/match/methods/parseMatch/05-postProcess.js
var nameGroups = function(regs) {
  let index4 = 0;
  let inGroup = null;
  for (let i3 = 0; i3 < regs.length; i3++) {
    const token = regs[i3];
    if (token.groupStart === true) {
      inGroup = token.group;
      if (inGroup === null) {
        inGroup = String(index4);
        index4 += 1;
      }
    }
    if (inGroup !== null) {
      token.group = inGroup;
    }
    if (token.groupEnd === true) {
      inGroup = null;
    }
  }
  return regs;
};
var doFastOrMode = function(tokens) {
  return tokens.map((token) => {
    if (token.choices !== void 0) {
      if (token.operator !== "or") {
        return token;
      }
      if (token.fuzzy === true) {
        return token;
      }
      let shouldPack = token.choices.every((block2) => {
        if (block2.length !== 1) {
          return false;
        }
        let reg = block2[0];
        if (reg.fuzzy === true) {
          return false;
        }
        if (reg.start || reg.end) {
          return false;
        }
        if (reg.word !== void 0 && reg.negative !== true && reg.optional !== true && reg.method !== true) {
          return true;
        }
        return false;
      });
      if (shouldPack === true) {
        token.fastOr = /* @__PURE__ */ new Set();
        token.choices.forEach((block2) => {
          token.fastOr.add(block2[0].word);
        });
        delete token.choices;
      }
    }
    return token;
  });
};
var fuzzyOr = function(regs) {
  return regs.map((reg) => {
    if (reg.fuzzy && reg.choices) {
      reg.choices.forEach((r2) => {
        if (r2.length === 1 && r2[0].word) {
          r2[0].fuzzy = true;
          r2[0].min = reg.min;
        }
      });
    }
    return reg;
  });
};
var postProcess = function(regs) {
  regs = nameGroups(regs);
  regs = doFastOrMode(regs);
  regs = fuzzyOr(regs);
  return regs;
};
var postProcess_default = postProcess;

// node_modules/compromise/src/1-one/match/methods/parseMatch/index.js
var syntax = function(input, opts2, world2) {
  if (input === null || input === void 0 || input === "") {
    return [];
  }
  opts2 = opts2 || {};
  if (typeof input === "number") {
    input = String(input);
  }
  let tokens = parseBlocks_default(input);
  tokens = tokens.map((str) => parseToken_default(str, opts2));
  tokens = splitHyphens_default(tokens, world2);
  tokens = inflect_root_default(tokens, world2);
  tokens = postProcess_default(tokens, opts2);
  return tokens;
};
var parseMatch_default = syntax;

// node_modules/compromise/src/1-one/match/methods/match/01-failFast.js
var anyIntersection = function(setA, setB) {
  for (let elem of setB) {
    if (setA.has(elem)) {
      return true;
    }
  }
  return false;
};
var failFast = function(regs, cache2) {
  for (let i3 = 0; i3 < regs.length; i3 += 1) {
    let reg = regs[i3];
    if (reg.optional === true || reg.negative === true || reg.fuzzy === true) {
      continue;
    }
    if (reg.word !== void 0 && cache2.has(reg.word) === false) {
      return true;
    }
    if (reg.tag !== void 0 && cache2.has("#" + reg.tag) === false) {
      return true;
    }
    if (reg.fastOr && anyIntersection(reg.fastOr, cache2) === false) {
      return false;
    }
  }
  return false;
};
var failFast_default = failFast;

// node_modules/compromise/src/1-one/match/methods/match/term/_fuzzy.js
var editDistance = function(strA, strB) {
  let aLength = strA.length, bLength = strB.length;
  if (aLength === 0) {
    return bLength;
  }
  if (bLength === 0) {
    return aLength;
  }
  let limit = (bLength > aLength ? bLength : aLength) + 1;
  if (Math.abs(aLength - bLength) > (limit || 100)) {
    return limit || 100;
  }
  let matrix = [];
  for (let i3 = 0; i3 < limit; i3++) {
    matrix[i3] = [i3];
    matrix[i3].length = limit;
  }
  for (let i3 = 0; i3 < limit; i3++) {
    matrix[0][i3] = i3;
  }
  let j2, a_index, b_index, cost, min2, t3;
  for (let i3 = 1; i3 <= aLength; ++i3) {
    a_index = strA[i3 - 1];
    for (j2 = 1; j2 <= bLength; ++j2) {
      if (i3 === j2 && matrix[i3][j2] > 4) {
        return aLength;
      }
      b_index = strB[j2 - 1];
      cost = a_index === b_index ? 0 : 1;
      min2 = matrix[i3 - 1][j2] + 1;
      if ((t3 = matrix[i3][j2 - 1] + 1) < min2)
        min2 = t3;
      if ((t3 = matrix[i3 - 1][j2 - 1] + cost) < min2)
        min2 = t3;
      let shouldUpdate = i3 > 1 && j2 > 1 && a_index === strB[j2 - 2] && strA[i3 - 2] === b_index && (t3 = matrix[i3 - 2][j2 - 2] + cost) < min2;
      if (shouldUpdate) {
        matrix[i3][j2] = t3;
      } else {
        matrix[i3][j2] = min2;
      }
    }
  }
  return matrix[aLength][bLength];
};
var fuzzyMatch = function(strA, strB, minLength = 3) {
  if (strA === strB) {
    return 1;
  }
  if (strA.length < minLength || strB.length < minLength) {
    return 0;
  }
  const steps = editDistance(strA, strB);
  let length2 = Math.max(strA.length, strB.length);
  let relative2 = length2 === 0 ? 0 : steps / length2;
  let similarity = 1 - relative2;
  return similarity;
};
var fuzzy_default = fuzzyMatch;

// node_modules/compromise/src/1-one/match/methods/termMethods.js
var startQuote = /([\u0022\uFF02\u0027\u201C\u2018\u201F\u201B\u201E\u2E42\u201A\u00AB\u2039\u2035\u2036\u2037\u301D\u0060\u301F])/;
var endQuote = /([\u0022\uFF02\u0027\u201D\u2019\u00BB\u203A\u2032\u2033\u2034\u301E\u00B4])/;
var hasHyphen = /^[-]$/;
var hasDash2 = / [-]{1,3} /;
var hasPost = (term, punct) => term.post.indexOf(punct) !== -1;
var methods10 = {
  /** does it have a quotation symbol?  */
  hasQuote: (term) => startQuote.test(term.pre) || endQuote.test(term.post),
  /** does it have a comma?  */
  hasComma: (term) => hasPost(term, ","),
  /** does it end in a period? */
  hasPeriod: (term) => hasPost(term, ".") === true && hasPost(term, "...") === false,
  /** does it end in an exclamation */
  hasExclamation: (term) => hasPost(term, "!"),
  /** does it end with a question mark? */
  hasQuestionMark: (term) => hasPost(term, "?") || hasPost(term, "\xBF"),
  /** is there a ... at the end? */
  hasEllipses: (term) => hasPost(term, "..") || hasPost(term, "\u2026"),
  /** is there a semicolon after term word? */
  hasSemicolon: (term) => hasPost(term, ";"),
  /** is there a colon after term word? */
  hasColon: (term) => hasPost(term, ":"),
  /** is there a slash '/' in term word? */
  hasSlash: (term) => /\//.test(term.text),
  /** a hyphen connects two words like-term */
  hasHyphen: (term) => hasHyphen.test(term.post) || hasHyphen.test(term.pre),
  /** a dash separates words - like that */
  hasDash: (term) => hasDash2.test(term.post) || hasDash2.test(term.pre),
  /** is it multiple words combinded */
  hasContraction: (term) => Boolean(term.implicit),
  /** is it an acronym */
  isAcronym: (term) => term.tags.has("Acronym"),
  /** does it have any tags */
  isKnown: (term) => term.tags.size > 0,
  /** uppercase first letter, then a lowercase */
  isTitleCase: (term) => /^\p{Lu}[a-z'\u00C0-\u00FF]/u.test(term.text),
  /** uppercase all letters */
  isUpperCase: (term) => /^\p{Lu}+$/u.test(term.text)
};
methods10.hasQuotation = methods10.hasQuote;
var termMethods_default = methods10;

// node_modules/compromise/src/1-one/match/methods/match/term/doesMatch.js
var wrapMatch = function() {
};
var doesMatch = function(term, reg, index4, length2) {
  if (reg.anything === true) {
    return true;
  }
  if (reg.start === true && index4 !== 0) {
    return false;
  }
  if (reg.end === true && index4 !== length2 - 1) {
    return false;
  }
  if (reg.id !== void 0 && reg.id === term.id) {
    return true;
  }
  if (reg.word !== void 0) {
    if (reg.use) {
      return reg.word === term[reg.use];
    }
    if (term.machine !== null && term.machine === reg.word) {
      return true;
    }
    if (term.alias !== void 0 && term.alias.hasOwnProperty(reg.word)) {
      return true;
    }
    if (reg.fuzzy === true) {
      if (reg.word === term.root) {
        return true;
      }
      let score = fuzzy_default(reg.word, term.normal);
      if (score >= reg.min) {
        return true;
      }
    }
    if (term.alias && term.alias.some((str) => str === reg.word)) {
      return true;
    }
    return reg.word === term.text || reg.word === term.normal;
  }
  if (reg.tag !== void 0) {
    return term.tags.has(reg.tag) === true;
  }
  if (reg.method !== void 0) {
    if (typeof termMethods_default[reg.method] === "function" && termMethods_default[reg.method](term) === true) {
      return true;
    }
    return false;
  }
  if (reg.pre !== void 0) {
    return term.pre && term.pre.includes(reg.pre);
  }
  if (reg.post !== void 0) {
    return term.post && term.post.includes(reg.post);
  }
  if (reg.regex !== void 0) {
    let str = term.normal;
    if (reg.use) {
      str = term[reg.use];
    }
    return reg.regex.test(str);
  }
  if (reg.chunk !== void 0) {
    return term.chunk === reg.chunk;
  }
  if (reg.switch !== void 0) {
    return term.switch === reg.switch;
  }
  if (reg.machine !== void 0) {
    return term.normal === reg.machine || term.machine === reg.machine || term.root === reg.machine;
  }
  if (reg.sense !== void 0) {
    return term.sense === reg.sense;
  }
  if (reg.fastOr !== void 0) {
    if (reg.pos && !term.tags.has(reg.pos)) {
      return null;
    }
    let str = term.root || term.implicit || term.machine || term.normal;
    return reg.fastOr.has(str) || reg.fastOr.has(term.text);
  }
  if (reg.choices !== void 0) {
    if (reg.operator === "and") {
      return reg.choices.every((r2) => wrapMatch(term, r2, index4, length2));
    }
    return reg.choices.some((r2) => wrapMatch(term, r2, index4, length2));
  }
  return false;
};
wrapMatch = function(t3, reg, index4, length2) {
  let result = doesMatch(t3, reg, index4, length2);
  if (reg.negative === true) {
    return !result;
  }
  return result;
};
var doesMatch_default = wrapMatch;

// node_modules/compromise/src/1-one/match/methods/match/steps/logic/greedy.js
var getGreedy = function(state2, endReg) {
  let reg = Object.assign({}, state2.regs[state2.r], { start: false, end: false });
  let start2 = state2.t;
  for (; state2.t < state2.terms.length; state2.t += 1) {
    if (endReg && doesMatch_default(state2.terms[state2.t], endReg, state2.start_i + state2.t, state2.phrase_length)) {
      return state2.t;
    }
    let count = state2.t - start2 + 1;
    if (reg.max !== void 0 && count === reg.max) {
      return state2.t;
    }
    if (doesMatch_default(state2.terms[state2.t], reg, state2.start_i + state2.t, state2.phrase_length) === false) {
      if (reg.min !== void 0 && count < reg.min) {
        return null;
      }
      return state2.t;
    }
  }
  return state2.t;
};
var greedyTo = function(state2, nextReg) {
  let t3 = state2.t;
  if (!nextReg) {
    return state2.terms.length;
  }
  for (; t3 < state2.terms.length; t3 += 1) {
    if (doesMatch_default(state2.terms[t3], nextReg, state2.start_i + t3, state2.phrase_length) === true) {
      return t3;
    }
  }
  return null;
};
var isEndGreedy = function(reg, state2) {
  if (reg.end === true && reg.greedy === true) {
    if (state2.start_i + state2.t < state2.phrase_length - 1) {
      let tmpReg = Object.assign({}, reg, { end: false });
      if (doesMatch_default(state2.terms[state2.t], tmpReg, state2.start_i + state2.t, state2.phrase_length) === true) {
        return true;
      }
    }
  }
  return false;
};

// node_modules/compromise/src/1-one/match/methods/match/_lib.js
var getGroup = function(state2, term_index) {
  if (state2.groups[state2.inGroup]) {
    return state2.groups[state2.inGroup];
  }
  state2.groups[state2.inGroup] = {
    start: term_index,
    length: 0
  };
  return state2.groups[state2.inGroup];
};

// node_modules/compromise/src/1-one/match/methods/match/steps/astrix.js
var doAstrix = function(state2) {
  let { regs } = state2;
  let reg = regs[state2.r];
  let skipto = greedyTo(state2, regs[state2.r + 1]);
  if (skipto === null || skipto === 0) {
    return null;
  }
  if (reg.min !== void 0 && skipto - state2.t < reg.min) {
    return null;
  }
  if (reg.max !== void 0 && skipto - state2.t > reg.max) {
    state2.t = state2.t + reg.max;
    return true;
  }
  if (state2.hasGroup === true) {
    const g4 = getGroup(state2, state2.t);
    g4.length = skipto - state2.t;
  }
  state2.t = skipto;
  return true;
};
var astrix_default = doAstrix;

// node_modules/compromise/src/1-one/match/methods/match/steps/logic/and-or.js
var isArray6 = function(arr) {
  return Object.prototype.toString.call(arr) === "[object Array]";
};
var doOrBlock = function(state2, skipN = 0) {
  let block2 = state2.regs[state2.r];
  let wasFound = false;
  for (let c2 = 0; c2 < block2.choices.length; c2 += 1) {
    let regs = block2.choices[c2];
    if (!isArray6(regs)) {
      return false;
    }
    wasFound = regs.every((cr, w_index) => {
      let extra = 0;
      let t3 = state2.t + w_index + skipN + extra;
      if (state2.terms[t3] === void 0) {
        return false;
      }
      let foundBlock = doesMatch_default(state2.terms[t3], cr, t3 + state2.start_i, state2.phrase_length);
      if (foundBlock === true && cr.greedy === true) {
        for (let i3 = 1; i3 < state2.terms.length; i3 += 1) {
          let term = state2.terms[t3 + i3];
          if (term) {
            let keepGoing = doesMatch_default(term, cr, state2.start_i + i3, state2.phrase_length);
            if (keepGoing === true) {
              extra += 1;
            } else {
              break;
            }
          }
        }
      }
      skipN += extra;
      return foundBlock;
    });
    if (wasFound) {
      skipN += regs.length;
      break;
    }
  }
  if (wasFound && block2.greedy === true) {
    return doOrBlock(state2, skipN);
  }
  return skipN;
};
var doAndBlock = function(state2) {
  let longest = 0;
  let reg = state2.regs[state2.r];
  let allDidMatch = reg.choices.every((block2) => {
    let allWords = block2.every((cr, w_index) => {
      let tryTerm = state2.t + w_index;
      if (state2.terms[tryTerm] === void 0) {
        return false;
      }
      return doesMatch_default(state2.terms[tryTerm], cr, tryTerm, state2.phrase_length);
    });
    if (allWords === true && block2.length > longest) {
      longest = block2.length;
    }
    return allWords;
  });
  if (allDidMatch === true) {
    return longest;
  }
  return false;
};

// node_modules/compromise/src/1-one/match/methods/match/steps/or-block.js
var orBlock = function(state2) {
  const { regs } = state2;
  let reg = regs[state2.r];
  let skipNum = doOrBlock(state2);
  if (skipNum) {
    if (reg.negative === true) {
      return null;
    }
    if (state2.hasGroup === true) {
      const g4 = getGroup(state2, state2.t);
      g4.length += skipNum;
    }
    if (reg.end === true) {
      let end2 = state2.phrase_length;
      if (state2.t + state2.start_i + skipNum !== end2) {
        return null;
      }
    }
    state2.t += skipNum;
    return true;
  } else if (!reg.optional) {
    return null;
  }
  return true;
};
var or_block_default = orBlock;

// node_modules/compromise/src/1-one/match/methods/match/steps/and-block.js
var andBlock = function(state2) {
  const { regs } = state2;
  let reg = regs[state2.r];
  let skipNum = doAndBlock(state2);
  if (skipNum) {
    if (reg.negative === true) {
      return null;
    }
    if (state2.hasGroup === true) {
      const g4 = getGroup(state2, state2.t);
      g4.length += skipNum;
    }
    if (reg.end === true) {
      let end2 = state2.phrase_length - 1;
      if (state2.t + state2.start_i !== end2) {
        return null;
      }
    }
    state2.t += skipNum;
    return true;
  } else if (!reg.optional) {
    return null;
  }
  return true;
};
var and_block_default = andBlock;

// node_modules/compromise/src/1-one/match/methods/match/steps/logic/negative-greedy.js
var negGreedy = function(state2, reg, nextReg) {
  let skip = 0;
  for (let t3 = state2.t; t3 < state2.terms.length; t3 += 1) {
    let found = doesMatch_default(state2.terms[t3], reg, state2.start_i + state2.t, state2.phrase_length);
    if (found) {
      break;
    }
    if (nextReg) {
      found = doesMatch_default(state2.terms[t3], nextReg, state2.start_i + state2.t, state2.phrase_length);
      if (found) {
        break;
      }
    }
    skip += 1;
    if (reg.max !== void 0 && skip === reg.max) {
      break;
    }
  }
  if (skip === 0) {
    return false;
  }
  if (reg.min && reg.min > skip) {
    return false;
  }
  state2.t += skip;
  return true;
};
var negative_greedy_default = negGreedy;

// node_modules/compromise/src/1-one/match/methods/match/steps/negative.js
var doNegative = function(state2) {
  const { regs } = state2;
  let reg = regs[state2.r];
  let tmpReg = Object.assign({}, reg);
  tmpReg.negative = false;
  let found = doesMatch_default(state2.terms[state2.t], tmpReg, state2.start_i + state2.t, state2.phrase_length);
  if (found) {
    return false;
  }
  if (reg.optional) {
    let nextReg = regs[state2.r + 1];
    if (nextReg) {
      let fNext = doesMatch_default(state2.terms[state2.t], nextReg, state2.start_i + state2.t, state2.phrase_length);
      if (fNext) {
        state2.r += 1;
      } else if (nextReg.optional && regs[state2.r + 2]) {
        let fNext2 = doesMatch_default(state2.terms[state2.t], regs[state2.r + 2], state2.start_i + state2.t, state2.phrase_length);
        if (fNext2) {
          state2.r += 2;
        }
      }
    }
  }
  if (reg.greedy) {
    return negative_greedy_default(state2, tmpReg, regs[state2.r + 1]);
  }
  state2.t += 1;
  return true;
};
var negative_default = doNegative;

// node_modules/compromise/src/1-one/match/methods/match/steps/optional-match.js
var foundOptional = function(state2) {
  const { regs } = state2;
  let reg = regs[state2.r];
  let term = state2.terms[state2.t];
  let nextRegMatched = doesMatch_default(term, regs[state2.r + 1], state2.start_i + state2.t, state2.phrase_length);
  if (reg.negative || nextRegMatched) {
    let nextTerm = state2.terms[state2.t + 1];
    if (!nextTerm || !doesMatch_default(nextTerm, regs[state2.r + 1], state2.start_i + state2.t, state2.phrase_length)) {
      state2.r += 1;
    }
  }
};
var optional_match_default = foundOptional;

// node_modules/compromise/src/1-one/match/methods/match/steps/greedy-match.js
var greedyMatch = function(state2) {
  const { regs, phrase_length } = state2;
  let reg = regs[state2.r];
  state2.t = getGreedy(state2, regs[state2.r + 1]);
  if (state2.t === null) {
    return null;
  }
  if (reg.min && reg.min > state2.t) {
    return null;
  }
  if (reg.end === true && state2.start_i + state2.t !== phrase_length) {
    return null;
  }
  return true;
};
var greedy_match_default = greedyMatch;

// node_modules/compromise/src/1-one/match/methods/match/steps/contraction-skip.js
var contractionSkip = function(state2) {
  let term = state2.terms[state2.t];
  let reg = state2.regs[state2.r];
  if (term.implicit && state2.terms[state2.t + 1]) {
    let nextTerm = state2.terms[state2.t + 1];
    if (!nextTerm.implicit) {
      return;
    }
    if (reg.word === term.normal) {
      state2.t += 1;
    }
    if (reg.method === "hasContraction") {
      state2.t += 1;
    }
  }
};
var contraction_skip_default = contractionSkip;

// node_modules/compromise/src/1-one/match/methods/match/steps/simple-match.js
var setGroup = function(state2, startAt) {
  let reg = state2.regs[state2.r];
  const g4 = getGroup(state2, startAt);
  if (state2.t > 1 && reg.greedy) {
    g4.length += state2.t - startAt;
  } else {
    g4.length++;
  }
};
var simpleMatch = function(state2) {
  const { regs } = state2;
  let reg = regs[state2.r];
  let term = state2.terms[state2.t];
  let startAt = state2.t;
  if (reg.optional && regs[state2.r + 1] && reg.negative) {
    return true;
  }
  if (reg.optional && regs[state2.r + 1]) {
    optional_match_default(state2);
  }
  if (term.implicit && state2.terms[state2.t + 1]) {
    contraction_skip_default(state2);
  }
  state2.t += 1;
  if (reg.end === true && state2.t !== state2.terms.length && reg.greedy !== true) {
    return null;
  }
  if (reg.greedy === true) {
    let alive = greedy_match_default(state2);
    if (!alive) {
      return null;
    }
  }
  if (state2.hasGroup === true) {
    setGroup(state2, startAt);
  }
  return true;
};
var simple_match_default = simpleMatch;

// node_modules/compromise/src/1-one/match/methods/match/02-from-here.js
var tryHere = function(terms, regs, start_i, phrase_length) {
  if (terms.length === 0 || regs.length === 0) {
    return null;
  }
  let state2 = {
    t: 0,
    terms,
    r: 0,
    regs,
    groups: {},
    start_i,
    phrase_length,
    inGroup: null
  };
  for (; state2.r < regs.length; state2.r += 1) {
    let reg = regs[state2.r];
    state2.hasGroup = Boolean(reg.group);
    if (state2.hasGroup === true) {
      state2.inGroup = reg.group;
    } else {
      state2.inGroup = null;
    }
    if (!state2.terms[state2.t]) {
      const alive = regs.slice(state2.r).some((remain) => !remain.optional);
      if (alive === false) {
        break;
      }
      return null;
    }
    if (reg.anything === true && reg.greedy === true) {
      let alive = astrix_default(state2);
      if (!alive) {
        return null;
      }
      continue;
    }
    if (reg.choices !== void 0 && reg.operator === "or") {
      let alive = or_block_default(state2);
      if (!alive) {
        return null;
      }
      continue;
    }
    if (reg.choices !== void 0 && reg.operator === "and") {
      let alive = and_block_default(state2);
      if (!alive) {
        return null;
      }
      continue;
    }
    if (reg.anything === true) {
      if (reg.negative && reg.anything) {
        return null;
      }
      let alive = simple_match_default(state2);
      if (!alive) {
        return null;
      }
      continue;
    }
    if (isEndGreedy(reg, state2) === true) {
      let alive = simple_match_default(state2);
      if (!alive) {
        return null;
      }
      continue;
    }
    if (reg.negative) {
      let alive = negative_default(state2);
      if (!alive) {
        return null;
      }
      continue;
    }
    let hasMatch = doesMatch_default(state2.terms[state2.t], reg, state2.start_i + state2.t, state2.phrase_length);
    if (hasMatch === true) {
      let alive = simple_match_default(state2);
      if (!alive) {
        return null;
      }
      continue;
    }
    if (reg.optional === true) {
      continue;
    }
    return null;
  }
  let pntr = [null, start_i, state2.t + start_i];
  if (pntr[1] === pntr[2]) {
    return null;
  }
  let groups = {};
  Object.keys(state2.groups).forEach((k2) => {
    let o2 = state2.groups[k2];
    let start2 = start_i + o2.start;
    groups[k2] = [null, start2, start2 + o2.length];
  });
  return { pointer: pntr, groups };
};
var from_here_default = tryHere;

// node_modules/compromise/src/1-one/match/methods/match/03-getGroup.js
var getGroup2 = function(res, group) {
  let ptrs = [];
  let byGroup = {};
  if (res.length === 0) {
    return { ptrs, byGroup };
  }
  if (typeof group === "number") {
    group = String(group);
  }
  if (group) {
    res.forEach((r2) => {
      if (r2.groups[group]) {
        ptrs.push(r2.groups[group]);
      }
    });
  } else {
    res.forEach((r2) => {
      ptrs.push(r2.pointer);
      Object.keys(r2.groups).forEach((k2) => {
        byGroup[k2] = byGroup[k2] || [];
        byGroup[k2].push(r2.groups[k2]);
      });
    });
  }
  return { ptrs, byGroup };
};
var getGroup_default = getGroup2;

// node_modules/compromise/src/1-one/match/methods/match/03-notIf.js
var notIf = function(results, not, docs) {
  results = results.filter((res) => {
    let [n3, start2, end2] = res.pointer;
    let terms = docs[n3].slice(start2, end2);
    for (let i3 = 0; i3 < terms.length; i3 += 1) {
      let slice = terms.slice(i3);
      let found = from_here_default(slice, not, i3, terms.length);
      if (found !== null) {
        return false;
      }
    }
    return true;
  });
  return results;
};
var notIf_default = notIf;

// node_modules/compromise/src/1-one/match/methods/match/index.js
var addSentence = function(res, n3) {
  res.pointer[0] = n3;
  Object.keys(res.groups).forEach((k2) => {
    res.groups[k2][0] = n3;
  });
  return res;
};
var handleStart = function(terms, regs, n3) {
  let res = from_here_default(terms, regs, 0, terms.length);
  if (res) {
    res = addSentence(res, n3);
    return res;
  }
  return null;
};
var runMatch = function(docs, todo, cache2) {
  cache2 = cache2 || [];
  let { regs, group, justOne } = todo;
  let results = [];
  if (!regs || regs.length === 0) {
    return { ptrs: [], byGroup: {} };
  }
  const minLength = regs.filter((r2) => r2.optional !== true && r2.negative !== true).length;
  docs:
    for (let n3 = 0; n3 < docs.length; n3 += 1) {
      let terms = docs[n3];
      if (cache2[n3] && failFast_default(regs, cache2[n3])) {
        continue;
      }
      if (regs[0].start === true) {
        let foundStart = handleStart(terms, regs, n3, group);
        if (foundStart) {
          results.push(foundStart);
        }
        continue;
      }
      for (let i3 = 0; i3 < terms.length; i3 += 1) {
        let slice = terms.slice(i3);
        if (slice.length < minLength) {
          break;
        }
        let res = from_here_default(slice, regs, i3, terms.length);
        if (res) {
          res = addSentence(res, n3);
          results.push(res);
          if (justOne === true) {
            break docs;
          }
          let end2 = res.pointer[2];
          if (Math.abs(end2 - 1) > i3) {
            i3 = Math.abs(end2 - 1);
          }
        }
      }
    }
  if (regs[regs.length - 1].end === true) {
    results = results.filter((res) => {
      let n3 = res.pointer[0];
      return docs[n3].length === res.pointer[2];
    });
  }
  if (todo.notIf) {
    results = notIf_default(results, todo.notIf, docs);
  }
  results = getGroup_default(results, group);
  results.ptrs.forEach((ptr) => {
    let [n3, start2, end2] = ptr;
    ptr[3] = docs[n3][start2].id;
    ptr[4] = docs[n3][end2 - 1].id;
  });
  return results;
};
var match_default2 = runMatch;

// node_modules/compromise/src/1-one/match/methods/index.js
var methods11 = {
  one: {
    termMethods: termMethods_default,
    parseMatch: parseMatch_default,
    match: match_default2
  }
};
var methods_default4 = methods11;

// node_modules/compromise/src/1-one/match/lib.js
var lib_default2 = {
  /** pre-parse any match statements */
  parseMatch: function(str, opts2) {
    const world2 = this.world();
    let killUnicode2 = world2.methods.one.killUnicode;
    if (killUnicode2) {
      str = killUnicode2(str, world2);
    }
    return world2.methods.one.parseMatch(str, opts2, world2);
  }
};

// node_modules/compromise/src/1-one/match/plugin.js
var plugin_default7 = {
  api: api_default4,
  methods: methods_default4,
  lib: lib_default2
};

// node_modules/compromise/src/1-one/output/api/html.js
var isClass = /^\../;
var isId = /^#./;
var escapeXml = (str) => {
  str = str.replace(/&/g, "&amp;");
  str = str.replace(/</g, "&lt;");
  str = str.replace(/>/g, "&gt;");
  str = str.replace(/"/g, "&quot;");
  str = str.replace(/'/g, "&apos;");
  return str;
};
var toTag = function(k2) {
  let start2 = "";
  let end2 = "</span>";
  k2 = escapeXml(k2);
  if (isClass.test(k2)) {
    start2 = `<span class="${k2.replace(/^\./, "")}"`;
  } else if (isId.test(k2)) {
    start2 = `<span id="${k2.replace(/^#/, "")}"`;
  } else {
    start2 = `<${k2}`;
    end2 = `</${k2}>`;
  }
  start2 += ">";
  return { start: start2, end: end2 };
};
var getIndex = function(doc, obj) {
  let starts = {};
  let ends = {};
  Object.keys(obj).forEach((k2) => {
    let res = obj[k2];
    let tag2 = toTag(k2);
    if (typeof res === "string") {
      res = doc.match(res);
    }
    res.docs.forEach((terms) => {
      if (terms.every((t3) => t3.implicit)) {
        return;
      }
      let a2 = terms[0].id;
      starts[a2] = starts[a2] || [];
      starts[a2].push(tag2.start);
      let b = terms[terms.length - 1].id;
      ends[b] = ends[b] || [];
      ends[b].push(tag2.end);
    });
  });
  return { starts, ends };
};
var html2 = function(obj) {
  let { starts, ends } = getIndex(this, obj);
  let out2 = "";
  this.docs.forEach((terms) => {
    for (let i3 = 0; i3 < terms.length; i3 += 1) {
      let t3 = terms[i3];
      if (starts.hasOwnProperty(t3.id)) {
        out2 += starts[t3.id].join("");
      }
      out2 += t3.pre || "";
      out2 += t3.text || "";
      if (ends.hasOwnProperty(t3.id)) {
        out2 += ends[t3.id].join("");
      }
      out2 += t3.post || "";
    }
  });
  return out2;
};
var html_default = { html: html2 };

// node_modules/compromise/src/1-one/output/api/_text.js
var trimEnd = /[,:;)\]*.?~!\u0022\uFF02\u201D\u2019\u00BB\u203A\u2032\u2033\u2034\u301E\u00B4-]+$/;
var trimStart = /^[(['"*~\uFF02\u201C\u2018\u201F\u201B\u201E\u2E42\u201A\u00AB\u2039\u2035\u2036\u2037\u301D\u0060\u301F]+/;
var punctToKill = /[,:;)('"\u201D\]]/;
var isHyphen = /^[-]$/;
var hasSpace = / /;
var textFromTerms = function(terms, opts2, keepSpace = true) {
  let txt = "";
  terms.forEach((t3) => {
    let pre = t3.pre || "";
    let post = t3.post || "";
    if (opts2.punctuation === "some") {
      pre = pre.replace(trimStart, "");
      if (isHyphen.test(post)) {
        post = " ";
      }
      post = post.replace(punctToKill, "");
      post = post.replace(/\?!+/, "?");
      post = post.replace(/!+/, "!");
      post = post.replace(/\?+/, "?");
      post = post.replace(/\.{2,}/, "");
      if (t3.tags.has("Abbreviation")) {
        post = post.replace(/\./, "");
      }
    }
    if (opts2.whitespace === "some") {
      pre = pre.replace(/\s/, "");
      post = post.replace(/\s+/, " ");
    }
    if (!opts2.keepPunct) {
      pre = pre.replace(trimStart, "");
      if (post === "-") {
        post = " ";
      } else {
        post = post.replace(trimEnd, "");
      }
    }
    let word = t3[opts2.form || "text"] || t3.normal || "";
    if (opts2.form === "implicit") {
      word = t3.implicit || t3.text;
    }
    if (opts2.form === "root" && t3.implicit) {
      word = t3.root || t3.implicit || t3.normal;
    }
    if ((opts2.form === "machine" || opts2.form === "implicit" || opts2.form === "root") && t3.implicit) {
      if (!post || !hasSpace.test(post)) {
        post += " ";
      }
    }
    txt += pre + word + post;
  });
  if (keepSpace === false) {
    txt = txt.trim();
  }
  if (opts2.lowerCase === true) {
    txt = txt.toLowerCase();
  }
  return txt;
};
var textFromDoc = function(docs, opts2) {
  let text2 = "";
  if (!docs || !docs[0] || !docs[0][0]) {
    return text2;
  }
  for (let i3 = 0; i3 < docs.length; i3 += 1) {
    text2 += textFromTerms(docs[i3], opts2, true);
  }
  if (!opts2.keepSpace) {
    text2 = text2.trim();
  }
  if (opts2.keepEndPunct === false) {
    if (!docs[0][0].tags.has("Emoticon")) {
      text2 = text2.replace(trimStart, "");
    }
    let last = docs[docs.length - 1];
    if (!last[last.length - 1].tags.has("Emoticon")) {
      text2 = text2.replace(trimEnd, "");
    }
    if (text2.endsWith(`'`) && !text2.endsWith(`s'`)) {
      text2 = text2.replace(/'/, "");
    }
  }
  if (opts2.cleanWhitespace === true) {
    text2 = text2.trim();
  }
  return text2;
};

// node_modules/compromise/src/1-one/output/api/_fmts.js
var fmts = {
  text: {
    form: "text"
  },
  normal: {
    whitespace: "some",
    punctuation: "some",
    case: "some",
    unicode: "some",
    form: "normal"
  },
  machine: {
    keepSpace: false,
    whitespace: "some",
    punctuation: "some",
    case: "none",
    unicode: "some",
    form: "machine"
  },
  root: {
    keepSpace: false,
    whitespace: "some",
    punctuation: "some",
    case: "some",
    unicode: "some",
    form: "root"
  },
  implicit: {
    form: "implicit"
  }
};
fmts.clean = fmts.normal;
fmts.reduced = fmts.root;
var fmts_default = fmts;

// node_modules/compromise/src/1-one/output/methods/hash.js
var k = [];
var i = 0;
for (; i < 64; ) {
  k[i] = 0 | Math.sin(++i % Math.PI) * 4294967296;
}
var md5 = function(s3) {
  let b, c2, d2, h2 = [b = 1732584193, c2 = 4023233417, ~b, ~c2], words = [], j2 = decodeURI(encodeURI(s3)) + "\x80", a2 = j2.length;
  s3 = --a2 / 4 + 2 | 15;
  words[--s3] = a2 * 8;
  for (; ~a2; ) {
    words[a2 >> 2] |= j2.charCodeAt(a2) << 8 * a2--;
  }
  for (i = j2 = 0; i < s3; i += 16) {
    a2 = h2;
    for (; j2 < 64; a2 = [
      d2 = a2[3],
      b + ((d2 = a2[0] + [b & c2 | ~b & d2, d2 & b | ~d2 & c2, b ^ c2 ^ d2, c2 ^ (b | ~d2)][a2 = j2 >> 4] + k[j2] + ~~words[i | [j2, 5 * j2 + 1, 3 * j2 + 5, 7 * j2][a2] & 15]) << (a2 = [7, 12, 17, 22, 5, 9, 14, 20, 4, 11, 16, 23, 6, 10, 15, 21][4 * a2 + j2++ % 4]) | d2 >>> -a2),
      b,
      c2
    ]) {
      b = a2[1] | 0;
      c2 = a2[2];
    }
    for (j2 = 4; j2; )
      h2[--j2] += a2[j2];
  }
  for (s3 = ""; j2 < 32; ) {
    s3 += (h2[j2 >> 3] >> (1 ^ j2++) * 4 & 15).toString(16);
  }
  return s3;
};
var hash_default = md5;

// node_modules/compromise/src/1-one/output/api/json.js
var defaults = {
  text: true,
  terms: true
};
var opts = { case: "none", unicode: "some", form: "machine", punctuation: "some" };
var merge = function(a2, b) {
  return Object.assign({}, a2, b);
};
var fns4 = {
  text: (terms) => textFromTerms(terms, { keepPunct: true }, false),
  normal: (terms) => textFromTerms(terms, merge(fmts_default.normal, { keepPunct: true }), false),
  implicit: (terms) => textFromTerms(terms, merge(fmts_default.implicit, { keepPunct: true }), false),
  machine: (terms) => textFromTerms(terms, opts, false),
  root: (terms) => textFromTerms(terms, merge(opts, { form: "root" }), false),
  hash: (terms) => hash_default(textFromTerms(terms, { keepPunct: true }, false)),
  offset: (terms) => {
    let len = fns4.text(terms).length;
    return {
      index: terms[0].offset.index,
      start: terms[0].offset.start,
      length: len
    };
  },
  terms: (terms) => {
    return terms.map((t3) => {
      let term = Object.assign({}, t3);
      term.tags = Array.from(t3.tags);
      return term;
    });
  },
  confidence: (_terms, view, i3) => view.eq(i3).confidence(),
  syllables: (_terms, view, i3) => view.eq(i3).syllables(),
  sentence: (_terms, view, i3) => view.eq(i3).fullSentence().text(),
  dirty: (terms) => terms.some((t3) => t3.dirty === true)
};
fns4.sentences = fns4.sentence;
fns4.clean = fns4.normal;
fns4.reduced = fns4.root;
var toJSON = function(view, option) {
  option = option || {};
  if (typeof option === "string") {
    option = {};
  }
  option = Object.assign({}, defaults, option);
  if (option.offset) {
    view.compute("offset");
  }
  return view.docs.map((terms, i3) => {
    let res = {};
    Object.keys(option).forEach((k2) => {
      if (option[k2] && fns4[k2]) {
        res[k2] = fns4[k2](terms, view, i3);
      }
    });
    return res;
  });
};
var methods12 = {
  /** return data */
  json: function(n3) {
    let res = toJSON(this, n3);
    if (typeof n3 === "number") {
      return res[n3];
    }
    return res;
  }
};
methods12.data = methods12.json;
var json_default = methods12;

// node_modules/compromise/src/1-one/output/api/debug.js
var isClientSide = () => typeof window !== "undefined" && window.document;
var debug2 = function(fmt2) {
  let debugMethods = this.methods.one.debug || {};
  if (fmt2 && debugMethods.hasOwnProperty(fmt2)) {
    debugMethods[fmt2](this);
    return this;
  }
  if (isClientSide()) {
    debugMethods.clientSide(this);
    return this;
  }
  debugMethods.tags(this);
  return this;
};
var debug_default2 = debug2;

// node_modules/compromise/src/1-one/output/api/wrap.js
var toText = function(term) {
  let pre = term.pre || "";
  let post = term.post || "";
  return pre + term.text + post;
};
var findStarts = function(doc, obj) {
  let starts = {};
  Object.keys(obj).forEach((reg) => {
    let m3 = doc.match(reg);
    m3.fullPointer.forEach((a2) => {
      starts[a2[3]] = { fn: obj[reg], end: a2[2] };
    });
  });
  return starts;
};
var wrap = function(doc, obj) {
  let starts = findStarts(doc, obj);
  let text2 = "";
  doc.docs.forEach((terms, n3) => {
    for (let i3 = 0; i3 < terms.length; i3 += 1) {
      let t3 = terms[i3];
      if (starts.hasOwnProperty(t3.id)) {
        let { fn, end: end2 } = starts[t3.id];
        let m3 = doc.update([[n3, i3, end2]]);
        text2 += terms[i3].pre || "";
        text2 += fn(m3);
        i3 = end2 - 1;
        text2 += terms[i3].post || "";
      } else {
        text2 += toText(t3);
      }
    }
  });
  return text2;
};
var wrap_default = wrap;

// node_modules/compromise/src/1-one/output/api/out.js
var isObject5 = (val) => {
  return Object.prototype.toString.call(val) === "[object Object]";
};
var topk = function(arr) {
  let obj = {};
  arr.forEach((a2) => {
    obj[a2] = obj[a2] || 0;
    obj[a2] += 1;
  });
  let res = Object.keys(obj).map((k2) => {
    return { normal: k2, count: obj[k2] };
  });
  return res.sort((a2, b) => a2.count > b.count ? -1 : 0);
};
var out = function(method) {
  if (isObject5(method)) {
    return wrap_default(this, method);
  }
  if (method === "text") {
    return this.text();
  }
  if (method === "normal") {
    return this.text("normal");
  }
  if (method === "root") {
    return this.text("root");
  }
  if (method === "machine" || method === "reduced") {
    return this.text("machine");
  }
  if (method === "hash" || method === "md5") {
    return hash_default(this.text());
  }
  if (method === "json") {
    return this.json();
  }
  if (method === "offset" || method === "offsets") {
    this.compute("offset");
    return this.json({ offset: true });
  }
  if (method === "array") {
    let arr = this.docs.map((terms) => {
      return terms.reduce((str, t3) => {
        return str + t3.pre + t3.text + t3.post;
      }, "").trim();
    });
    return arr.filter((str) => str);
  }
  if (method === "freq" || method === "frequency" || method === "topk") {
    return topk(this.json({ normal: true }).map((o2) => o2.normal));
  }
  if (method === "terms") {
    let list4 = [];
    this.docs.forEach((terms) => {
      let words = terms.map((t3) => t3.text);
      words = words.filter((t3) => t3);
      list4 = list4.concat(words);
    });
    return list4;
  }
  if (method === "tags") {
    return this.docs.map((terms) => {
      return terms.reduce((h2, t3) => {
        h2[t3.implicit || t3.normal] = Array.from(t3.tags);
        return h2;
      }, {});
    });
  }
  if (method === "debug") {
    return this.debug();
  }
  return this.text();
};
var methods13 = {
  /** */
  debug: debug_default2,
  /** */
  out,
  /** */
  wrap: function(obj) {
    return wrap_default(this, obj);
  }
};
var out_default = methods13;

// node_modules/compromise/src/1-one/output/api/text.js
var isObject6 = (val) => {
  return Object.prototype.toString.call(val) === "[object Object]";
};
var text_default = {
  /** */
  text: function(fmt2) {
    let opts2 = {};
    if (fmt2 && typeof fmt2 === "string" && fmts_default.hasOwnProperty(fmt2)) {
      opts2 = Object.assign({}, fmts_default[fmt2]);
    } else if (fmt2 && isObject6(fmt2)) {
      opts2 = Object.assign({}, fmt2);
    }
    if (opts2.keepSpace === void 0 && !this.isFull()) {
      opts2.keepSpace = false;
    }
    if (opts2.keepEndPunct === void 0 && this.pointer) {
      let ptr = this.pointer[0];
      if (ptr && ptr[1]) {
        opts2.keepEndPunct = false;
      } else {
        opts2.keepEndPunct = true;
      }
    }
    if (opts2.keepPunct === void 0) {
      opts2.keepPunct = true;
    }
    if (opts2.keepSpace === void 0) {
      opts2.keepSpace = true;
    }
    return textFromDoc(this.docs, opts2);
  }
};

// node_modules/compromise/src/1-one/output/api/index.js
var methods14 = Object.assign({}, out_default, text_default, json_default, html_default);
var addAPI3 = function(View2) {
  Object.assign(View2.prototype, methods14);
};
var api_default5 = addAPI3;

// node_modules/compromise/src/1-one/output/methods/debug/client-side.js
var logClientSide = function(view) {
  console.log("%c -=-=- ", "background-color:#6699cc;");
  view.forEach((m3) => {
    console.groupCollapsed(m3.text());
    let terms = m3.docs[0];
    let out2 = terms.map((t3) => {
      let text2 = t3.text || "-";
      if (t3.implicit) {
        text2 = "[" + t3.implicit + "]";
      }
      let tags = "[" + Array.from(t3.tags).join(", ") + "]";
      return { text: text2, tags };
    });
    console.table(out2, ["text", "tags"]);
    console.groupEnd();
  });
};
var client_side_default = logClientSide;

// node_modules/compromise/src/1-one/output/methods/debug/_color.js
var reset2 = "\x1B[0m";
var cli = {
  green: (str) => "\x1B[32m" + str + reset2,
  red: (str) => "\x1B[31m" + str + reset2,
  blue: (str) => "\x1B[34m" + str + reset2,
  magenta: (str) => "\x1B[35m" + str + reset2,
  cyan: (str) => "\x1B[36m" + str + reset2,
  yellow: (str) => "\x1B[33m" + str + reset2,
  black: (str) => "\x1B[30m" + str + reset2,
  dim: (str) => "\x1B[2m" + str + reset2,
  i: (str) => "\x1B[3m" + str + reset2
};
var color_default = cli;

// node_modules/compromise/src/1-one/output/methods/debug/tags.js
var tagString = function(tags, model5) {
  if (model5.one.tagSet) {
    tags = tags.map((tag2) => {
      if (!model5.one.tagSet.hasOwnProperty(tag2)) {
        return tag2;
      }
      const c2 = model5.one.tagSet[tag2].color || "blue";
      return color_default[c2](tag2);
    });
  }
  return tags.join(", ");
};
var showTags = function(view) {
  let { docs, model: model5 } = view;
  if (docs.length === 0) {
    console.log(color_default.blue("\n     \u2500\u2500\u2500\u2500\u2500\u2500"));
  }
  docs.forEach((terms) => {
    console.log(color_default.blue("\n  \u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500"));
    terms.forEach((t3) => {
      let tags = [...t3.tags || []];
      let text2 = t3.text || "-";
      if (t3.sense) {
        text2 = `{${t3.normal}/${t3.sense}}`;
      }
      if (t3.implicit) {
        text2 = "[" + t3.implicit + "]";
      }
      text2 = color_default.yellow(text2);
      let word = "'" + text2 + "'";
      if (t3.reference) {
        let str2 = view.update([t3.reference]).text("normal");
        word += ` - ${color_default.dim(color_default.i("[" + str2 + "]"))}`;
      }
      word = word.padEnd(18);
      let str = color_default.blue("  \u2502 ") + color_default.i(word) + "  - " + tagString(tags, model5);
      console.log(str);
    });
  });
  console.log("\n");
};
var tags_default = showTags;

// node_modules/compromise/src/1-one/output/methods/debug/chunks.js
var showChunks = function(view) {
  let { docs } = view;
  console.log("");
  docs.forEach((terms) => {
    let out2 = [];
    terms.forEach((term) => {
      if (term.chunk === "Noun") {
        out2.push(color_default.blue(term.implicit || term.normal));
      } else if (term.chunk === "Verb") {
        out2.push(color_default.green(term.implicit || term.normal));
      } else if (term.chunk === "Adjective") {
        out2.push(color_default.yellow(term.implicit || term.normal));
      } else if (term.chunk === "Pivot") {
        out2.push(color_default.red(term.implicit || term.normal));
      } else {
        out2.push(term.implicit || term.normal);
      }
    });
    console.log(out2.join(" "), "\n");
  });
  console.log("\n");
};
var chunks_default = showChunks;

// node_modules/compromise/src/1-one/output/methods/debug/highlight.js
var split = (txt, offset2, index4) => {
  let buff = index4 * 9;
  let start2 = offset2.start + buff;
  let end2 = start2 + offset2.length;
  let pre = txt.substring(0, start2);
  let mid = txt.substring(start2, end2);
  let post = txt.substring(end2, txt.length);
  return [pre, mid, post];
};
var spliceIn = function(txt, offset2, index4) {
  let parts = split(txt, offset2, index4);
  return `${parts[0]}${color_default.blue(parts[1])}${parts[2]}`;
};
var showHighlight = function(doc) {
  if (!doc.found) {
    return;
  }
  let bySentence = {};
  doc.fullPointer.forEach((ptr) => {
    bySentence[ptr[0]] = bySentence[ptr[0]] || [];
    bySentence[ptr[0]].push(ptr);
  });
  Object.keys(bySentence).forEach((k2) => {
    let full = doc.update([[Number(k2)]]);
    let txt = full.text();
    let matches3 = doc.update(bySentence[k2]);
    let json = matches3.json({ offset: true });
    json.forEach((obj, i3) => {
      txt = spliceIn(txt, obj.offset, i3);
    });
    console.log(txt);
  });
  console.log("\n");
};
var highlight_default = showHighlight;

// node_modules/compromise/src/1-one/output/methods/debug/index.js
var debug3 = {
  tags: tags_default,
  clientSide: client_side_default,
  chunks: chunks_default,
  highlight: highlight_default
};
var debug_default3 = debug3;

// node_modules/compromise/src/1-one/output/plugin.js
var plugin_default8 = {
  api: api_default5,
  methods: {
    one: {
      hash: hash_default,
      debug: debug_default3
    }
  }
};

// node_modules/compromise/src/1-one/pointers/api/lib/_lib.js
var doesOverlap = function(a2, b) {
  if (a2[0] !== b[0]) {
    return false;
  }
  let [, startA, endA] = a2;
  let [, startB, endB] = b;
  if (startA <= startB && endA > startB) {
    return true;
  }
  if (startB <= startA && endB > startA) {
    return true;
  }
  return false;
};
var getExtent = function(ptrs) {
  let min2 = ptrs[0][1];
  let max3 = ptrs[0][2];
  ptrs.forEach((ptr) => {
    if (ptr[1] < min2) {
      min2 = ptr[1];
    }
    if (ptr[2] > max3) {
      max3 = ptr[2];
    }
  });
  return [ptrs[0][0], min2, max3];
};
var indexN = function(ptrs) {
  let byN = {};
  ptrs.forEach((ref) => {
    byN[ref[0]] = byN[ref[0]] || [];
    byN[ref[0]].push(ref);
  });
  return byN;
};
var uniquePtrs = function(arr) {
  let obj = {};
  for (let i3 = 0; i3 < arr.length; i3 += 1) {
    obj[arr[i3].join(",")] = arr[i3];
  }
  return Object.values(obj);
};

// node_modules/compromise/src/1-one/pointers/api/lib/split.js
var pivotBy = function(full, m3) {
  let [n3, start2] = full;
  let mStart = m3[1];
  let mEnd = m3[2];
  let res = {};
  if (start2 < mStart) {
    let end2 = mStart < full[2] ? mStart : full[2];
    res.before = [n3, start2, end2];
  }
  res.match = m3;
  if (full[2] > mEnd) {
    res.after = [n3, mEnd, full[2]];
  }
  return res;
};
var doesMatch2 = function(full, m3) {
  return full[1] <= m3[1] && m3[2] <= full[2];
};
var splitAll = function(full, m3) {
  let byN = indexN(m3);
  let res = [];
  full.forEach((ptr) => {
    let [n3] = ptr;
    let matches3 = byN[n3] || [];
    matches3 = matches3.filter((p5) => doesMatch2(ptr, p5));
    if (matches3.length === 0) {
      res.push({ passthrough: ptr });
      return;
    }
    matches3 = matches3.sort((a2, b) => a2[1] - b[1]);
    let carry = ptr;
    matches3.forEach((p5, i3) => {
      let found = pivotBy(carry, p5);
      if (!matches3[i3 + 1]) {
        res.push(found);
      } else {
        res.push({ before: found.before, match: found.match });
        if (found.after) {
          carry = found.after;
        }
      }
    });
  });
  return res;
};
var split_default2 = splitAll;

// node_modules/compromise/src/1-one/pointers/methods/getDoc.js
var max = 20;
var blindSweep = function(id, doc, n3) {
  for (let i3 = 0; i3 < max; i3 += 1) {
    if (doc[n3 - i3]) {
      let index4 = doc[n3 - i3].findIndex((term) => term.id === id);
      if (index4 !== -1) {
        return [n3 - i3, index4];
      }
    }
    if (doc[n3 + i3]) {
      let index4 = doc[n3 + i3].findIndex((term) => term.id === id);
      if (index4 !== -1) {
        return [n3 + i3, index4];
      }
    }
  }
  return null;
};
var repairEnding = function(ptr, document2) {
  let [n3, start2, , , endId] = ptr;
  let terms = document2[n3];
  let newEnd = terms.findIndex((t3) => t3.id === endId);
  if (newEnd === -1) {
    ptr[2] = document2[n3].length;
    ptr[4] = terms.length ? terms[terms.length - 1].id : null;
  } else {
    ptr[2] = newEnd;
  }
  return document2[n3].slice(start2, ptr[2] + 1);
};
var getDoc2 = function(ptrs, document2) {
  let doc = [];
  ptrs.forEach((ptr, i3) => {
    if (!ptr) {
      return;
    }
    let [n3, start2, end2, id, endId] = ptr;
    let terms = document2[n3] || [];
    if (start2 === void 0) {
      start2 = 0;
    }
    if (end2 === void 0) {
      end2 = terms.length;
    }
    if (id && (!terms[start2] || terms[start2].id !== id)) {
      let wild = blindSweep(id, document2, n3);
      if (wild !== null) {
        let len = end2 - start2;
        terms = document2[wild[0]].slice(wild[1], wild[1] + len);
        let startId = terms[0] ? terms[0].id : null;
        ptrs[i3] = [wild[0], wild[1], wild[1] + len, startId];
      }
    } else {
      terms = terms.slice(start2, end2);
    }
    if (terms.length === 0) {
      return;
    }
    if (start2 === end2) {
      return;
    }
    if (endId && terms[terms.length - 1].id !== endId) {
      terms = repairEnding(ptr, document2);
    }
    doc.push(terms);
  });
  doc = doc.filter((a2) => a2.length > 0);
  return doc;
};
var getDoc_default = getDoc2;

// node_modules/compromise/src/1-one/pointers/methods/index.js
var termList = function(docs) {
  let arr = [];
  for (let i3 = 0; i3 < docs.length; i3 += 1) {
    for (let t3 = 0; t3 < docs[i3].length; t3 += 1) {
      arr.push(docs[i3][t3]);
    }
  }
  return arr;
};
var methods_default5 = {
  one: {
    termList,
    getDoc: getDoc_default,
    pointer: {
      indexN,
      splitAll: split_default2
    }
  }
};

// node_modules/compromise/src/1-one/pointers/api/lib/union.js
var getUnion = function(a2, b) {
  let both = a2.concat(b);
  let byN = indexN(both);
  let res = [];
  both.forEach((ptr) => {
    let [n3] = ptr;
    if (byN[n3].length === 1) {
      res.push(ptr);
      return;
    }
    let hmm = byN[n3].filter((m3) => doesOverlap(ptr, m3));
    hmm.push(ptr);
    let range = getExtent(hmm);
    res.push(range);
  });
  res = uniquePtrs(res);
  return res;
};
var union_default = getUnion;

// node_modules/compromise/src/1-one/pointers/api/lib/difference.js
var subtract = function(refs, not) {
  let res = [];
  let found = split_default2(refs, not);
  found.forEach((o2) => {
    if (o2.passthrough) {
      res.push(o2.passthrough);
    }
    if (o2.before) {
      res.push(o2.before);
    }
    if (o2.after) {
      res.push(o2.after);
    }
  });
  return res;
};
var difference_default = subtract;

// node_modules/compromise/src/1-one/pointers/api/lib/intersection.js
var intersection = function(a2, b) {
  let start2 = a2[1] < b[1] ? b[1] : a2[1];
  let end2 = a2[2] > b[2] ? b[2] : a2[2];
  if (start2 < end2) {
    return [a2[0], start2, end2];
  }
  return null;
};
var getIntersection = function(a2, b) {
  let byN = indexN(b);
  let res = [];
  a2.forEach((ptr) => {
    let hmm = byN[ptr[0]] || [];
    hmm = hmm.filter((p5) => doesOverlap(ptr, p5));
    if (hmm.length === 0) {
      return;
    }
    hmm.forEach((h2) => {
      let overlap = intersection(ptr, h2);
      if (overlap) {
        res.push(overlap);
      }
    });
  });
  return res;
};
var intersection_default = getIntersection;

// node_modules/compromise/src/1-one/pointers/api/index.js
var isArray7 = function(arr) {
  return Object.prototype.toString.call(arr) === "[object Array]";
};
var getDoc3 = (m3, view) => {
  if (typeof m3 === "string" || isArray7(m3)) {
    return view.match(m3);
  }
  if (!m3) {
    return view.none();
  }
  return m3;
};
var addIds3 = function(ptrs, docs) {
  return ptrs.map((ptr) => {
    let [n3, start2] = ptr;
    if (docs[n3] && docs[n3][start2]) {
      ptr[3] = docs[n3][start2].id;
    }
    return ptr;
  });
};
var methods15 = {};
methods15.union = function(m3) {
  m3 = getDoc3(m3, this);
  let ptrs = union_default(this.fullPointer, m3.fullPointer);
  ptrs = addIds3(ptrs, this.document);
  return this.toView(ptrs);
};
methods15.and = methods15.union;
methods15.intersection = function(m3) {
  m3 = getDoc3(m3, this);
  let ptrs = intersection_default(this.fullPointer, m3.fullPointer);
  ptrs = addIds3(ptrs, this.document);
  return this.toView(ptrs);
};
methods15.not = function(m3) {
  m3 = getDoc3(m3, this);
  let ptrs = difference_default(this.fullPointer, m3.fullPointer);
  ptrs = addIds3(ptrs, this.document);
  return this.toView(ptrs);
};
methods15.difference = methods15.not;
methods15.complement = function() {
  let doc = this.all();
  let ptrs = difference_default(doc.fullPointer, this.fullPointer);
  ptrs = addIds3(ptrs, this.document);
  return this.toView(ptrs);
};
methods15.settle = function() {
  let ptrs = this.fullPointer;
  ptrs.forEach((ptr) => {
    ptrs = union_default(ptrs, [ptr]);
  });
  ptrs = addIds3(ptrs, this.document);
  return this.update(ptrs);
};
var addAPI4 = function(View2) {
  Object.assign(View2.prototype, methods15);
};
var api_default6 = addAPI4;

// node_modules/compromise/src/1-one/pointers/plugin.js
var plugin_default9 = {
  methods: methods_default5,
  api: api_default6
};

// node_modules/compromise/src/1-one/sweep/lib.js
var lib_default3 = {
  // compile a list of matches into a match-net
  buildNet: function(matches3) {
    const methods17 = this.methods();
    let net3 = methods17.one.buildNet(matches3, this.world());
    net3.isNet = true;
    return net3;
  }
};

// node_modules/compromise/src/1-one/sweep/api.js
var api = function(View2) {
  View2.prototype.sweep = function(net3, opts2 = {}) {
    const { world: world2, docs } = this;
    const { methods: methods17 } = world2;
    let found = methods17.one.bulkMatch(docs, net3, this.methods, opts2);
    if (opts2.tagger !== false) {
      methods17.one.bulkTagger(found, docs, this.world);
    }
    found = found.map((o2) => {
      let ptr = o2.pointer;
      let term = docs[ptr[0]][ptr[1]];
      let len = ptr[2] - ptr[1];
      if (term.index) {
        o2.pointer = [
          term.index[0],
          term.index[1],
          ptr[1] + len
        ];
      }
      return o2;
    });
    let ptrs = found.map((o2) => o2.pointer);
    found = found.map((obj) => {
      obj.view = this.update([obj.pointer]);
      delete obj.regs;
      delete obj.needs;
      delete obj.pointer;
      delete obj._expanded;
      return obj;
    });
    return {
      view: this.update(ptrs),
      found
    };
  };
};
var api_default7 = api;

// node_modules/compromise/src/1-one/sweep/methods/buildNet/01-parse.js
var getTokenNeeds = function(reg) {
  if (reg.optional === true || reg.negative === true) {
    return null;
  }
  if (reg.tag) {
    return "#" + reg.tag;
  }
  if (reg.word) {
    return reg.word;
  }
  if (reg.switch) {
    return `%${reg.switch}%`;
  }
  return null;
};
var getNeeds = function(regs) {
  let needs = [];
  regs.forEach((reg) => {
    needs.push(getTokenNeeds(reg));
    if (reg.operator === "and" && reg.choices) {
      reg.choices.forEach((oneSide) => {
        oneSide.forEach((r2) => {
          needs.push(getTokenNeeds(r2));
        });
      });
    }
  });
  return needs.filter((str) => str);
};
var getWants = function(regs) {
  let wants = [];
  let count = 0;
  regs.forEach((reg) => {
    if (reg.operator === "or" && !reg.optional && !reg.negative) {
      if (reg.fastOr) {
        Array.from(reg.fastOr).forEach((w) => {
          wants.push(w);
        });
      }
      if (reg.choices) {
        reg.choices.forEach((rs) => {
          rs.forEach((r2) => {
            let n3 = getTokenNeeds(r2);
            if (n3) {
              wants.push(n3);
            }
          });
        });
      }
      count += 1;
    }
  });
  return { wants, count };
};
var parse = function(matches3, world2) {
  const parseMatch = world2.methods.one.parseMatch;
  matches3.forEach((obj) => {
    obj.regs = parseMatch(obj.match, {}, world2);
    if (typeof obj.ifNo === "string") {
      obj.ifNo = [obj.ifNo];
    }
    if (obj.notIf) {
      obj.notIf = parseMatch(obj.notIf, {}, world2);
    }
    obj.needs = getNeeds(obj.regs);
    let { wants, count } = getWants(obj.regs);
    obj.wants = wants;
    obj.minWant = count;
    obj.minWords = obj.regs.filter((o2) => !o2.optional).length;
  });
  return matches3;
};
var parse_default = parse;

// node_modules/compromise/src/1-one/sweep/methods/buildNet/index.js
var buildNet = function(matches3, world2) {
  matches3 = parse_default(matches3, world2);
  let hooks2 = {};
  matches3.forEach((obj) => {
    obj.needs.forEach((str) => {
      hooks2[str] = Array.isArray(hooks2[str]) ? hooks2[str] : [];
      hooks2[str].push(obj);
    });
    obj.wants.forEach((str) => {
      hooks2[str] = Array.isArray(hooks2[str]) ? hooks2[str] : [];
      hooks2[str].push(obj);
    });
  });
  Object.keys(hooks2).forEach((k2) => {
    let already = {};
    hooks2[k2] = hooks2[k2].filter((obj) => {
      if (typeof already[obj.match] === "boolean") {
        return false;
      }
      already[obj.match] = true;
      return true;
    });
  });
  let always = matches3.filter((o2) => o2.needs.length === 0 && o2.wants.length === 0);
  return {
    hooks: hooks2,
    always
  };
};
var buildNet_default = buildNet;

// node_modules/compromise/src/1-one/sweep/methods/sweep/01-getHooks.js
var getHooks = function(docCaches, hooks2) {
  return docCaches.map((set2, i3) => {
    let maybe = [];
    Object.keys(hooks2).forEach((k2) => {
      if (docCaches[i3].has(k2)) {
        maybe = maybe.concat(hooks2[k2]);
      }
    });
    let already = {};
    maybe = maybe.filter((m3) => {
      if (typeof already[m3.match] === "boolean") {
        return false;
      }
      already[m3.match] = true;
      return true;
    });
    return maybe;
  });
};
var getHooks_default = getHooks;

// node_modules/compromise/src/1-one/sweep/methods/sweep/02-trim-down.js
var localTrim = function(maybeList, docCache) {
  return maybeList.map((list4, n3) => {
    let haves = docCache[n3];
    list4 = list4.filter((obj) => {
      return obj.needs.every((need) => haves.has(need));
    });
    list4 = list4.filter((obj) => {
      if (obj.ifNo !== void 0 && obj.ifNo.some((no) => haves.has(no)) === true) {
        return false;
      }
      return true;
    });
    list4 = list4.filter((obj) => {
      if (obj.wants.length === 0) {
        return true;
      }
      let found = obj.wants.filter((str) => haves.has(str)).length;
      return found >= obj.minWant;
    });
    return list4;
  });
};
var trim_down_default = localTrim;

// node_modules/compromise/src/1-one/sweep/methods/sweep/04-runMatch.js
var runMatch2 = function(maybeList, document2, docCache, methods17, opts2) {
  let results = [];
  for (let n3 = 0; n3 < maybeList.length; n3 += 1) {
    for (let i3 = 0; i3 < maybeList[n3].length; i3 += 1) {
      let m3 = maybeList[n3][i3];
      let res = methods17.one.match([document2[n3]], m3);
      if (res.ptrs.length > 0) {
        res.ptrs.forEach((ptr) => {
          ptr[0] = n3;
          let todo = Object.assign({}, m3, { pointer: ptr });
          if (m3.unTag !== void 0) {
            todo.unTag = m3.unTag;
          }
          results.push(todo);
        });
        if (opts2.matchOne === true) {
          return [results[0]];
        }
      }
    }
  }
  return results;
};
var runMatch_default = runMatch2;

// node_modules/compromise/src/1-one/sweep/methods/sweep/index.js
var tooSmall = function(maybeList, document2) {
  return maybeList.map((arr, i3) => {
    let termCount = document2[i3].length;
    arr = arr.filter((o2) => {
      return termCount >= o2.minWords;
    });
    return arr;
  });
};
var sweep = function(document2, net3, methods17, opts2 = {}) {
  let docCache = methods17.one.cacheDoc(document2);
  let maybeList = getHooks_default(docCache, net3.hooks);
  maybeList = trim_down_default(maybeList, docCache, document2);
  if (net3.always.length > 0) {
    maybeList = maybeList.map((arr) => arr.concat(net3.always));
  }
  maybeList = tooSmall(maybeList, document2);
  let results = runMatch_default(maybeList, document2, docCache, methods17, opts2);
  return results;
};
var sweep_default = sweep;

// node_modules/compromise/src/1-one/sweep/methods/tagger/canBe.js
var canBe = function(terms, tag2, model5) {
  let tagSet = model5.one.tagSet;
  if (!tagSet.hasOwnProperty(tag2)) {
    return true;
  }
  let not = tagSet[tag2].not || [];
  for (let i3 = 0; i3 < terms.length; i3 += 1) {
    let term = terms[i3];
    for (let k2 = 0; k2 < not.length; k2 += 1) {
      if (term.tags.has(not[k2]) === true) {
        return false;
      }
    }
  }
  return true;
};
var canBe_default = canBe;

// node_modules/compromise/src/1-one/sweep/methods/tagger/index.js
var tagger = function(list4, document2, world2) {
  const { model: model5, methods: methods17 } = world2;
  const { getDoc: getDoc4, setTag: setTag2, unTag: unTag2 } = methods17.one;
  const looksPlural2 = methods17.two.looksPlural;
  if (list4.length === 0) {
    return list4;
  }
  const env2 = typeof process === "undefined" || !process.env ? self.env || {} : process.env;
  if (env2.DEBUG_TAGS) {
    console.log(`

  \x1B[32m\u2192 ${list4.length} post-tagger:\x1B[0m`);
  }
  return list4.map((todo) => {
    if (!todo.tag && !todo.chunk && !todo.unTag) {
      return;
    }
    let reason = todo.reason || todo.match;
    let terms = getDoc4([todo.pointer], document2)[0];
    if (todo.safe === true) {
      if (canBe_default(terms, todo.tag, model5) === false) {
        return;
      }
      if (terms[terms.length - 1].post === "-") {
        return;
      }
    }
    if (todo.tag !== void 0) {
      setTag2(terms, todo.tag, world2, todo.safe, `[post] '${reason}'`);
      if (todo.tag === "Noun" && looksPlural2) {
        let term = terms[terms.length - 1];
        if (looksPlural2(term.text)) {
          setTag2([term], "Plural", world2, todo.safe, "quick-plural");
        } else {
          setTag2([term], "Singular", world2, todo.safe, "quick-singular");
        }
      }
      if (todo.freeze === true) {
        terms.forEach((term) => term.frozen = true);
      }
    }
    if (todo.unTag !== void 0) {
      unTag2(terms, todo.unTag, world2, todo.safe, reason);
    }
    if (todo.chunk) {
      terms.forEach((t3) => t3.chunk = todo.chunk);
    }
  });
};
var tagger_default = tagger;

// node_modules/compromise/src/1-one/sweep/methods/index.js
var methods_default6 = {
  buildNet: buildNet_default,
  bulkMatch: sweep_default,
  bulkTagger: tagger_default
};

// node_modules/compromise/src/1-one/sweep/plugin.js
var plugin_default10 = {
  lib: lib_default3,
  api: api_default7,
  methods: {
    one: methods_default6
  }
};

// node_modules/compromise/src/1-one/tag/methods/setTag.js
var isMulti = / /;
var addChunk = function(term, tag2) {
  if (tag2 === "Noun") {
    term.chunk = tag2;
  }
  if (tag2 === "Verb") {
    term.chunk = tag2;
  }
};
var tagTerm = function(term, tag2, tagSet, isSafe) {
  if (term.tags.has(tag2) === true) {
    return null;
  }
  if (tag2 === ".") {
    return null;
  }
  if (term.frozen === true) {
    isSafe = true;
  }
  let known = tagSet[tag2];
  if (known) {
    if (known.not && known.not.length > 0) {
      for (let o2 = 0; o2 < known.not.length; o2 += 1) {
        if (isSafe === true && term.tags.has(known.not[o2])) {
          return null;
        }
        term.tags.delete(known.not[o2]);
      }
    }
    if (known.parents && known.parents.length > 0) {
      for (let o2 = 0; o2 < known.parents.length; o2 += 1) {
        term.tags.add(known.parents[o2]);
        addChunk(term, known.parents[o2]);
      }
    }
  }
  term.tags.add(tag2);
  term.dirty = true;
  addChunk(term, tag2);
  return true;
};
var multiTag = function(terms, tagString2, tagSet, isSafe) {
  let tags = tagString2.split(isMulti);
  terms.forEach((term, i3) => {
    let tag2 = tags[i3];
    if (tag2) {
      tag2 = tag2.replace(/^#/, "");
      tagTerm(term, tag2, tagSet, isSafe);
    }
  });
};
var isArray8 = function(arr) {
  return Object.prototype.toString.call(arr) === "[object Array]";
};
var log = (terms, tag2, reason = "") => {
  const yellow = (str) => "\x1B[33m\x1B[3m" + str + "\x1B[0m";
  const i3 = (str) => "\x1B[3m" + str + "\x1B[0m";
  let word = terms.map((t3) => {
    return t3.text || "[" + t3.implicit + "]";
  }).join(" ");
  if (typeof tag2 !== "string" && tag2.length > 2) {
    tag2 = tag2.slice(0, 2).join(", #") + " +";
  }
  tag2 = typeof tag2 !== "string" ? tag2.join(", #") : tag2;
  console.log(` ${yellow(word).padEnd(24)} \x1B[32m\u2192\x1B[0m #${tag2.padEnd(22)}  ${i3(reason)}`);
};
var setTag = function(terms, tag2, world2 = {}, isSafe, reason) {
  const tagSet = world2.model.one.tagSet || {};
  if (!tag2) {
    return;
  }
  const env2 = typeof process === "undefined" || !process.env ? self.env || {} : process.env;
  if (env2 && env2.DEBUG_TAGS) {
    log(terms, tag2, reason);
  }
  if (isArray8(tag2) === true) {
    tag2.forEach((tg) => setTag(terms, tg, world2, isSafe));
    return;
  }
  if (typeof tag2 !== "string") {
    console.warn(`compromise: Invalid tag '${tag2}'`);
    return;
  }
  tag2 = tag2.trim();
  if (isMulti.test(tag2)) {
    multiTag(terms, tag2, tagSet, isSafe);
    return;
  }
  tag2 = tag2.replace(/^#/, "");
  for (let i3 = 0; i3 < terms.length; i3 += 1) {
    tagTerm(terms[i3], tag2, tagSet, isSafe);
  }
};
var setTag_default = setTag;

// node_modules/compromise/src/1-one/tag/methods/unTag.js
var unTag = function(terms, tag2, tagSet) {
  tag2 = tag2.trim().replace(/^#/, "");
  for (let i3 = 0; i3 < terms.length; i3 += 1) {
    let term = terms[i3];
    if (term.frozen === true) {
      continue;
    }
    if (tag2 === "*") {
      term.tags.clear();
      continue;
    }
    let known = tagSet[tag2];
    if (known && known.children.length > 0) {
      for (let o2 = 0; o2 < known.children.length; o2 += 1) {
        term.tags.delete(known.children[o2]);
      }
    }
    term.tags.delete(tag2);
  }
};
var unTag_default = unTag;

// node_modules/compromise/src/1-one/tag/methods/canBe.js
var canBe2 = function(term, tag2, tagSet) {
  if (!tagSet.hasOwnProperty(tag2)) {
    return true;
  }
  let not = tagSet[tag2].not || [];
  for (let i3 = 0; i3 < not.length; i3 += 1) {
    if (term.tags.has(not[i3])) {
      return false;
    }
  }
  return true;
};
var canBe_default2 = canBe2;

// node_modules/grad-school/builds/grad-school.mjs
var e = function(e2) {
  return e2.children = e2.children || [], e2._cache = e2._cache || {}, e2.props = e2.props || {}, e2._cache.parents = e2._cache.parents || [], e2._cache.children = e2._cache.children || [], e2;
};
var t2 = /^ *(#|\/\/)/;
var n = function(t3) {
  let n3 = t3.trim().split(/->/), r2 = [];
  n3.forEach((t4) => {
    r2 = r2.concat(function(t5) {
      if (!(t5 = t5.trim()))
        return null;
      if (/^\[/.test(t5) && /\]$/.test(t5)) {
        let n4 = (t5 = (t5 = t5.replace(/^\[/, "")).replace(/\]$/, "")).split(/,/);
        return n4 = n4.map((e2) => e2.trim()).filter((e2) => e2), n4 = n4.map((t6) => e({ id: t6 })), n4;
      }
      return [e({ id: t5 })];
    }(t4));
  }), r2 = r2.filter((e2) => e2);
  let i3 = r2[0];
  for (let e2 = 1; e2 < r2.length; e2 += 1)
    i3.children.push(r2[e2]), i3 = r2[e2];
  return r2[0];
};
var r = (e2, t3) => {
  let n3 = [], r2 = [e2];
  for (; r2.length > 0; ) {
    let e3 = r2.pop();
    n3.push(e3), e3.children && e3.children.forEach((n4) => {
      t3 && t3(e3, n4), r2.push(n4);
    });
  }
  return n3;
};
var i2 = (e2) => "[object Array]" === Object.prototype.toString.call(e2);
var c = (e2) => (e2 = e2 || "").trim();
var s = function(c2 = []) {
  return "string" == typeof c2 ? function(r2) {
    let i3 = r2.split(/\r?\n/), c3 = [];
    i3.forEach((e2) => {
      if (!e2.trim() || t2.test(e2))
        return;
      let r3 = ((e3) => {
        const t3 = /^( {2}|\t)/;
        let n3 = 0;
        for (; t3.test(e3); )
          e3 = e3.replace(t3, ""), n3 += 1;
        return n3;
      })(e2);
      c3.push({ indent: r3, node: n(e2) });
    });
    let s4 = function(e2) {
      let t3 = { children: [] };
      return e2.forEach((n3, r3) => {
        0 === n3.indent ? t3.children = t3.children.concat(n3.node) : e2[r3 - 1] && function(e3, t4) {
          let n4 = e3[t4].indent;
          for (; t4 >= 0; t4 -= 1)
            if (e3[t4].indent < n4)
              return e3[t4];
          return e3[0];
        }(e2, r3).node.children.push(n3.node);
      }), t3;
    }(c3);
    return s4 = e(s4), s4;
  }(c2) : i2(c2) ? function(t3) {
    let n3 = {};
    t3.forEach((e2) => {
      n3[e2.id] = e2;
    });
    let r2 = e({});
    return t3.forEach((t4) => {
      if ((t4 = e(t4)).parent)
        if (n3.hasOwnProperty(t4.parent)) {
          let e2 = n3[t4.parent];
          delete t4.parent, e2.children.push(t4);
        } else
          console.warn(`[Grad] - missing node '${t4.parent}'`);
      else
        r2.children.push(t4);
    }), r2;
  }(c2) : (r(s3 = c2).forEach(e), s3);
  var s3;
};
var h = (e2) => "\x1B[31m" + e2 + "\x1B[0m";
var o = (e2) => "\x1B[2m" + e2 + "\x1B[0m";
var l = function(e2, t3) {
  let n3 = "-> ";
  t3 && (n3 = o("\u2192 "));
  let i3 = "";
  return r(e2).forEach((e3, r2) => {
    let c2 = e3.id || "";
    if (t3 && (c2 = h(c2)), 0 === r2 && !e3.id)
      return;
    let s3 = e3._cache.parents.length;
    i3 += "    ".repeat(s3) + n3 + c2 + "\n";
  }), i3;
};
var a = function(e2) {
  let t3 = r(e2);
  t3.forEach((e3) => {
    delete (e3 = Object.assign({}, e3)).children;
  });
  let n3 = t3[0];
  return n3 && !n3.id && 0 === Object.keys(n3.props).length && t3.shift(), t3;
};
var p = { text: l, txt: l, array: a, flat: a };
var d = function(e2, t3) {
  return "nested" === t3 || "json" === t3 ? e2 : "debug" === t3 ? (console.log(l(e2, true)), null) : p.hasOwnProperty(t3) ? p[t3](e2) : e2;
};
var u = (e2) => {
  r(e2, (e3, t3) => {
    e3.id && (e3._cache.parents = e3._cache.parents || [], t3._cache.parents = e3._cache.parents.concat([e3.id]));
  });
};
var f = (e2, t3) => (Object.keys(t3).forEach((n3) => {
  if (t3[n3] instanceof Set) {
    let r2 = e2[n3] || /* @__PURE__ */ new Set();
    e2[n3] = /* @__PURE__ */ new Set([...r2, ...t3[n3]]);
  } else {
    if (((e3) => e3 && "object" == typeof e3 && !Array.isArray(e3))(t3[n3])) {
      let r2 = e2[n3] || {};
      e2[n3] = Object.assign({}, t3[n3], r2);
    } else
      i2(t3[n3]) ? e2[n3] = t3[n3].concat(e2[n3] || []) : void 0 === e2[n3] && (e2[n3] = t3[n3]);
  }
}), e2);
var j = /\//;
var g = class _g {
  constructor(e2 = {}) {
    Object.defineProperty(this, "json", { enumerable: false, value: e2, writable: true });
  }
  get children() {
    return this.json.children;
  }
  get id() {
    return this.json.id;
  }
  get found() {
    return this.json.id || this.json.children.length > 0;
  }
  props(e2 = {}) {
    let t3 = this.json.props || {};
    return "string" == typeof e2 && (t3[e2] = true), this.json.props = Object.assign(t3, e2), this;
  }
  get(t3) {
    if (t3 = c(t3), !j.test(t3)) {
      let e2 = this.json.children.find((e3) => e3.id === t3);
      return new _g(e2);
    }
    let n3 = ((e2, t4) => {
      let n4 = ((e3) => "string" != typeof e3 ? e3 : (e3 = e3.replace(/^\//, "")).split(/\//))(t4 = t4 || "");
      for (let t5 = 0; t5 < n4.length; t5 += 1) {
        let r2 = e2.children.find((e3) => e3.id === n4[t5]);
        if (!r2)
          return null;
        e2 = r2;
      }
      return e2;
    })(this.json, t3) || e({});
    return new _g(n3);
  }
  add(t3, n3 = {}) {
    if (i2(t3))
      return t3.forEach((e2) => this.add(c(e2), n3)), this;
    t3 = c(t3);
    let r2 = e({ id: t3, props: n3 });
    return this.json.children.push(r2), new _g(r2);
  }
  remove(e2) {
    return e2 = c(e2), this.json.children = this.json.children.filter((t3) => t3.id !== e2), this;
  }
  nodes() {
    return r(this.json).map((e2) => (delete (e2 = Object.assign({}, e2)).children, e2));
  }
  cache() {
    return ((e2) => {
      let t3 = r(e2, (e3, t4) => {
        e3.id && (e3._cache.parents = e3._cache.parents || [], e3._cache.children = e3._cache.children || [], t4._cache.parents = e3._cache.parents.concat([e3.id]));
      }), n3 = {};
      t3.forEach((e3) => {
        e3.id && (n3[e3.id] = e3);
      }), t3.forEach((e3) => {
        e3._cache.parents.forEach((t4) => {
          n3.hasOwnProperty(t4) && n3[t4]._cache.children.push(e3.id);
        });
      }), e2._cache.children = Object.keys(n3);
    })(this.json), this;
  }
  list() {
    return r(this.json);
  }
  fillDown() {
    var e2;
    return e2 = this.json, r(e2, (e3, t3) => {
      t3.props = f(t3.props, e3.props);
    }), this;
  }
  depth() {
    u(this.json);
    let e2 = r(this.json), t3 = e2.length > 1 ? 1 : 0;
    return e2.forEach((e3) => {
      if (0 === e3._cache.parents.length)
        return;
      let n3 = e3._cache.parents.length + 1;
      n3 > t3 && (t3 = n3);
    }), t3;
  }
  out(e2) {
    return u(this.json), d(this.json, e2);
  }
  debug() {
    return u(this.json), d(this.json, "debug"), this;
  }
};
var _ = function(e2) {
  let t3 = s(e2);
  return new g(t3);
};
_.prototype.plugin = function(e2) {
  e2(this);
};

// node_modules/compromise/src/1-one/tag/methods/addTags/_colors.js
var colors = {
  Noun: "blue",
  Verb: "green",
  Negative: "green",
  Date: "red",
  Value: "red",
  Adjective: "magenta",
  Preposition: "cyan",
  Conjunction: "cyan",
  Determiner: "cyan",
  Hyphenated: "cyan",
  Adverb: "cyan"
};
var colors_default = colors;

// node_modules/compromise/src/1-one/tag/methods/addTags/02-fmt.js
var getColor = function(node) {
  if (colors_default.hasOwnProperty(node.id)) {
    return colors_default[node.id];
  }
  if (colors_default.hasOwnProperty(node.is)) {
    return colors_default[node.is];
  }
  let found = node._cache.parents.find((c2) => colors_default[c2]);
  return colors_default[found];
};
var fmt = function(nodes) {
  const res = {};
  nodes.forEach((node) => {
    let { not, also, is: is2, novel } = node.props;
    let parents = node._cache.parents;
    if (also) {
      parents = parents.concat(also);
    }
    res[node.id] = {
      is: is2,
      not,
      novel,
      also,
      parents,
      children: node._cache.children,
      color: getColor(node)
    };
  });
  Object.keys(res).forEach((k2) => {
    let nots = new Set(res[k2].not);
    res[k2].not.forEach((not) => {
      if (res[not]) {
        res[not].children.forEach((tag2) => nots.add(tag2));
      }
    });
    res[k2].not = Array.from(nots);
  });
  return res;
};
var fmt_default = fmt;

// node_modules/compromise/src/1-one/tag/methods/addTags/01-validate.js
var toArr = function(input) {
  if (!input) {
    return [];
  }
  if (typeof input === "string") {
    return [input];
  }
  return input;
};
var addImplied = function(tags, already) {
  Object.keys(tags).forEach((k2) => {
    if (tags[k2].isA) {
      tags[k2].is = tags[k2].isA;
    }
    if (tags[k2].notA) {
      tags[k2].not = tags[k2].notA;
    }
    if (tags[k2].is && typeof tags[k2].is === "string") {
      if (!already.hasOwnProperty(tags[k2].is) && !tags.hasOwnProperty(tags[k2].is)) {
        tags[tags[k2].is] = {};
      }
    }
    if (tags[k2].not && typeof tags[k2].not === "string" && !tags.hasOwnProperty(tags[k2].not)) {
      if (!already.hasOwnProperty(tags[k2].not) && !tags.hasOwnProperty(tags[k2].not)) {
        tags[tags[k2].not] = {};
      }
    }
  });
  return tags;
};
var validate = function(tags, already) {
  tags = addImplied(tags, already);
  Object.keys(tags).forEach((k2) => {
    tags[k2].children = toArr(tags[k2].children);
    tags[k2].not = toArr(tags[k2].not);
  });
  Object.keys(tags).forEach((k2) => {
    let nots = tags[k2].not || [];
    nots.forEach((no) => {
      if (tags[no] && tags[no].not) {
        tags[no].not.push(k2);
      }
    });
  });
  return tags;
};
var validate_default = validate;

// node_modules/compromise/src/1-one/tag/methods/addTags/index.js
var compute3 = function(allTags2) {
  const flatList = Object.keys(allTags2).map((k2) => {
    let o2 = allTags2[k2];
    const props = { not: new Set(o2.not), also: o2.also, is: o2.is, novel: o2.novel };
    return { id: k2, parent: o2.is, props, children: [] };
  });
  const graph = _(flatList).cache().fillDown();
  return graph.out("array");
};
var fromUser = function(tags) {
  Object.keys(tags).forEach((k2) => {
    tags[k2] = Object.assign({}, tags[k2]);
    tags[k2].novel = true;
  });
  return tags;
};
var addTags = function(tags, already) {
  if (Object.keys(already).length > 0) {
    tags = fromUser(tags);
  }
  tags = validate_default(tags, already);
  let allTags2 = Object.assign({}, already, tags);
  const nodes = compute3(allTags2);
  const res = fmt_default(nodes);
  return res;
};
var addTags_default = addTags;

// node_modules/compromise/src/1-one/tag/methods/index.js
var methods_default7 = {
  one: {
    setTag: setTag_default,
    unTag: unTag_default,
    addTags: addTags_default,
    canBe: canBe_default2
  }
};

// node_modules/compromise/src/1-one/tag/api/tag.js
var isArray9 = function(arr) {
  return Object.prototype.toString.call(arr) === "[object Array]";
};
var fns5 = {
  /** add a given tag, to all these terms */
  tag: function(input, reason = "", isSafe) {
    if (!this.found || !input) {
      return this;
    }
    let terms = this.termList();
    if (terms.length === 0) {
      return this;
    }
    const { methods: methods17, verbose: verbose2, world: world2 } = this;
    if (verbose2 === true) {
      console.log(" +  ", input, reason || "");
    }
    if (isArray9(input)) {
      input.forEach((tag2) => methods17.one.setTag(terms, tag2, world2, isSafe, reason));
    } else {
      methods17.one.setTag(terms, input, world2, isSafe, reason);
    }
    this.uncache();
    return this;
  },
  /** add a given tag, only if it is consistent */
  tagSafe: function(input, reason = "") {
    return this.tag(input, reason, true);
  },
  /** remove a given tag from all these terms */
  unTag: function(input, reason) {
    if (!this.found || !input) {
      return this;
    }
    let terms = this.termList();
    if (terms.length === 0) {
      return this;
    }
    const { methods: methods17, verbose: verbose2, model: model5 } = this;
    if (verbose2 === true) {
      console.log(" -  ", input, reason || "");
    }
    let tagSet = model5.one.tagSet;
    if (isArray9(input)) {
      input.forEach((tag2) => methods17.one.unTag(terms, tag2, tagSet));
    } else {
      methods17.one.unTag(terms, input, tagSet);
    }
    this.uncache();
    return this;
  },
  /** return only the terms that can be this tag  */
  canBe: function(tag2) {
    tag2 = tag2.replace(/^#/, "");
    let tagSet = this.model.one.tagSet;
    let canBe3 = this.methods.one.canBe;
    let nope2 = [];
    this.document.forEach((terms, n3) => {
      terms.forEach((term, i3) => {
        if (!canBe3(term, tag2, tagSet)) {
          nope2.push([n3, i3, i3 + 1]);
        }
      });
    });
    let noDoc = this.update(nope2);
    return this.difference(noDoc);
  }
};
var tag_default = fns5;

// node_modules/compromise/src/1-one/tag/api/index.js
var tagAPI = function(View2) {
  Object.assign(View2.prototype, tag_default);
};
var api_default8 = tagAPI;

// node_modules/compromise/src/1-one/tag/lib.js
var addTags2 = function(tags) {
  const { model: model5, methods: methods17 } = this.world();
  const tagSet = model5.one.tagSet;
  const fn = methods17.one.addTags;
  let res = fn(tags, tagSet);
  model5.one.tagSet = res;
  return this;
};
var lib_default4 = { addTags: addTags2 };

// node_modules/compromise/src/1-one/tag/compute/tagRank.js
var boringTags = /* @__PURE__ */ new Set(["Auxiliary", "Possessive"]);
var sortByKids = function(tags, tagSet) {
  tags = tags.sort((a2, b) => {
    if (boringTags.has(a2) || !tagSet.hasOwnProperty(b)) {
      return 1;
    }
    if (boringTags.has(b) || !tagSet.hasOwnProperty(a2)) {
      return -1;
    }
    let kids = tagSet[a2].children || [];
    let aKids = kids.length;
    kids = tagSet[b].children || [];
    let bKids = kids.length;
    return aKids - bKids;
  });
  return tags;
};
var tagRank = function(view) {
  const { document: document2, world: world2 } = view;
  const tagSet = world2.model.one.tagSet;
  document2.forEach((terms) => {
    terms.forEach((term) => {
      let tags = Array.from(term.tags);
      term.tagRank = sortByKids(tags, tagSet);
    });
  });
};
var tagRank_default = tagRank;

// node_modules/compromise/src/1-one/tag/plugin.js
var plugin_default11 = {
  model: {
    one: { tagSet: {} }
  },
  compute: {
    tagRank: tagRank_default
  },
  methods: methods_default7,
  api: api_default8,
  lib: lib_default4
};

// node_modules/compromise/src/1-one/tokenize/methods/01-sentences/01-simple-split.js
var initSplit = /([.!?\u203D\u2E18\u203C\u2047-\u2049\u3002]+\s)/g;
var splitsOnly = /^[.!?\u203D\u2E18\u203C\u2047-\u2049\u3002]+\s$/;
var newLine = /((?:\r?\n|\r)+)/;
var basicSplit = function(text2) {
  let all4 = [];
  let lines = text2.split(newLine);
  for (let i3 = 0; i3 < lines.length; i3++) {
    let arr = lines[i3].split(initSplit);
    for (let o2 = 0; o2 < arr.length; o2++) {
      if (arr[o2 + 1] && splitsOnly.test(arr[o2 + 1]) === true) {
        arr[o2] += arr[o2 + 1];
        arr[o2 + 1] = "";
      }
      if (arr[o2] !== "") {
        all4.push(arr[o2]);
      }
    }
  }
  return all4;
};
var simple_split_default = basicSplit;

// node_modules/compromise/src/1-one/tokenize/methods/01-sentences/02-simple-merge.js
var hasLetter = /[a-z0-9\u00C0-\u00FF\u00a9\u00ae\u2000-\u3300\ud000-\udfff]/i;
var hasSomething = /\S/;
var notEmpty = function(splits) {
  let chunks2 = [];
  for (let i3 = 0; i3 < splits.length; i3++) {
    let s3 = splits[i3];
    if (s3 === void 0 || s3 === "") {
      continue;
    }
    if (hasSomething.test(s3) === false || hasLetter.test(s3) === false) {
      if (chunks2[chunks2.length - 1]) {
        chunks2[chunks2.length - 1] += s3;
        continue;
      } else if (splits[i3 + 1]) {
        splits[i3 + 1] = s3 + splits[i3 + 1];
        continue;
      }
    }
    chunks2.push(s3);
  }
  return chunks2;
};
var simple_merge_default = notEmpty;

// node_modules/compromise/src/1-one/tokenize/methods/01-sentences/03-smart-merge.js
var smartMerge = function(chunks2, world2) {
  const isSentence2 = world2.methods.one.tokenize.isSentence;
  const abbrevs = world2.model.one.abbreviations || /* @__PURE__ */ new Set();
  let sentences = [];
  for (let i3 = 0; i3 < chunks2.length; i3++) {
    let c2 = chunks2[i3];
    if (chunks2[i3 + 1] && isSentence2(c2, abbrevs) === false) {
      chunks2[i3 + 1] = c2 + (chunks2[i3 + 1] || "");
    } else if (c2 && c2.length > 0) {
      sentences.push(c2);
      chunks2[i3] = "";
    }
  }
  return sentences;
};
var smart_merge_default = smartMerge;

// node_modules/compromise/src/1-one/tokenize/methods/01-sentences/04-quote-merge.js
var MAX_QUOTE = 280;
var pairs = {
  '"': '"',
  // 'StraightDoubleQuotes'
  "\uFF02": "\uFF02",
  // 'StraightDoubleQuotesWide'
  // '\u0027': '\u0027', // 'StraightSingleQuotes'
  "\u201C": "\u201D",
  // 'CommaDoubleQuotes'
  // '\u2018': '\u2019', // 'CommaSingleQuotes'
  "\u201F": "\u201D",
  // 'CurlyDoubleQuotesReversed'
  // '\u201B': '\u2019', // 'CurlySingleQuotesReversed'
  "\u201E": "\u201D",
  // 'LowCurlyDoubleQuotes'
  "\u2E42": "\u201D",
  // 'LowCurlyDoubleQuotesReversed'
  "\u201A": "\u2019",
  // 'LowCurlySingleQuotes'
  "\xAB": "\xBB",
  // 'AngleDoubleQuotes'
  "\u2039": "\u203A",
  // 'AngleSingleQuotes'
  "\u2035": "\u2032",
  // 'PrimeSingleQuotes'
  "\u2036": "\u2033",
  // 'PrimeDoubleQuotes'
  "\u2037": "\u2034",
  // 'PrimeTripleQuotes'
  "\u301D": "\u301E",
  // 'PrimeDoubleQuotes'
  // '\u0060': '\u00B4', // 'PrimeSingleQuotes'
  "\u301F": "\u301E"
  // 'LowPrimeDoubleQuotesReversed'
};
var openQuote = RegExp("[" + Object.keys(pairs).join("") + "]", "g");
var closeQuote = RegExp("[" + Object.values(pairs).join("") + "]", "g");
var closesQuote = function(str) {
  if (!str) {
    return false;
  }
  let m3 = str.match(closeQuote);
  if (m3 !== null && m3.length === 1) {
    return true;
  }
  return false;
};
var quoteMerge = function(splits) {
  let arr = [];
  for (let i3 = 0; i3 < splits.length; i3 += 1) {
    let split3 = splits[i3];
    let m3 = split3.match(openQuote);
    if (m3 !== null && m3.length === 1) {
      if (closesQuote(splits[i3 + 1]) && splits[i3 + 1].length < MAX_QUOTE) {
        splits[i3] += splits[i3 + 1];
        arr.push(splits[i3]);
        splits[i3 + 1] = "";
        i3 += 1;
        continue;
      }
      if (closesQuote(splits[i3 + 2])) {
        let toAdd = splits[i3 + 1] + splits[i3 + 2];
        if (toAdd.length < MAX_QUOTE) {
          splits[i3] += toAdd;
          arr.push(splits[i3]);
          splits[i3 + 1] = "";
          splits[i3 + 2] = "";
          i3 += 2;
          continue;
        }
      }
    }
    arr.push(splits[i3]);
  }
  return arr;
};
var quote_merge_default = quoteMerge;

// node_modules/compromise/src/1-one/tokenize/methods/01-sentences/05-parens-merge.js
var MAX_LEN = 250;
var hasOpen = /\(/g;
var hasClosed = /\)/g;
var mergeParens = function(splits) {
  let arr = [];
  for (let i3 = 0; i3 < splits.length; i3 += 1) {
    let split3 = splits[i3];
    let m3 = split3.match(hasOpen);
    if (m3 !== null && m3.length === 1) {
      if (splits[i3 + 1] && splits[i3 + 1].length < MAX_LEN) {
        let m22 = splits[i3 + 1].match(hasClosed);
        if (m22 !== null && m3.length === 1 && !hasOpen.test(splits[i3 + 1])) {
          splits[i3] += splits[i3 + 1];
          arr.push(splits[i3]);
          splits[i3 + 1] = "";
          i3 += 1;
          continue;
        }
      }
    }
    arr.push(splits[i3]);
  }
  return arr;
};
var parens_merge_default = mergeParens;

// node_modules/compromise/src/1-one/tokenize/methods/01-sentences/index.js
var hasSomething2 = /\S/;
var startWhitespace = /^\s+/;
var splitSentences = function(text2, world2) {
  text2 = text2 || "";
  text2 = String(text2);
  if (!text2 || typeof text2 !== "string" || hasSomething2.test(text2) === false) {
    return [];
  }
  text2 = text2.replace("\xA0", " ");
  let splits = simple_split_default(text2);
  let sentences = simple_merge_default(splits);
  sentences = smart_merge_default(sentences, world2);
  sentences = quote_merge_default(sentences);
  sentences = parens_merge_default(sentences);
  if (sentences.length === 0) {
    return [text2];
  }
  for (let i3 = 1; i3 < sentences.length; i3 += 1) {
    let ws = sentences[i3].match(startWhitespace);
    if (ws !== null) {
      sentences[i3 - 1] += ws[0];
      sentences[i3] = sentences[i3].replace(startWhitespace, "");
    }
  }
  return sentences;
};
var sentences_default = splitSentences;

// node_modules/compromise/src/1-one/tokenize/methods/02-terms/01-hyphens.js
var hasHyphen2 = function(str, model5) {
  let parts = str.split(/[-]/);
  if (parts.length <= 1) {
    return false;
  }
  const { prefixes: prefixes2, suffixes: suffixes5 } = model5.one;
  if (parts[0].length === 1 && /[a-z]/i.test(parts[0])) {
    return false;
  }
  if (prefixes2.hasOwnProperty(parts[0])) {
    return false;
  }
  parts[1] = parts[1].trim().replace(/[.?!]$/, "");
  if (suffixes5.hasOwnProperty(parts[1])) {
    return false;
  }
  let reg = /^([a-z\u00C0-\u00FF`"'/]+)[-]([a-z0-9\u00C0-\u00FF].*)/i;
  if (reg.test(str) === true) {
    return true;
  }
  let reg2 = /^[('"]?([0-9]{1,4})[-]([a-z\u00C0-\u00FF`"'/-]+[)'"]?$)/i;
  if (reg2.test(str) === true) {
    return true;
  }
  return false;
};
var splitHyphens2 = function(word) {
  let arr = [];
  const hyphens = word.split(/[-]/);
  let whichDash = "-";
  let found = word.match(/[-]/);
  if (found && found[0]) {
    whichDash = found;
  }
  for (let o2 = 0; o2 < hyphens.length; o2++) {
    if (o2 === hyphens.length - 1) {
      arr.push(hyphens[o2]);
    } else {
      arr.push(hyphens[o2] + whichDash);
    }
  }
  return arr;
};

// node_modules/compromise/src/1-one/tokenize/methods/02-terms/03-ranges.js
var combineRanges = function(arr) {
  const startRange = /^[0-9]{1,4}(:[0-9][0-9])?([a-z]{1,2})? ?[-] ?$/;
  const endRange = /^[0-9]{1,4}([a-z]{1,2})? ?$/;
  for (let i3 = 0; i3 < arr.length - 1; i3 += 1) {
    if (arr[i3 + 1] && startRange.test(arr[i3]) && endRange.test(arr[i3 + 1])) {
      arr[i3] = arr[i3] + arr[i3 + 1];
      arr[i3 + 1] = null;
    }
  }
  return arr;
};
var ranges_default = combineRanges;

// node_modules/compromise/src/1-one/tokenize/methods/02-terms/02-slashes.js
var isSlash = /\p{L} ?\/ ?\p{L}+$/u;
var combineSlashes = function(arr) {
  for (let i3 = 1; i3 < arr.length - 1; i3++) {
    if (isSlash.test(arr[i3])) {
      arr[i3 - 1] += arr[i3] + arr[i3 + 1];
      arr[i3] = null;
      arr[i3 + 1] = null;
    }
  }
  return arr;
};
var slashes_default = combineSlashes;

// node_modules/compromise/src/1-one/tokenize/methods/02-terms/index.js
var wordlike = /\S/;
var isBoundary = /^[!?.]+$/;
var naiiveSplit = /(\S+)/;
var notWord = [
  ".",
  "?",
  "!",
  ":",
  ";",
  "-",
  "\u2013",
  "\u2014",
  "--",
  "...",
  "(",
  ")",
  "[",
  "]",
  '"',
  "'",
  "`",
  "\xAB",
  "\xBB",
  "*",
  "\u2022"
];
notWord = notWord.reduce((h2, c2) => {
  h2[c2] = true;
  return h2;
}, {});
var isArray10 = function(arr) {
  return Object.prototype.toString.call(arr) === "[object Array]";
};
var splitWords = function(str, model5) {
  let result = [];
  let arr = [];
  str = str || "";
  if (typeof str === "number") {
    str = String(str);
  }
  if (isArray10(str)) {
    return str;
  }
  const words = str.split(naiiveSplit);
  for (let i3 = 0; i3 < words.length; i3++) {
    if (hasHyphen2(words[i3], model5) === true) {
      arr = arr.concat(splitHyphens2(words[i3]));
      continue;
    }
    arr.push(words[i3]);
  }
  let carry = "";
  for (let i3 = 0; i3 < arr.length; i3++) {
    let word = arr[i3];
    if (wordlike.test(word) === true && notWord.hasOwnProperty(word) === false && isBoundary.test(word) === false) {
      if (result.length > 0) {
        result[result.length - 1] += carry;
        result.push(word);
      } else {
        result.push(carry + word);
      }
      carry = "";
    } else {
      carry += word;
    }
  }
  if (carry) {
    if (result.length === 0) {
      result[0] = "";
    }
    result[result.length - 1] += carry;
  }
  result = slashes_default(result);
  result = ranges_default(result);
  result = result.filter((s3) => s3);
  return result;
};
var terms_default = splitWords;

// node_modules/compromise/src/1-one/tokenize/methods/03-whitespace/tokenize.js
var isLetter = /\p{Letter}/u;
var isNumber = /[\p{Number}\p{Currency_Symbol}]/u;
var hasAcronym = /^[a-z]\.([a-z]\.)+/i;
var chillin = /[sn][']$/;
var normalizePunctuation = function(str, model5) {
  let { prePunctuation: prePunctuation2, postPunctuation: postPunctuation2, emoticons: emoticons2 } = model5.one;
  let original = str;
  let pre = "";
  let post = "";
  let chars = Array.from(str);
  if (emoticons2.hasOwnProperty(str.trim())) {
    return { str: str.trim(), pre, post: " " };
  }
  let len = chars.length;
  for (let i3 = 0; i3 < len; i3 += 1) {
    let c2 = chars[0];
    if (prePunctuation2[c2] === true) {
      continue;
    }
    if ((c2 === "+" || c2 === "-") && isNumber.test(chars[1])) {
      break;
    }
    if (c2 === "'" && c2.length === 3 && isNumber.test(chars[1])) {
      break;
    }
    if (isLetter.test(c2) || isNumber.test(c2)) {
      break;
    }
    pre += chars.shift();
  }
  len = chars.length;
  for (let i3 = 0; i3 < len; i3 += 1) {
    let c2 = chars[chars.length - 1];
    if (postPunctuation2[c2] === true) {
      continue;
    }
    if (isLetter.test(c2) || isNumber.test(c2)) {
      break;
    }
    if (c2 === "." && hasAcronym.test(original) === true) {
      continue;
    }
    if (c2 === "'" && chillin.test(original) === true) {
      continue;
    }
    post = chars.pop() + post;
  }
  str = chars.join("");
  if (str === "") {
    original = original.replace(/ *$/, (after2) => {
      post = after2 || "";
      return "";
    });
    str = original;
    pre = "";
  }
  return { str, pre, post };
};
var tokenize_default = normalizePunctuation;

// node_modules/compromise/src/1-one/tokenize/methods/03-whitespace/index.js
var parseTerm = (txt, model5) => {
  let { str, pre, post } = tokenize_default(txt, model5);
  const parsed = {
    text: str,
    pre,
    post,
    tags: /* @__PURE__ */ new Set()
  };
  return parsed;
};
var whitespace_default2 = parseTerm;

// node_modules/compromise/src/1-one/tokenize/methods/unicode.js
var killUnicode = function(str, world2) {
  const unicode2 = world2.model.one.unicode || {};
  str = str || "";
  let chars = str.split("");
  chars.forEach((s3, i3) => {
    if (unicode2[s3]) {
      chars[i3] = unicode2[s3];
    }
  });
  return chars.join("");
};
var unicode_default = killUnicode;

// node_modules/compromise/src/1-one/tokenize/compute/normal/01-cleanup.js
var clean = function(str) {
  str = str || "";
  str = str.toLowerCase();
  str = str.trim();
  let original = str;
  str = str.replace(/[,;.!?]+$/, "");
  str = str.replace(/\u2026/g, "...");
  str = str.replace(/\u2013/g, "-");
  if (/^[:;]/.test(str) === false) {
    str = str.replace(/\.{3,}$/g, "");
    str = str.replace(/[",.!:;?)]+$/g, "");
    str = str.replace(/^['"(]+/g, "");
  }
  str = str.replace(/[\u200B-\u200D\uFEFF]/g, "");
  str = str.trim();
  if (str === "") {
    str = original;
  }
  str = str.replace(/([0-9]),([0-9])/g, "$1$2");
  return str;
};
var cleanup_default = clean;

// node_modules/compromise/src/1-one/tokenize/compute/normal/02-acronyms.js
var periodAcronym = /([A-Z]\.)+[A-Z]?,?$/;
var oneLetterAcronym = /^[A-Z]\.,?$/;
var noPeriodAcronym = /[A-Z]{2,}('s|,)?$/;
var lowerCaseAcronym = /([a-z]\.)+[a-z]\.?$/;
var isAcronym = function(str) {
  if (periodAcronym.test(str) === true) {
    return true;
  }
  if (lowerCaseAcronym.test(str) === true) {
    return true;
  }
  if (oneLetterAcronym.test(str) === true) {
    return true;
  }
  if (noPeriodAcronym.test(str) === true) {
    return true;
  }
  return false;
};
var doAcronym = function(str) {
  if (isAcronym(str)) {
    str = str.replace(/\./g, "");
  }
  return str;
};
var acronyms_default = doAcronym;

// node_modules/compromise/src/1-one/tokenize/compute/normal/index.js
var normalize = function(term, world2) {
  const killUnicode2 = world2.methods.one.killUnicode;
  let str = term.text || "";
  str = cleanup_default(str);
  str = killUnicode2(str, world2);
  str = acronyms_default(str);
  term.normal = str;
};
var normal_default = normalize;

// node_modules/compromise/src/1-one/tokenize/methods/parse.js
var parse2 = function(input, world2) {
  const { methods: methods17, model: model5 } = world2;
  const { splitSentences: splitSentences2, splitTerms, splitWhitespace } = methods17.one.tokenize;
  input = input || "";
  let sentences = splitSentences2(input, world2);
  input = sentences.map((txt) => {
    let terms = splitTerms(txt, model5);
    terms = terms.map((t3) => splitWhitespace(t3, model5));
    terms.forEach((t3) => {
      normal_default(t3, world2);
    });
    return terms;
  });
  return input;
};
var parse_default2 = parse2;

// node_modules/compromise/src/1-one/tokenize/methods/01-sentences/is-sentence.js
var isAcronym2 = /[ .][A-Z]\.? *$/i;
var hasEllipse = /(?:\u2026|\.{2,}) *$/;
var hasLetter2 = /\p{L}/u;
var hasPeriod = /\. *$/;
var leadInit = /^[A-Z]\. $/;
var isSentence = function(str, abbrevs) {
  if (hasLetter2.test(str) === false) {
    return false;
  }
  if (isAcronym2.test(str) === true) {
    return false;
  }
  if (str.length === 3 && leadInit.test(str)) {
    return false;
  }
  if (hasEllipse.test(str) === true) {
    return false;
  }
  let txt = str.replace(/[.!?\u203D\u2E18\u203C\u2047-\u2049] *$/, "");
  let words = txt.split(" ");
  let lastWord = words[words.length - 1].toLowerCase();
  if (abbrevs.hasOwnProperty(lastWord) === true && hasPeriod.test(str) === true) {
    return false;
  }
  return true;
};
var is_sentence_default = isSentence;

// node_modules/compromise/src/1-one/tokenize/methods/index.js
var methods_default8 = {
  one: {
    killUnicode: unicode_default,
    tokenize: {
      splitSentences: sentences_default,
      isSentence: is_sentence_default,
      splitTerms: terms_default,
      splitWhitespace: whitespace_default2,
      fromString: parse_default2
    }
  }
};

// node_modules/compromise/src/1-one/tokenize/model/aliases.js
var aliases = {
  "&": "and",
  "@": "at",
  "%": "percent",
  "plz": "please",
  "bein": "being"
};
var aliases_default = aliases;

// node_modules/compromise/src/1-one/tokenize/model/abbreviations/misc.js
var misc_default = [
  "approx",
  "apt",
  "bc",
  "cyn",
  "eg",
  "esp",
  "est",
  "etc",
  "ex",
  "exp",
  "prob",
  //probably
  "pron",
  // Pronunciation
  "gal",
  //gallon
  "min",
  "pseud",
  "fig",
  //figure
  "jd",
  "lat",
  //latitude
  "lng",
  //longitude
  "vol",
  //volume
  "fm",
  //not am
  "def",
  //definition
  "misc",
  "plz",
  //please
  "ea",
  //each
  "ps",
  "sec",
  //second
  "pt",
  "pref",
  //preface
  "pl",
  //plural
  "pp",
  //pages
  "qt",
  //quarter
  "fr",
  //french
  "sq",
  "nee",
  //given name at birth
  "ss",
  //ship, or sections
  "tel",
  "temp",
  "vet",
  "ver",
  //version
  "fem",
  //feminine
  "masc",
  //masculine
  "eng",
  //engineering/english
  "adj",
  //adjective
  "vb",
  //verb
  "rb",
  //adverb
  "inf",
  //infinitive
  "situ",
  // in situ
  "vivo",
  "vitro",
  "wr"
  //world record
];

// node_modules/compromise/src/1-one/tokenize/model/abbreviations/honorifics.js
var honorifics_default = [
  "adj",
  "adm",
  "adv",
  "asst",
  "atty",
  "bldg",
  "brig",
  "capt",
  "cmdr",
  "comdr",
  "cpl",
  "det",
  "dr",
  "esq",
  "gen",
  "gov",
  "hon",
  "jr",
  "llb",
  "lt",
  "maj",
  "messrs",
  "mlle",
  "mme",
  "mr",
  "mrs",
  "ms",
  "mstr",
  "phd",
  "prof",
  "pvt",
  "rep",
  "reps",
  "res",
  "rev",
  "sen",
  "sens",
  "sfc",
  "sgt",
  "sir",
  "sr",
  "supt",
  "surg"
  //miss
  //misses
];

// node_modules/compromise/src/1-one/tokenize/model/abbreviations/months.js
var months_default = ["jan", "feb", "mar", "apr", "jun", "jul", "aug", "sep", "sept", "oct", "nov", "dec"];

// node_modules/compromise/src/1-one/tokenize/model/abbreviations/nouns.js
var nouns_default = [
  "ad",
  "al",
  "arc",
  "ba",
  "bl",
  "ca",
  "cca",
  "col",
  "corp",
  "ft",
  "fy",
  "ie",
  "lit",
  "ma",
  "md",
  "pd",
  "tce"
];

// node_modules/compromise/src/1-one/tokenize/model/abbreviations/organizations.js
var organizations_default = ["dept", "univ", "assn", "bros", "inc", "ltd", "co"];

// node_modules/compromise/src/1-one/tokenize/model/abbreviations/places.js
var places_default = [
  "rd",
  "st",
  "dist",
  "mt",
  "ave",
  "blvd",
  "cl",
  // 'ct',
  "cres",
  "hwy",
  //states
  "ariz",
  "cal",
  "calif",
  "colo",
  "conn",
  "fla",
  "fl",
  "ga",
  "ida",
  "ia",
  "kan",
  "kans",
  "minn",
  "neb",
  "nebr",
  "okla",
  "penna",
  "penn",
  "pa",
  "dak",
  "tenn",
  "tex",
  "ut",
  "vt",
  "va",
  "wis",
  "wisc",
  "wy",
  "wyo",
  "usafa",
  "alta",
  "ont",
  "que",
  "sask"
];

// node_modules/compromise/src/1-one/tokenize/model/abbreviations/units.js
var units_default = [
  "dl",
  "ml",
  "gal",
  // 'ft', //ambiguous
  "qt",
  "pt",
  "tbl",
  "tsp",
  "tbsp",
  "km",
  "dm",
  //decimeter
  "cm",
  "mm",
  "mi",
  "td",
  "hr",
  //hour
  "hrs",
  //hour
  "kg",
  "hg",
  "dg",
  //decigram
  "cg",
  //centigram
  "mg",
  //milligram
  "\xB5g",
  //microgram
  "lb",
  //pound
  "oz",
  //ounce
  "sq ft",
  "hz",
  //hertz
  "mps",
  //meters per second
  "mph",
  "kmph",
  //kilometers per hour
  "kb",
  //kilobyte
  "mb",
  //megabyte
  // 'gb', //ambig
  "tb",
  //terabyte
  "lx",
  //lux
  "lm",
  //lumen
  // 'pa', //ambig
  "fl oz",
  //
  "yb"
];

// node_modules/compromise/src/1-one/tokenize/model/lexicon.js
var list = [
  [misc_default],
  [units_default, "Unit"],
  [nouns_default, "Noun"],
  [honorifics_default, "Honorific"],
  [months_default, "Month"],
  [organizations_default, "Organization"],
  [places_default, "Place"]
];
var abbreviations = {};
var lexicon2 = {};
list.forEach((a2) => {
  a2[0].forEach((w) => {
    abbreviations[w] = true;
    lexicon2[w] = "Abbreviation";
    if (a2[1] !== void 0) {
      lexicon2[w] = [lexicon2[w], a2[1]];
    }
  });
});

// node_modules/compromise/src/1-one/tokenize/model/prefixes.js
var prefixes_default = [
  "anti",
  "bi",
  "co",
  "contra",
  "de",
  "extra",
  "infra",
  "inter",
  "intra",
  "macro",
  "micro",
  "mis",
  "mono",
  "multi",
  "peri",
  "pre",
  "pro",
  "proto",
  "pseudo",
  "re",
  "sub",
  "supra",
  "trans",
  "tri",
  "un",
  "out",
  //out-lived
  "ex"
  //ex-wife
  // 'counter',
  // 'mid',
  // 'out',
  // 'non',
  // 'over',
  // 'post',
  // 'semi',
  // 'super', //'super-cool'
  // 'ultra', //'ulta-cool'
  // 'under',
  // 'whole',
].reduce((h2, str) => {
  h2[str] = true;
  return h2;
}, {});

// node_modules/compromise/src/1-one/tokenize/model/suffixes.js
var suffixes_default = {
  "like": true,
  "ish": true,
  "less": true,
  "able": true,
  "elect": true,
  "type": true,
  "designate": true
  // 'fold':true,
};

// node_modules/compromise/src/1-one/tokenize/model/unicode.js
var compact = {
  "!": "\xA1",
  "?": "\xBF\u0241",
  '"': '\u201C\u201D"\u275D\u275E',
  "'": "\u2018\u201B\u275B\u275C\u2019",
  "-": "\u2014\u2013",
  a: "\xAA\xC0\xC1\xC2\xC3\xC4\xC5\xE0\xE1\xE2\xE3\xE4\xE5\u0100\u0101\u0102\u0103\u0104\u0105\u01CD\u01CE\u01DE\u01DF\u01E0\u01E1\u01FA\u01FB\u0200\u0201\u0202\u0203\u0226\u0227\u023A\u0386\u0391\u0394\u039B\u03AC\u03B1\u03BB\u0410\u0430\u0466\u0467\u04D0\u04D1\u04D2\u04D3\u019B\xE6",
  b: "\xDF\xFE\u0180\u0181\u0182\u0183\u0184\u0185\u0243\u0392\u03B2\u03D0\u03E6\u0411\u0412\u042A\u042C\u0432\u044A\u044C\u0462\u0463\u048C\u048D",
  c: "\xA2\xA9\xC7\xE7\u0106\u0107\u0108\u0109\u010A\u010B\u010C\u010D\u0186\u0187\u0188\u023B\u023C\u037B\u037C\u03F2\u03F9\u03FD\u03FE\u0421\u0441\u0454\u0480\u0481\u04AA\u04AB",
  d: "\xD0\u010E\u010F\u0110\u0111\u0189\u018A\u0221\u018B\u018C",
  e: "\xC8\xC9\xCA\xCB\xE8\xE9\xEA\xEB\u0112\u0113\u0114\u0115\u0116\u0117\u0118\u0119\u011A\u011B\u0190\u0204\u0205\u0206\u0207\u0228\u0229\u0246\u0247\u0388\u0395\u039E\u03A3\u03AD\u03B5\u03BE\u03F5\u0400\u0401\u0415\u0435\u0450\u0451\u04BC\u04BD\u04BE\u04BF\u04D6\u04D7\u1EC5",
  f: "\u0191\u0192\u03DC\u03DD\u04FA\u04FB\u0492\u0493\u017F",
  g: "\u011C\u011D\u011E\u011F\u0120\u0121\u0122\u0123\u0193\u01E4\u01E5\u01E6\u01E7\u01F4\u01F5",
  h: "\u0124\u0125\u0126\u0127\u0195\u01F6\u021E\u021F\u0389\u0397\u0402\u040A\u040B\u041D\u043D\u0452\u045B\u04A2\u04A3\u04A4\u04A5\u04BA\u04BB\u04C9\u04CA",
  I: "\xCC\xCD\xCE\xCF",
  i: "\xEC\xED\xEE\xEF\u0128\u0129\u012A\u012B\u012C\u012D\u012E\u012F\u0130\u0131\u0196\u0197\u0208\u0209\u020A\u020B\u038A\u0390\u03AA\u03AF\u03B9\u03CA\u0406\u0407\u0456\u0457i\u0307",
  j: "\u0134\u0135\u01F0\u0237\u0248\u0249\u03F3\u0408\u0458",
  k: "\u0136\u0137\u0138\u0198\u0199\u01E8\u01E9\u039A\u03BA\u040C\u0416\u041A\u0436\u043A\u045C\u049A\u049B\u049C\u049D\u049E\u049F\u04A0\u04A1",
  l: "\u0139\u013A\u013B\u013C\u013D\u013E\u013F\u0140\u0141\u0142\u019A\u01AA\u01C0\u01CF\u01D0\u0234\u023D\u0399\u04C0\u04CF",
  m: "\u039C\u03FA\u03FB\u041C\u043C\u04CD\u04CE",
  n: "\xD1\xF1\u0143\u0144\u0145\u0146\u0147\u0148\u0149\u014A\u014B\u019D\u019E\u01F8\u01F9\u0220\u0235\u039D\u03A0\u03AE\u03B7\u03DE\u040D\u0418\u0419\u041B\u041F\u0438\u0439\u043B\u043F\u045D\u048A\u048B\u04C5\u04C6\u04E2\u04E3\u04E4\u04E5\u03C0",
  o: "\xD2\xD3\xD4\xD5\xD6\xD8\xF0\xF2\xF3\xF4\xF5\xF6\xF8\u014C\u014D\u014E\u014F\u0150\u0151\u019F\u01A0\u01A1\u01D1\u01D2\u01EA\u01EB\u01EC\u01ED\u01FE\u01FF\u020C\u020D\u020E\u020F\u022A\u022B\u022C\u022D\u022E\u022F\u0230\u0231\u038C\u0398\u039F\u03B8\u03BF\u03C3\u03CC\u03D5\u03D8\u03D9\u03EC\u03F4\u041E\u0424\u043E\u0472\u0473\u04E6\u04E7\u04E8\u04E9\u04EA\u04EB",
  p: "\u01A4\u03A1\u03C1\u03F7\u03F8\u03FC\u0420\u0440\u048E\u048F\xDE",
  q: "\u024A\u024B",
  r: "\u0154\u0155\u0156\u0157\u0158\u0159\u01A6\u0210\u0211\u0212\u0213\u024C\u024D\u0403\u0413\u042F\u0433\u044F\u0453\u0490\u0491",
  s: "\u015A\u015B\u015C\u015D\u015E\u015F\u0160\u0161\u01A7\u01A8\u0218\u0219\u023F\u0405\u0455",
  t: "\u0162\u0163\u0164\u0165\u0166\u0167\u01AB\u01AC\u01AD\u01AE\u021A\u021B\u0236\u023E\u0393\u03A4\u03C4\u03EE\u0422\u0442",
  u: "\xD9\xDA\xDB\xDC\xF9\xFA\xFB\xFC\u0168\u0169\u016A\u016B\u016C\u016D\u016E\u016F\u0170\u0171\u0172\u0173\u01AF\u01B0\u01B1\u01B2\u01D3\u01D4\u01D5\u01D6\u01D7\u01D8\u01D9\u01DA\u01DB\u01DC\u0214\u0215\u0216\u0217\u0244\u03B0\u03C5\u03CB\u03CD",
  v: "\u03BD\u0474\u0475\u0476\u0477",
  w: "\u0174\u0175\u019C\u03C9\u03CE\u03D6\u03E2\u03E3\u0428\u0429\u0448\u0449\u0461\u047F",
  x: "\xD7\u03A7\u03C7\u03D7\u03F0\u0425\u0445\u04B2\u04B3\u04FC\u04FD\u04FE\u04FF",
  y: "\xDD\xFD\xFF\u0176\u0177\u0178\u01B3\u01B4\u0232\u0233\u024E\u024F\u038E\u03A5\u03AB\u03B3\u03C8\u03D2\u03D3\u03D4\u040E\u0423\u0443\u0447\u045E\u0470\u0471\u04AE\u04AF\u04B0\u04B1\u04EE\u04EF\u04F0\u04F1\u04F2\u04F3",
  z: "\u0179\u017A\u017B\u017C\u017D\u017E\u01B5\u01B6\u0224\u0225\u0240\u0396"
};
var unicode = {};
Object.keys(compact).forEach(function(k2) {
  compact[k2].split("").forEach(function(s3) {
    unicode[s3] = k2;
  });
});
var unicode_default2 = unicode;

// node_modules/compromise/src/1-one/tokenize/model/punctuation.js
var prePunctuation = {
  "#": true,
  //#hastag
  "@": true,
  //@atmention
  "_": true,
  //underscore
  "\xB0": true,
  // '+': true,//+4
  // '\\-',//-4  (escape)
  // '.',//.4
  // zero-width chars
  "\u200B": true,
  "\u200C": true,
  "\u200D": true,
  "\uFEFF": true
};
var postPunctuation = {
  "%": true,
  //88%
  "_": true,
  //underscore
  "\xB0": true,
  //degrees, italian ordinal
  // '\'',// sometimes
  // zero-width chars
  "\u200B": true,
  "\u200C": true,
  "\u200D": true,
  "\uFEFF": true
};
var emoticons = {
  "<3": true,
  "</3": true,
  "<\\3": true,
  ":^P": true,
  ":^p": true,
  ":^O": true,
  ":^3": true
};

// node_modules/compromise/src/1-one/tokenize/model/index.js
var model_default2 = {
  one: {
    aliases: aliases_default,
    abbreviations,
    prefixes: prefixes_default,
    suffixes: suffixes_default,
    prePunctuation,
    postPunctuation,
    lexicon: lexicon2,
    //give this one forward
    unicode: unicode_default2,
    emoticons
  }
};

// node_modules/compromise/src/1-one/tokenize/compute/alias.js
var hasSlash = /\//;
var hasDomain = /[a-z]\.[a-z]/i;
var isMath = /[0-9]/;
var addAliases = function(term, world2) {
  let str = term.normal || term.text || term.machine;
  const aliases3 = world2.model.one.aliases;
  if (aliases3.hasOwnProperty(str)) {
    term.alias = term.alias || [];
    term.alias.push(aliases3[str]);
  }
  if (hasSlash.test(str) && !hasDomain.test(str) && !isMath.test(str)) {
    let arr = str.split(hasSlash);
    if (arr.length <= 3) {
      arr.forEach((word) => {
        word = word.trim();
        if (word !== "") {
          term.alias = term.alias || [];
          term.alias.push(word);
        }
      });
    }
  }
  return term;
};
var alias_default = addAliases;

// node_modules/compromise/src/1-one/tokenize/compute/machine.js
var hasDash3 = /^\p{Letter}+-\p{Letter}+$/u;
var doMachine = function(term) {
  let str = term.implicit || term.normal || term.text;
  str = str.replace(/[']s$/, "");
  str = str.replace(/s[']$/, "s");
  str = str.replace(/([aeiou][ktrp])in'$/, "$1ing");
  if (hasDash3.test(str)) {
    str = str.replace(/-/g, "");
  }
  str = str.replace(/^[#@]/, "");
  if (str !== term.normal) {
    term.machine = str;
  }
};
var machine_default = doMachine;

// node_modules/compromise/src/1-one/tokenize/compute/freq.js
var freq = function(view) {
  let docs = view.docs;
  let counts = {};
  for (let i3 = 0; i3 < docs.length; i3 += 1) {
    for (let t3 = 0; t3 < docs[i3].length; t3 += 1) {
      let term = docs[i3][t3];
      let word = term.machine || term.normal;
      counts[word] = counts[word] || 0;
      counts[word] += 1;
    }
  }
  for (let i3 = 0; i3 < docs.length; i3 += 1) {
    for (let t3 = 0; t3 < docs[i3].length; t3 += 1) {
      let term = docs[i3][t3];
      let word = term.machine || term.normal;
      term.freq = counts[word];
    }
  }
};
var freq_default = freq;

// node_modules/compromise/src/1-one/tokenize/compute/offset.js
var offset = function(view) {
  let elapsed = 0;
  let index4 = 0;
  let docs = view.document;
  for (let i3 = 0; i3 < docs.length; i3 += 1) {
    for (let t3 = 0; t3 < docs[i3].length; t3 += 1) {
      let term = docs[i3][t3];
      term.offset = {
        index: index4,
        start: elapsed + term.pre.length,
        length: term.text.length
      };
      elapsed += term.pre.length + term.text.length + term.post.length;
      index4 += 1;
    }
  }
};
var offset_default = offset;

// node_modules/compromise/src/1-one/tokenize/compute/reindex.js
var index3 = function(view) {
  let document2 = view.document;
  for (let n3 = 0; n3 < document2.length; n3 += 1) {
    for (let i3 = 0; i3 < document2[n3].length; i3 += 1) {
      document2[n3][i3].index = [n3, i3];
    }
  }
};
var reindex_default = index3;

// node_modules/compromise/src/1-one/tokenize/compute/wordCount.js
var wordCount2 = function(view) {
  let n3 = 0;
  let docs = view.docs;
  for (let i3 = 0; i3 < docs.length; i3 += 1) {
    for (let t3 = 0; t3 < docs[i3].length; t3 += 1) {
      if (docs[i3][t3].normal === "") {
        continue;
      }
      n3 += 1;
      docs[i3][t3].wordCount = n3;
    }
  }
};
var wordCount_default = wordCount2;

// node_modules/compromise/src/1-one/tokenize/compute/index.js
var termLoop = function(view, fn) {
  let docs = view.docs;
  for (let i3 = 0; i3 < docs.length; i3 += 1) {
    for (let t3 = 0; t3 < docs[i3].length; t3 += 1) {
      fn(docs[i3][t3], view.world);
    }
  }
};
var methods16 = {
  alias: (view) => termLoop(view, alias_default),
  machine: (view) => termLoop(view, machine_default),
  normal: (view) => termLoop(view, normal_default),
  freq: freq_default,
  offset: offset_default,
  index: reindex_default,
  wordCount: wordCount_default
};
var compute_default7 = methods16;

// node_modules/compromise/src/1-one/tokenize/plugin.js
var plugin_default12 = {
  compute: compute_default7,
  methods: methods_default8,
  model: model_default2,
  hooks: ["alias", "machine", "index", "id"]
};

// node_modules/compromise/src/1-one/typeahead/compute.js
var typeahead = function(view) {
  const prefixes2 = view.model.one.typeahead;
  const docs = view.docs;
  if (docs.length === 0 || Object.keys(prefixes2).length === 0) {
    return;
  }
  let lastPhrase = docs[docs.length - 1] || [];
  let lastTerm = lastPhrase[lastPhrase.length - 1];
  if (lastTerm.post) {
    return;
  }
  if (prefixes2.hasOwnProperty(lastTerm.normal)) {
    let found = prefixes2[lastTerm.normal];
    lastTerm.implicit = found;
    lastTerm.machine = found;
    lastTerm.typeahead = true;
    if (view.compute.preTagger) {
      view.last().unTag("*").compute(["lexicon", "preTagger"]);
    }
  }
};
var compute_default8 = { typeahead };

// node_modules/compromise/src/1-one/typeahead/api.js
var autoFill = function() {
  const docs = this.docs;
  if (docs.length === 0) {
    return this;
  }
  let lastPhrase = docs[docs.length - 1] || [];
  let term = lastPhrase[lastPhrase.length - 1];
  if (term.typeahead === true && term.machine) {
    term.text = term.machine;
    term.normal = term.machine;
  }
  return this;
};
var api2 = function(View2) {
  View2.prototype.autoFill = autoFill;
};
var api_default9 = api2;

// node_modules/compromise/src/1-one/typeahead/lib/allPrefixes.js
var getPrefixes = function(arr, opts2, world2) {
  let index4 = {};
  let collisions = [];
  let existing = world2.prefixes || {};
  arr.forEach((str) => {
    str = str.toLowerCase().trim();
    let max3 = str.length;
    if (opts2.max && max3 > opts2.max) {
      max3 = opts2.max;
    }
    for (let size = opts2.min; size < max3; size += 1) {
      let prefix5 = str.substring(0, size);
      if (opts2.safe && world2.model.one.lexicon.hasOwnProperty(prefix5)) {
        continue;
      }
      if (existing.hasOwnProperty(prefix5) === true) {
        collisions.push(prefix5);
        continue;
      }
      if (index4.hasOwnProperty(prefix5) === true) {
        collisions.push(prefix5);
        continue;
      }
      index4[prefix5] = str;
    }
  });
  index4 = Object.assign({}, existing, index4);
  collisions.forEach((str) => {
    delete index4[str];
  });
  return index4;
};
var allPrefixes_default = getPrefixes;

// node_modules/compromise/src/1-one/typeahead/lib/index.js
var isObject7 = (val) => {
  return Object.prototype.toString.call(val) === "[object Object]";
};
var defaults2 = {
  safe: true,
  min: 3
};
var prepare = function(words = [], opts2 = {}) {
  let model5 = this.model();
  opts2 = Object.assign({}, defaults2, opts2);
  if (isObject7(words)) {
    Object.assign(model5.one.lexicon, words);
    words = Object.keys(words);
  }
  let prefixes2 = allPrefixes_default(words, opts2, this.world());
  Object.keys(prefixes2).forEach((str) => {
    if (model5.one.typeahead.hasOwnProperty(str)) {
      delete model5.one.typeahead[str];
      return;
    }
    model5.one.typeahead[str] = prefixes2[str];
  });
  return this;
};
var lib_default5 = {
  typeahead: prepare
};

// node_modules/compromise/src/1-one/typeahead/plugin.js
var model3 = {
  one: {
    typeahead: {}
    //set a blank key-val
  }
};
var plugin_default13 = {
  model: model3,
  api: api_default9,
  lib: lib_default5,
  compute: compute_default8,
  hooks: ["typeahead"]
};

// node_modules/compromise/src/one.js
nlp_default.extend(plugin_default2);
nlp_default.extend(plugin_default8);
nlp_default.extend(plugin_default7);
nlp_default.extend(plugin_default9);
nlp_default.extend(plugin_default11);
nlp_default.plugin(plugin_default3);
nlp_default.extend(plugin_default12);
nlp_default.extend(plugin_default4);
nlp_default.plugin(plugin_default);
nlp_default.extend(plugin_default6);
nlp_default.extend(plugin_default13);
nlp_default.extend(plugin_default5);
nlp_default.extend(plugin_default10);
var one_default = nlp_default;

// node_modules/compromise/src/2-two/preTagger/model/irregulars/plurals.js
var plurals_default = {
  // -a
  addendum: "addenda",
  corpus: "corpora",
  criterion: "criteria",
  curriculum: "curricula",
  genus: "genera",
  memorandum: "memoranda",
  opus: "opera",
  ovum: "ova",
  phenomenon: "phenomena",
  referendum: "referenda",
  // -ae
  alga: "algae",
  alumna: "alumnae",
  antenna: "antennae",
  formula: "formulae",
  larva: "larvae",
  nebula: "nebulae",
  vertebra: "vertebrae",
  // -is
  analysis: "analyses",
  axis: "axes",
  diagnosis: "diagnoses",
  parenthesis: "parentheses",
  prognosis: "prognoses",
  synopsis: "synopses",
  thesis: "theses",
  neurosis: "neuroses",
  // -x
  appendix: "appendices",
  index: "indices",
  matrix: "matrices",
  ox: "oxen",
  sex: "sexes",
  // -i
  alumnus: "alumni",
  bacillus: "bacilli",
  cactus: "cacti",
  fungus: "fungi",
  hippopotamus: "hippopotami",
  libretto: "libretti",
  modulus: "moduli",
  nucleus: "nuclei",
  octopus: "octopi",
  radius: "radii",
  stimulus: "stimuli",
  syllabus: "syllabi",
  // -ie
  cookie: "cookies",
  calorie: "calories",
  auntie: "aunties",
  movie: "movies",
  pie: "pies",
  rookie: "rookies",
  tie: "ties",
  zombie: "zombies",
  // -f
  leaf: "leaves",
  loaf: "loaves",
  thief: "thieves",
  // ee-
  foot: "feet",
  goose: "geese",
  tooth: "teeth",
  // -eaux
  beau: "beaux",
  chateau: "chateaux",
  tableau: "tableaux",
  // -ses
  bus: "buses",
  gas: "gases",
  circus: "circuses",
  crisis: "crises",
  virus: "viruses",
  database: "databases",
  excuse: "excuses",
  abuse: "abuses",
  avocado: "avocados",
  barracks: "barracks",
  child: "children",
  clothes: "clothes",
  echo: "echoes",
  embargo: "embargoes",
  epoch: "epochs",
  deer: "deer",
  halo: "halos",
  man: "men",
  woman: "women",
  mosquito: "mosquitoes",
  mouse: "mice",
  person: "people",
  quiz: "quizzes",
  rodeo: "rodeos",
  shoe: "shoes",
  sombrero: "sombreros",
  stomach: "stomachs",
  tornado: "tornados",
  tuxedo: "tuxedos",
  volcano: "volcanoes"
};

// node_modules/compromise/src/2-two/preTagger/model/lexicon/_data.js
var data_default = {
  "Comparative": "true\xA6bett1f0;arth0ew0in0;er",
  "Superlative": "true\xA6earlier",
  "PresentTense": "true\xA6bests,sounds",
  "Condition": "true\xA6lest,unless",
  "PastTense": "true\xA6began,came,d4had,kneel3l2m0sa4we1;ea0sg2;nt;eap0i0;ed;id",
  "Participle": "true\xA60:09;a06b01cZdXeat0fSgQhPoJprov0rHs7t6u4w1;ak0ithdra02o2r1;i02uY;k0v0;nd1pr04;ergoJoJ;ak0hHo3;e9h7lain,o6p5t4un3w1;o1um;rn;g,k;ol0reS;iQok0;ught,wn;ak0o1runk;ne,wn;en,wn;ewriNi1uJ;dd0s0;ut3ver1;do4se0t1;ak0h2;do2g1;roG;ne;ast0i7;iv0o1;ne,tt0;all0loBor1;bi3g2s1;ak0e0;iv0o9;dd0;ove,r1;a5eamt,iv0;hos0lu1;ng;e4i3lo2ui1;lt;wn;tt0;at0en,gun;r2w1;ak0ok0;is0;en",
  "Gerund": "true\xA6accord0be0doin,go0result0stain0;ing",
  "Expression": "true\xA6a0Yb0Uc0Sd0Oe0Mfarew0Lg0FhZjeez,lWmVnToOpLsJtIuFvEw7y0;a5e3i1u0;ck,p;k04p0;ee,pee;a0p,s;!h;!a,h,y;a5h2o1t0;af,f;rd up,w;atsoever,e1o0;a,ops;e,w;hoo,t;ery w06oi0L;gh,h0;! 0h,m;huh,oh;here nPsk,ut tut;h0ic;eesh,hh,it,oo;ff,h1l0ow,sst;ease,s,z;ew,ooey;h1i,mg,o0uch,w,y;h,o,ps;! 0h;hTmy go0wT;d,sh;a7evertheless,o0;!pe;eh,mm;ah,eh,m1ol0;!s;ao,fao;aCeBi9o2u0;h,mph,rra0zzC;h,y;l1o0;r6y9;la,y0;! 0;c1moCsmok0;es;ow;!p hip hoor0;ay;ck,e,llo,y;ha1i,lleluj0;ah;!ha;ah,ee4o1r0;eat scott,r;l1od0sh; grief,bye;ly;! whiz;ell;e0h,t cetera,ureka,ww,xcuse me;k,p;'oh,a0rat,uh;m0ng;mit,n0;!it;mon,o0;ngratulations,wabunga;a2oo1r0tw,ye;avo,r;!ya;h,m; 1h0ka,las,men,rgh,ye;!a,em,h,oy;la",
  "Negative": "true\xA6n0;ever,o0;n,t",
  "QuestionWord": "true\xA6how3wh0;at,e1ich,o0y;!m,se;n,re; come,'s",
  "Reflexive": "true\xA6h4it5my5o1the0your2;ir1m1;ne3ur0;sel0;f,ves;er0im0;self",
  "Plural": "true\xA6dick0gre0ones,records;ens",
  "Unit|Noun": "true\xA6cEfDgChBinchAk9lb,m6newt5oz,p4qt,t1y0;ardEd;able1b0ea1sp;!l,sp;spo1;a,t,x;on9;!b,g,i1l,m,p0;h,s;!les;!b,elvin,g,m;!es;g,z;al,b;eet,oot,t;m,up0;!s",
  "Value": "true\xA6a few",
  "Imperative": "true\xA6bewa0come he0;re",
  "Plural|Verb": "true\xA6leaves",
  "Demonym": "true\xA60:15;1:12;a0Vb0Oc0Dd0Ce08f07g04h02iYjVkTlPmLnIomHpEqatari,rCs7t5u4v3welAz2;am0Gimbabwe0;enezuel0ietnam0I;gAkrai1;aiwTex0hai,rinida0Ju2;ni0Prkmen;a5cotti4e3ingapoOlovak,oma0Spaniard,udRw2y0W;ede,iss;negal0Cr09;sh;mo0uT;o5us0Jw2;and0;a2eru0Fhilippi0Nortugu07uerto r0S;kist3lesti1na2raguay0;ma1;ani;ami00i2orweP;caragu0geri2;an,en;a3ex0Lo2;ngo0Drocc0;cedo1la2;gasy,y07;a4eb9i2;b2thua1;e0Cy0;o,t01;azakh,eny0o2uwaiI;re0;a2orda1;ma0Ap2;anO;celandic,nd4r2sraeli,ta01vo05;a2iB;ni0qi;i0oneU;aiAin2ondur0unO;di;amEe2hanai0reek,uatemal0;or2rm0;gi0;ilipino,ren8;cuadoVgyp4mira3ngli2sto1thiopi0urope0;shm0;ti;ti0;aPominUut3;a9h6o4roat3ub0ze2;ch;!i0;lom2ngol5;bi0;a6i2;le0n2;ese;lifor1m2na3;bo2eroo1;di0;angladeshi,el6o4r3ul2;gaE;azi9it;li2s1;vi0;aru2gi0;si0;fAl7merBngol0r5si0us2;sie,tr2;a2i0;li0;genti2me1;ne;ba1ge2;ri0;ni0;gh0r2;ic0;an",
  "Organization": "true\xA60:4Q;a3Tb3Bc2Od2He2Df27g1Zh1Ti1Pj1Nk1Ll1Gm12n0Po0Mp0Cqu0Br02sTtHuCv9w3xiaomi,y1;amaha,m1Bou1w1B;gov,tu3C;a4e2iki1orld trade organizati33;leaRped0O;lls fargo,st1;fie2Hinghou2R;l1rner br3U;gree3Jl street journ2Im1E;an halOeriz2Xisa,o1;dafo2Yl1;kswagMvo;b4kip,n2ps,s1;a tod3Aps;es3Mi1;lev3Fted natio3C;er,s; mobi32aco beRd bOe9gi frida3Lh3im horto3Amz,o1witt3D;shi49y1;ota,s r 05;e 1in lizzy;b3carpen3Jdaily ma3Dguess w2holli0s1w2;mashing pumpki35uprem0;ho;ea1lack eyed pe3Xyr0Q;ch bo3Dtl0;l2n3Qs1xas instrumen1U;co,la m1F;efoni0Kus;a8cientology,e5ieme2Ymirnoff,np,o3pice gir6quare0Ata1ubaru;rbuc1to34;ks;ny,undgard1;en;a2x pisto1;ls;g1Wrs;few2Minsbur31lesfor03msu2E;adiohead,b8e4o1yana3C;man empi1Xyal 1;b1dutch she4;ank;a3d 1max,vl20;bu1c2Ahot chili peppe2Ylobst2N;ll;ders dige1Ll madrid;c,s;ant3Aizn2Q;a8bs,e5fiz2Ihilip4i3r1;emier 1udenti1D;leagTo2K;nk floyd,zza hut; morrBs;psi2tro1uge0E;br33chi0Tn33;!co;lant2Un1yp16; 2ason27da2P;ld navy,pec,range juli2xf1;am;us;aAb9e6fl,h5i4o1sa,vid3wa;k2tre dame,vart1;is;ia;ke,ntendo,ss0QvZ;l,s;c,st1Otflix,w1; 1sweek;kids on the block,york0D;a,c;nd22s2t1;ional aca2Po,we0U;a,c02d0S;aDcdonalCe9i6lb,o3tv,y1;spa1;ce;b1Tnsanto,ody blu0t1;ley cr1or0T;ue;c2t1;as,subisO;helin,rosoft;dica2rcedes benz,talli1;ca;id,re;ds;cs milk,tt19z24;a3e1g,ittle caesa1P; ore09novo,x1;is,mark,us; 1bour party;pres0Dz boy;atv,fc,kk,lm,m1od1O;art;iffy lu0Roy divisi0Jpmorgan1sa;! cha09;bm,hop,k3n1tv;g,te1;l,rpol;ea;a5ewlett pack1Vi3o1sbc,yundai;me dep1n1P;ot;tac1zbollah;hi;lliburt08sbro;eneral 6hq,ithub,l5mb,o2reen d0Ou1;cci,ns n ros0;ldman sachs,o1;dye1g0H;ar;axo smith kli04encoW;electr0Nm1;oto0Z;a5bi,c barcelo4da,edex,i2leetwood m03o1rito l0G;rd,xcY;at,fa,nancial1restoZ; tim0;na;cebook,nnie mae;b0Asa,u3xxon1; m1m1;ob0J;!rosceptics;aiml0De5isney,o4u1;nkin donu2po0Zran dur1;an;ts;j,w jon0;a,f lepp12ll,peche mode,r spieg02stiny's chi1;ld;aJbc,hFiDloudflaCnn,o3r1;aigsli5eedence clearwater reviv1ossra09;al;c7inba6l4m1o0Est09;ca2p1;aq;st;dplSg1;ate;se;a c1o chanQ;ola;re;a,sco1tigroup;! systems;ev2i1;ck fil a,na daily;r1y;on;d2pital o1rls jr;ne;bury,ill1;ac;aEbc,eBf9l5mw,ni,o1p,rexiteeU;ei3mbardiIston 1;glo1pizza;be;ng;o2ue c1;roV;ckbuster video,omingda1;le; g1g1;oodriL;cht2e ge0rkshire hathaw1;ay;el;cardi,idu,nana republ3s1xt5y5;f,kin robbi1;ns;ic;bYcTdidSerosmith,iRlKmEnheuser busDol,ppleAr6s4u3v2y1;er;is,on;di,todesk;hland o1sociated E;il;b3g2m1;co;os;ys; compu1be0;te1;rs;ch;c,d,erican3t1;!r1;ak; ex1;pre1;ss; 5catel2ta1;ir;! lu1;ce1;nt;jazeera,qae1;da;g,rbnb;as;/dc,a3er,tivision1;! blizz1;ard;demy of scienc0;es;ba",
  "Possessive": "true\xA6its,my,our0thy;!s",
  "Noun|Verb": "true\xA60:9W;1:AA;2:96;3:A3;4:9R;5:A2;6:9K;7:8N;8:7L;9:A8;A:93;B:8D;C:8X;a9Ob8Qc7Id6Re6Gf5Sg5Hh55i4Xj4Uk4Rl4Em40n3Vo3Sp2Squ2Rr21s0Jt02u00vVwGyFzD;ip,oD;ne,om;awn,e6Fie68;aOeMhJiHoErD;ap,e9Oink2;nd0rDuC;kDry,sh5Hth;!shop;ck,nDpe,re,sh;!d,g;e86iD;p,sD;k,p0t2;aDed,lco8W;r,th0;it,lk,rEsDt4ve,x;h,te;!ehou1ra9;aGen5FiFoD;iDmAte,w;ce,d;be,ew,sA;cuum,l4B;pDr7;da5gra6Elo6A;aReQhrPiOoMrGuEwiDy5Z;n,st;nDrn;e,n7O;aGeFiEoDu6;t,ub2;bu5ck4Jgg0m,p;at,k,nd;ck,de,in,nsDp,v7J;f0i8R;ll,ne,p,r4Yss,t94uD;ch,r;ck,de,e,le,me,p,re;e5Wow,u6;ar,e,ll,mp0st,xt;g,lDng2rg7Ps5x;k,ly;a0Sc0Ne0Kh0Fi0Dk0Cl0Am08n06o05pXquaBtKuFwD;ea88iD;ng,pe,t4;bGit,m,ppErD;fa3ge,pri1v2U;lDo6S;e6Py;!je8;aMeLiKoHrEuDy2;dy,ff,mb2;a85eEiDo5Pugg2;ke,ng;am,ss,t4;ckEop,p,rD;e,m;ing,pi2;ck,nk,t4;er,m,p;ck,ff,ge,in,ke,lEmp,nd,p2rDte,y;!e,t;k,l;aJeIiHlGoFrDur,y;ay,e56inDu3;g,k2;ns8Bt;a5Qit;ll,n,r87te;ed,ll;m,n,rk;b,uC;aDee1Tow;ke,p;a5Je4FiDo53;le,rk;eep,iDou4;ce,p,t;ateboa7Ii;de,gnDl2Vnk,p,ze;!al;aGeFiEoDuff2;ck,p,re,w;ft,p,v0;d,i3Ylt0;ck,de,pe,re,ve;aEed,nDrv1It;se,t2N;l,r4t;aGhedu2oBrD;aEeDibb2o3Z;en,w;pe,t4;le,n,r2M;cDfegua72il,mp2;k,rifi3;aZeHhy6LiGoEuD;b,in,le,n,s5X;a6ck,ll,oDpe,u5;f,t;de,ng,ot,p,s1W;aTcSdo,el,fQgPje8lOmMnLo17pJque6sFturn,vDwa6V;eDi27;al,r1;er74oFpe8tEuD;lt,me;!a55;l71rt;air,eaDly,o53;l,t;dezvo2Zt;aDedy;ke,rk;ea1i4G;a6Iist0r5N;act6Yer1Vo71uD;nd,se;a38o6F;ch,s6G;c1Dge,iEke,lly,nDp1Wt1W;ge,k,t;n,se;es6Biv0;a04e00hYiXlToNrEsy4uD;mp,n4rcha1sh;aKeIiHoDu4O;be,ceFdu3fi2grDje8mi1p,te6;amDe6W;!me;ed,ss;ce,de,nt;sDy;er6Cs;cti3i1;iHlFoEp,re,sDuCw0;e,i5Yt;l,p;iDl;ce,sh;nt,s5V;aEce,e32uD;g,mp,n7;ce,nDy;!t;ck,le,n17pe,tNvot;a1oD;ne,tograph;ak,eFnErDt;fu55mA;!c32;!l,r;ckJiInHrFsEtDu1y;ch,e9;s,te;k,tD;!y;!ic;nt,r,se;!a7;bje8ff0il,oErDutli3Qver4B;bAd0ie9;ze;a4ReFoDur1;d,tD;e,i3;ed,gle8tD;!work;aMeKiIoEuD;rd0;ck,d3Rld,nEp,uDve;nt,th;it5EkD;ey;lk,n4Brr5CsDx;s,ta2B;asuBn4UrDss;ge,it;il,nFp,rk3WsEtD;ch,t0;h,k,t0;da5n0oeuvB;aLeJiHoEuD;mp,st;aEbby,ck,g,oDve;k,t;d,n;cDe,ft,mAnIst;en1k;aDc0Pe4vK;ch,d,k,p,se;bFcEnd,p,t4uD;gh,n4;e,k;el,o2U;eEiDno4E;ck,d,ll,ss;el,y;aEo1OuD;i3mp;m,zz;mpJnEr46ssD;ue;c1Rdex,fluGha2k,se2HteDvoi3;nt,rD;e6fa3viD;ew;en3;a8le2A;aJeHiGoEuD;g,nt;l3Ano2Dok,pDr1u1;!e;ghli1Fke,nt,re,t;aDd7lp;d,t;ck,mGndFrEsh,tDu9;ch,e;bo3Xm,ne4Eve6;!le;!m0;aMear,ift,lKossJrFuD;arDe4Alp,n;antee,d;aFiEoDumb2;uCwth;ll,nd,p;de,sp;ip;aBoDue;ss,w;g,in,me,ng,s,te,ze;aZeWiRlNoJrFuD;ck,el,nDss,zz;c38d;aEoDy;st,wn;cDgme,me,nchi1;tuB;cFg,il,ld,rD;ce,e29mDwa31;!at;us;aFe0Vip,oDy;at,ck,od,wD;!er;g,ke,me,re,sh,vo1E;eGgFlEnDre,sh,t,x;an3i0Q;e,m,t0;ht,uB;ld;aEeDn3;d,l;r,tuB;ce,il,ll,rm,vo2W;cho,d7ffe8nMsKxFyeD;!baD;ll;cGerci1hFpDtra8;eriDo0W;en3me9;au6ibA;el,han7u1;caDtima5;pe;count0d,vy;a01eSiMoJrEuDye;b,el,mp,pli2X;aGeFiEoD;ne,p;ft,ll,nk,p,ve;am,ss;ft,g,in;cEd7ubt,wnloD;ad;k,u0E;ge6p,sFt4vD;e,iDor3;de;char7gui1h,liEpD;at4lay,u5;ke;al,bKcJfeIlGmaCposAsEtaD;il;e07iD;gn,re;ay,ega5iD;ght;at,ct;li04rea1;a5ut;b,ma7n3rDte;e,t;a0Eent0Dh06irc2l03oKrFuD;be,e,rDt;b,e,l,ve;aGeFoEuDy;sh;p,ss,wd;dAep;ck,ft,sh;at,de,in,lTmMnFordina5py,re,st,uDv0;gh,nDp2rt;s01t;ceHdu8fli8glomeIsFtDveN;a8rD;a6ol;e9tru8;ct;ntDrn;ra5;bHfoGmFpD;leDouCromi1;me9;aCe9it,u5;rt;at,iD;ne;lap1oD;r,ur;aEiDoud,ub;ck,p;im,w;aEeDip;at,ck,er;iGllen7nErD;ge,m,t;ge,nD;el;n,r;er,re;ke,ll,mp,noe,pGrXsFtEuDve;se,ti0I;alog,ch;h,t;!tuB;re;a03eZiXlToPrHuEyD;pa11;bb2ck2dgEff0mp,rDst,zz;den,n;et;anJeHiFoadEuD;i1sh;ca6;be,d7;ge;aDed;ch,k;ch,d;aFg,mb,nEoDrd0tt2x,ycott;k,st,t;d,e;rd,st;aFeCiDoYur;nk,tz;nd;me;as,d,ke,nd,opsy,tD;!ch,e;aFef,lt,nDt;d,efA;it;r,t;ck,il,lan3nIrFsEtt2;le;e,h;!gDk;aDe;in;!d,g,k;bu1c05dZge,iYlVnTppQrLsIttGucEwaD;rd;tiD;on;aDempt;ck;k,sD;i6ocia5;st;chFmD;!oD;ur;!iD;ve;eEroa4;ch;al;chDg0sw0;or;aEt0;er;rm;d,m,r;dreHvD;an3oD;ca5;te;ce;ss;cDe,he,t;eFoD;rd,u9;nt;nt,ss;se",
  "Actor": "true\xA60:7B;1:7G;2:6A;3:7F;4:7O;5:7K;a6Nb62c4Ud4Be41f3Sg3Bh30i2Uj2Qkin2Pl2Km26n1Zo1Sp0Vqu0Tr0JsQtJuHvEw8yo6;gi,ut6;h,ub0;aAe9i8o7r6;estl0it0;m2rk0;fe,nn0t2Bza2H;atherm2ld0;ge earn0it0nder0rri1;eter7i6oyF;ll5Qp,s3Z;an,ina2U;n6s0;c6Uder03;aoisea23e9herapi5iktok0o8r6ut1yco6S;a6endseLo43;d0mp,nscri0Bvel0;ddl0u1G;a0Qchn7en6na4st0;ag0;i3Oo0D;aiXcUeRhPiMki0mu26oJpGquaFtBu7wee6;p0theart;lt2per7r6;f0ge6Iviv1;h6inten0Ist5Ivis1;ero,um2;a8ep7r6;ang0eam0;bro2Nc2Ofa2Nmo2Nsi20;ff0tesm2;tt0;ec7ir2Do6;kesp59u0M;ia5Jt3;l7me6An,rcere6ul;r,ss;di0oi5;n7s6;sy,t0;g0n0;am2ephe1Iow6;girl,m2r2Q;cretInior cit3Fr6;gea4v6;a4it1;hol4Xi7reen6ulpt1;wr2C;e01on;l1nt;aEe9o8u6;l0nn6;er up,ingE;g40le mod3Zof0;a4Zc8fug2Ppo32searQv6;ere4Uolution6;ary;e6luYru22;ptio3T;bbi,dic5Vpp0;arter6e2Z;back;aYeWhSiRlOoKr8sycho7u6;nk,p31;logi5;aGeDiBo6;d9fess1g7ph47s6;pe2Ktitu51;en6ramm0;it1y;igy,uc0;est4Nme mini0Unce6s3E;!ss;a7si6;de4;ch0;ctiti39nk0P;dca0Oet,li6pula50rnst42;c2Itic6;al scie6i2;nti5;a6umb0;nn0y6;er,ma4Lwright;lgrim,one0;a8iloso7otogra7ra6ysi1V;se;ph0;ntom,rmaci5;r6ssi1T;form0s4O;i3El,nel3Yr8st1tr6wn;i6on;arWot;ent4Wi42tn0;ccupa4ffBp8r7ut6;ca5l0B;ac4Iganiz0ig2Fph2;er3t6;i1Jomet6;ri5;ic0spring;aBe9ie4Xo7u6;n,rser3J;b6mad,vi4V;le2Vo4D;i6mesis,phew;ce,ghb1;nny,rr3t1X;aEeDiAo7u6yst1Y;m8si16;der3gul,m7n6th0;arDk;!my;ni7s6;f02s0Jt0;on,st0;chan1Qnt1rcha4;gi9k0n8rtyr,t6y1;e,riar6;ch;ag0iac;ci2stra3I;a7e2Aieutena4o6;rd,s0v0;bor0d7ndlo6ss,urea3Fwy0ym2;rd;!y;!s28;e8o7u6;ggl0;gg0urna2U;st0;c3Hdol,llu3Ummigra4n6; l9c1Qfa4habi42nov3s7ve6;nt1stig3;pe0Nt6;a1Fig3ru0M;aw;airFeBistoAo8u6ygie1K;man6sba2H;!ita8;bo,st6usekN;age,e3P;ri2;ir,r6;m7o6;!ine;it;dress0sty2C;aLeIhostGirl26ladi3oCrand7u6;e5ru;c9daug0Jfa8m7pa6s2Y;!re4;a,o6;th0;hi1B;al7d6lf0;!de3A;ie,k6te26;eep0;!wr6;it0;isha,n6;i6tl04;us;mbl0rden0;aDella,iAo7r6;eela2Nie1P;e,re6ster pare4;be1Hm2r6st0;unn0;an2ZgZlmm17nanci0r6tt0;e6st la2H; marsh2OfigXm2;rm0th0;conoEdDlectriCm8n7x6;amin0cellency,i2A;emy,trepreneur,vironmenta1J;c8p6;er1loye6;e,r;ee;ci2;it1;mi5;aKeBi8ork,ri7u6we02;de,tche2H;ft0v0;ct3eti7plom2Hre6va;ct1;ci2ti2;aDcor3fencCi0InAput9s7tectLvel6;op0;ce1Ge6ign0;rt0;ee,y;iz6;en;em2;c1Ml0;d8nc0redev7ug6;ht0;il;!dy;a06e04fo,hXitizenWlToBr9u6;r3stomer6;! representat6;ive;e3it6;ic;lJmGnAord9rpor1Nu7w6;boy,ork0;n6ri0;ciTte1Q;in3;fidantAgressSs9t6;e0Kr6;ibut1o6;ll0;tab13ul1O;!e;edi2m6pos0rade;a0EeQissi6;on0;leag8on7um6;ni5;el;ue;e6own;an0r6;ic,k;!s;a9e7i6um;ld;erle6f;ad0;ir7nce6plFract0;ll1;m2wI;lebri6o;ty;dBptAr6shi0;e7pe6;nt0;r,t6;ak0;ain;et;aMeLiJlogg0oErBu6;dd0Fild0rgl9siness6;m2p7w6;om2;ers05;ar;i7o6;!k0th0;cklay0de,gadi0;hemi2oge8y6;!frie6;nd;ym2;an;cyc6sR;li5;atbox0ings;by,nk0r6;b0on7te6;nd0;!e07;c04dWge4nQpLrHsFtAu7yatull6;ah;nt7t6;h1oG;!ie;h8t6;e6orney;nda4;ie5le6;te;sis00tron6;aut,om0;chbis8isto7tis6;an,t;crU;hop;ost9p6;ari6rentiS;ti6;on;le;a9cest1im3nou8y6;bo6;dy;nc0;ly5rc6;hi5;mi8v6;entur0is1;er;ni7r6;al;str3;at1;or;counBquaintanArob9t6;ivi5or,re6;ss;st;at;ce;ta4;nt",
  "Adj|Noun": "true\xA60:16;a1Db17c0Ud0Re0Mf0Dg0Ah08i06ju05l02mWnUoSpNrIsBt7u4v1watershed;a1ision0Z;gabo4nilla,ria1;b0Vnt;ndergr1pstairs;adua14ou1;nd;a3e1oken,ri0;en,r1;min0rori13;boo,n;age,e5ilv0Flack,o3quat,ta2u1well;bordina0Xper5;b0Lndard;ciali0Yl1vereign;e,ve16;cret,n1ri0;ior;a4e2ou1ubbiL;nd,tiY;ar,bBl0Wnt0p1side11;resent0Vublican;ci0Qsh;a4eriodic0last0Zotenti0r1;emi2incip0o1;!fession0;er,um;rall4st,tie0U;ff1pposi0Hv0;ens0Oi0C;agg01ov1uts;el;a5e3iniatJo1;bi01der07r1;al,t0;di1tr0N;an,um;le,riG;attOi2u1;sh;ber0ght,qC;stice,veniT;de0mpressioYn1;cumbe0Edividu0no0Dsta0Eterim;alf,o1umdrum;bby,melF;en2old,ra1;ph0Bve;er0ious;a7e5i4l3u1;git03t1;ure;uid;ne;llow,m1;aFiL;ir,t,vo1;riOuriO;l3p00x1;c1ecutUpeV;ess;d1iK;er;ar2e1;mographUrivO;k,l2;hiGlassSo2rude,unn1;ing;m5n1operK;creCstitueOte2vertab1;le;mpor1nt;ary;ic,m2p1;anion,lex;er2u1;ni8;ci0;al;e5lank,o4r1;i2u1;te;ef;ttom,urgeois;st;cadem9d6l2ntarct9r1;ab,ct8;e3tern1;at1;ive;rt;oles1ult;ce1;nt;ic",
  "Adj|Past": "true\xA60:4Q;1:4C;2:4H;3:4E;a44b3Tc36d2Je29f20g1Wh1Si1Jj1Gkno1Fl1Am15n12o0Xp0Mqu0Kr08sLtEuAv9w4yellow0;a7ea6o4rinkl0;r4u3Y;n,ri0;k31th3;rp0sh0tZ;ari0e1O;n5p4s0;d1li1Rset;cov3derstood,i4;fi0t0;a8e3Rhr7i6ouTr4urn0wi4C;a4imm0ou2G;ck0in0pp0;ed,r0;eat2Qi37;m0nn0r4;get0ni2T;aOcKeIhGimFm0Hoak0pDt7u4;bsid3Ogge44s4;pe4ta2Y;ct0nd0;a8e7i2Eok0r5u4;ff0mp0nn0;ength2Hip4;ed,p0;am0reotyp0;in0t0;eci4ik0oH;al3Efi0;pRul1;a4ock0ut;d0r0;a4c1Jle2t31;l0s3Ut0;a6or5r4;at4e25;ch0;r0tt3;t4ut0;is2Mur1;aEe5o4;tt0;cAdJf2Bg9je2l8m0Knew0p7qu6s4;eTpe2t4;or0ri2;e3Dir0;e1lac0;at0e2Q;i0Rul1;eiv0o4ycl0;mme2Lrd0v3;in0lli0ti2A;a4ot0;li28;aCer30iBlAo9r5u4;mp0zzl0;e6i2Oo4;ce2Fd4lo1Anou30pos0te2v0;uc0;fe1CocCp0Iss0;i2Kli1L;ann0e2CuS;ck0erc0ss0;ck0i2Hr4st0;allLk0;bse7c6pp13rgan2Dver4;lo4whelm0;ok0;cupi0;rv0;aJe5o4;t0uri1A;ed0gle2;a6e5ix0o4ut0ys1N;di1Nt15u26;as0Clt0;n4rk0;ag0ufact0A;e6i5o4;ad0ck0st,v0;cens0m04st0;ft,v4;el0;tt0wn;a5o15u4;dg0s1B;gg0;llumSmpAn4sol1;br0cre1Ldebt0f8jZspir0t5v4;it0olv0;e4ox0Y;gr1n4re23;d0si15;e2l1o1Wuri1;li0o01r4;ov0;a6e1o4um03;ok0r4;ri0Z;mm3rm0;i6r5u4;a1Bid0;a0Ui0Rown;ft0;aAe9i8l6oc0Ir4;a4i0oz0Y;ctHg19m0;avo0Ju4;st3;ni08tt0x0;ar0;d0il0sc4;in1;dCl1mBn9quipp0s8x4;agger1c6p4te0T;a0Se4os0;ct0rie1D;it0;cap0tabliZ;cha0XgFha1As4;ur0;a0Zbarra0N;i0Buc1;aMeDi5r4;a01i0;gni08miniSre2s4;a9c6grun0Ft4;o4re0Hu17;rt0;iplWou4;nt0r4;ag0;bl0;cBdRf9l8p7ra6t5v4;elop0ot0;ail0ermQ;ng0;re07;ay0ight0;e4in0o0M;rr0;ay0enTor1;m5t0z4;ed,zl0;ag0p4;en0;aPeLhIlHo9r6u4;lt4r0stom03;iv1;a5owd0u4;sh0;ck0mp0;d0loAm7n4ok0v3;centr1f5s4troC;id3olid1;us0;b5pl4;ic1;in0;r0ur0;assi9os0utt3;ar5i4;ll0;g0m0;lebr1n6r4;ti4;fi0;tralJ;g0lcul1;aDewild3iCl9o7r5urn4;ed,t;ok4uis0;en;il0r0t4und;tl0;e5i4;nd0;ss0;as0;ffl0k0laMs0tt3;bPcNdKfIg0lFmaz0nDppBrm0ss9u5wa4;rd0;g5thor4;iz0;me4;nt0;o6u4;m0r0;li0re4;ci1;im1ticip1;at0;a5leg0t3;er0;rm0;fe2;ct0;ju5o7va4;nc0;st0;ce4knowledg0;pt0;and5so4;rb0;on0;ed",
  "Singular": "true\xA60:5J;1:5H;2:4W;3:4S;4:52;5:57;6:5L;7:56;8:5B;a52b4Lc3Nd35e2Xf2Og2Jh28in24j23k22l1Um1Ln1Ho1Bp0Rqu0Qr0FsZtMuHvCw9x r58yo yo;a9ha3Po3Q;f3i4Rt0Gy9;! arou39;arCeAideo ga2Qo9;cabu4Jl5C;gOr9t;di4Zt1Y;iety,ni4P;nBp30rAs 9;do43s5E;bani1in0;coordinat3Ader9;estima1to24we41; rex,aKeJhHiFoErBuAv9;! show;m2On2rntLto1D;agedy,ib9o4E;e,u9;n0ta46;ni1p2rq3L;c,er,m9;etF;ing9ree26;!y;am,mp3F;ct2le6x return;aNcMeKhor4QiJkHoGpin off,tDuBy9;ll9ner7st4T;ab2X;b9i1n28per bowl,rro1X;st3Ltot0;atAipe2Go1Lrate7udent9;! lo0I;i39u1;ft ser4Lmeo1I;elet5i9;ll,r3V;b38gn2Tte;ab2Jc9min3B;t,urity gua2N;e6ho2Y;bbatic0la3Jndwi0Qpi5;av5eDhetor2iAo9;de6om,w;tAv9;erb2C;e,u0;bDcBf9publ2r10spi1;er9orm3;e6r0;i9ord label;p2Ht0;a1u46;estion mark,ot2F;aPeMhoLiIlGoErAu9yram1F;ddi3HpErpo1Js3J;eBo9;bl3Zs9;pe3Jta1;dic1Rmi1Fp1Qroga8ss relea1F;p9rt0;py;a9ebisci1;q2Dte;cn2eAg9;!gy;!r;ne call,tocoK;anut,dAr9t0yo1;cen3Jsp3K;al,est0;nop4rAt9;e,hog5;adi11i2V;atme0bj3FcBpia1rde0thers,utspok5ve9wn3;n,r9;ti0Pview;cuAe9;an;pi3;arBitAot9umb3;a2Fhi2R;e,ra1;cot2ra8;aFeCiAo9ur0;nopo4p18rni2Nsq1Rti36uld;c,li11n0As9tt5;chief,si34;dAnu,t9;al,i3;al,ic;gna1mm0nd15rsupi0te9yf4;ri0;aDegCiBu9;ddi1n9;ch;me,p09; Be0M;bor14y9; 9er;up;eyno1itt5;el4ourn0;cBdices,itia8ni25sAtel0Lvert9;eb1J;e28titu1;en8i2T;aIeEighDoAu9;man right,s22;me9rmoFsp1Ftb0K;! r9;un; scho0YriY;a9i1N;d9v5; start,pho9;ne;ndful,sh brown,v5ze;aBelat0Ilaci3r9ul4yp1S;an9enadi3id;a1Cd slam,ny;df4r9;l2ni1I;aGeti1HiFlu1oCrAun9;er0;ee market,i9onti3;ga1;l4ur9;so9;me;ePref4;br2mi4;conoFffi7gg,lecto0Rmbas1EnCpidem2s1Zth2venBxAyel9;id;ampZempl0Nte6;i19t;er7terp9;ri9;se;my;eLiEoBr9ump tru0U;agonf4i9;er,ve thru;cAg7i4or,ssi3wn9;side;to0EumenE;aEgniDnn3sAvide9;nd;conte6incen8p9tri11;osi9;ti0C;ta0H;le0X;athBcAf9ni0terre6;ault 05err0;al,im0;!b9;ed;aWeThMiLlJoDr9;edit caBuc9;ib9;le;rd;efficDke,lCmmuniqLnsApi3rr0t0Xus9yo1;in;erv9uI;ato02;ic,lQ;ie6;er7i9oth;e6n2;ty,vil wM;aDeqCick5ocoBr9;istmas car9ysanthemum;ol;la1;ue;ndeli3racteri9;st2;iAllEr9;e0tifica1;liZ;hi3nFpErCt9ucus;erpi9hedr0;ll9;ar;!bohyd9ri3;ra1;it0;aAe,nib0t9;on;l,ry;aMeLiop2leJoHrDu9;nny,r9tterf4;g9i0;la9;ry;eakAi9;ck;fa9throB;st;dy,ro9wl;ugh;mi9;sh;an,l4;nkiArri3;er;ng;cSdMlInFppeti1rDsBtt2utop9;sy;ic;ce6pe9;ct;r9sen0;ay;ecAoma4tiA;ly;do1;i5l9;er7y;gy;en; hominDjAvan9;tage;ec8;ti9;ve;em;cCeAqui9;tt0;ta1;te;iAru0;al;de6;nt",
  "Person|Noun": "true\xA6a0Eb07c03dWeUfQgOhLjHkiGlFmCnBolive,p7r4s3trini06v1wa0;ng,rd,tts;an,enus,iol0;a,et;ky,onPumm09;ay,e1o0uby;bin,d,se;ed,x;a2e1o0;l,tt04;aLnJ;dYge,tR;at,orm;a0eloW;t0x,ya;!s;a9eo,iH;ng,tP;a2e1o0;lGy;an,w3;de,smi4y;a0erb,iOolBuntR;ll,z0;el;ail,e0iLuy;ne;a1ern,i0lo;elds,nn;ith,n0;ny;a0dEmir,ula,ve;rl;a4e3i1j,ol0;ly;ck,x0;ie;an,ja;i0wn;sy;am,h0liff,rystal;a0in,ristian;mbers,ri0;ty;a4e3i2o,r0ud;an0ook;dy;ll;nedict,rg;k0nks;er;l0rt;fredo,ma",
  "Actor|Verb": "true\xA6aCb8c5doctor,engineAfool,g3host,judge,m2nerd,p1recruit,scout,ushAvolunteAwi0;mp,tneA;arent,ilot;an,ime;eek,oof,r0uide;adu8oom;ha1o0;ach,nscript,ok;mpion,uffeur;o2u0;lly,tch0;er;ss;ddi1ffili0rchite1;ate;ct",
  "MaleName": "true\xA60:H6;1:FZ;2:DS;3:GQ;4:CZ;5:FV;6:GM;7:FP;8:GW;9:ET;A:C2;B:GD;aF8bE1cCQdBMeASfA1g8Yh88i7Uj6Sk6Bl5Mm48n3So3Ip33qu31r26s1Et0Ru0Ov0CwTxSyHzC;aCor0;cChC1karia,nAT;!hDkC;!aF6;!ar7CeF5;aJevgenBSoEuC;en,rFVsCu3FvEF;if,uf;nDs6OusC;ouf,s6N;aCg;s,tC;an,h0;hli,nCrosE1ss09;is,nC;!iBU;avi2ho5;aPeNiDoCyaEL;jcieBJlfgang,odrFutR;lFnC;f8TsC;lCt1;ow;bGey,frEhe4QlC;aE5iCy;am,e,s;ed8iC;d,ed;eAur;i,ndeD2rn2sC;!l9t1;lDyC;l1ne;lDtC;!er;aCHy;aKernDAiFladDoC;jteB0lodymyr;!iC;mFQsDB;cFha0ktBZnceDrgCOvC;a0ek;!nC;t,zo;!e4StBV;lCnC7sily;!entC;in9J;ghE2lCm70nax,ri,sm0;riCyss87;ch,k;aWeRhNiLoGrEuDyC;!l2roEDs1;n6r6E;avD0eCist0oy,um0;ntCRvBKy;bFdAWmCny;!asDmCoharu;aFFie,y;!z;iA6y;mCt4;!my,othy;adEeoDia0SomC;!as;!dor91;!de4;dFrC;enBKrC;anBJeCy;ll,nBI;!dy;dgh,ha,iCnn2req,tsu5V;cDAka;aYcotWeThPiMlobod0oKpenc2tEurDvenAEyCzym1;ed,lvest2;aj,e9V;anFeDuC;!aA;fan17phEQvCwaA;e77ie;!islaCl9;v,w;lom1rBuC;leymaDHta;dDgmu9UlCm1yabonga;as,v8B;!dhart8Yn9;aEeClo75;lCrm0;d1t1;h9Jne,qu1Jun,wn,yne;aDbastiEDk2Yl5Mpp,rgCth,ymoCU;e1Dio;m4n;!tC;!ie,y;eDPlFmEnCq67tosCMul;dCj2UtiA5;e01ro;!iATkeB6mC4u5;!ik,vato9K;aZeUheC8iRoGuDyC;an,ou;b99dDf4peAssC;!elEG;ol00y;an,bLc7MdJel,geIh0lHmGnEry,sDyC;!ce;ar7Ocoe,s;!aCnBU;ld,n;an,eo;a7Ef;l7Jr;e3Eg2n9olfo,riC;go;bBNeDH;cCl9;ar87c86h54kCo;!ey,ie,y;cFeA3gDid,ubByCza;an8Ln06;g85iC;naC6s;ep;ch8Kfa5hHin2je8HlGmFndEoHpha5sDul,wi36yC;an,mo8O;h9Im4;alDSol3O;iD0on;f,ph;ul;e9CinC;cy,t1;aOeLhilJiFrCyoG;aDeC;m,st1;ka85v2O;eDoC;tr;r8GtC;er,ro;!ipCl6H;!p6U;dCLrcy,tC;ar,e9JrC;!o7;b9Udra8So9UscAHtri62ulCv8I;!ie,o7;ctav6Ji2lImHndrBRrGsDtCum6wB;is,to;aDc6k6m0vCwaBE;al79;ma;i,vR;ar,er;aDeksandr,ivC;er,i2;f,v;aNeLguyBiFoCu3O;aDel,j4l0ma0rC;beAm0;h,m;cFels,g5i9EkDlC;es,s;!au,h96l78olaC;!i,y;hCkCol76;ol75;al,d,il,ls1vC;ilAF;hom,tC;e,hC;anCy;!a5i5;aYeViLoGuDyC;l4Nr1;hamDr84staC;fa,p6E;ed,mG;di10e,hamEis4JntDritz,sCussa;es,he;e,y;ad,ed,mC;ad,ed;cGgu5hai,kFlEnDtchC;!e8O;a9Pik;house,o7t1;ae73eC3ha8Iolaj;ah,hDkC;!ey,y;aDeC;al,l;el,l;hDlv3rC;le,ri8Ev4T;di,met;ay0c00gn4hWjd,ks2NlTmadZnSrKsXtDuric7VxC;imilBKwe8B;eHhEi69tCus,y69;!eo,hCia7;ew,i67;eDiC;as,eu,s;us,w;j,o;cHiGkFlEqu8Qsha83tCv3;iCy;!m,n;in,on;el,o7us;a6Yo7us;!elCin,o7us;!l8o;frAEi5Zny,u5;achDcoCik;lm;ai,y;amDdi,e5VmC;oud;adCm6W;ou;aulCi9P;ay;aWeOiMloyd,oJuDyC;le,nd1;cFdEiDkCth2uk;a7e;gi,s,z;ov7Cv6Hw6H;!as,iC;a6Een;g0nn52renDuCvA4we7D;!iS;!zo;am,n4oC;n5r;a9Yevi,la5KnHoFst2thaEvC;eCi;nte;bo;nCpo8V;!a82el,id;!nC;aAy;mEnd1rDsz73urenCwr6K;ce,t;ry,s;ar,beAont;aOeIhalHiFla4onr63rDu5SylC;e,s;istCzysztof;i0oph2;er0ngsl9p,rC;ilA9k,ollos;ed,id;en0iGnDrmCv4Z;it;!dDnCt1;e2Ny;ri4Z;r,th;cp2j4mEna8BrDsp6them,uC;ri;im,l;al,il;a03eXiVoFuC;an,lCst3;en,iC;an,en,o,us;aQeOhKkub4AnIrGsDzC;ef;eDhCi9Wue;!ua;!f,ph;dCge;i,on;!aCny;h,s,th6J;anDnC;!ath6Hie,n72;!nC;!es;!l,sCy;ph;o,qu3;an,mC;!i,m6V;d,ffFns,rCs4;a7JemDmai7QoCry;me,ni1H;i9Dy;!e73rC;ey,y;cKdBkImHrEsDvi2yC;dBs1;on,p2;ed,oDrCv67;e6Qod;d,s61;al,es5Wis1;a,e,oCub;b,v;ob,qu13;aTbNchiMgLke53lija,nuKonut,rIsEtCv0;ai,suC;ki;aDha0i8XmaCsac;el,il;ac,iaC;h,s;a,vinCw3;!g;k,nngu6X;nac1Xor;ka;ai,rahC;im;aReLoIuCyd6;beAgGmFsC;eyDsC;a3e3;in,n;ber5W;h,o;m2raDsse3wC;a5Pie;c49t1K;a0Qct3XiGnDrC;beAman08;dr7VrC;iCy2N;!k,q1R;n0Tt3S;bKlJmza,nIo,rEsDyC;a5KdB;an,s0;lEo67r2IuCv9;hi5Hki,tC;a,o;an,ey;k,s;!im;ib;a08e00iUlenToQrMuCyorgy;iHnFsC;!taC;f,vC;!e,o;n6tC;er,h2;do,lC;herDlC;auCerQ;me;aEegCov2;!g,orC;!io,y;dy,h7C;dfr9nza3XrDttfC;ri6C;an,d47;!n;acoGlEno,oCuseppe;rgiCvan6O;!o,s;be6Ies,lC;es;mo;oFrC;aDha4HrC;it,y;ld,rd8;ffErgC;!e7iCy;!os;!r9;bElBrCv3;eCla1Nr4Hth,y;th;e,rC;e3YielC;!i4;aXeSiQlOorrest,rCyod2E;aHedFiC;edDtC;s,z;ri18;!d42eri11riC;ck,k;nCs2;cEkC;ie,lC;in,yn;esLisC;!co,z3M;etch2oC;ri0yd;d5lConn;ip;deriFliEng,rC;dinaCg4nan0B;nd8;pe,x;co;bCdi,hd;iEriC;ce,zC;io;an,en,o;benez2dZfrYit0lTmMnJo3rFsteb0th0ugenEvCymBzra;an,eCge4D;ns,re3K;!e;gi,iDnCrol,v3w3;est8ie,st;cCk;!h,k;o0DriCzo;co,qC;ue;aHerGiDmC;aGe3A;lCrh0;!iC;a10o,s;s1y;nu5;beAd1iEliDm2t1viCwood;n,s;ot28s;!as,j5Hot,sC;ha;a3en;!dGg6mFoDua2QwC;a2Pin;arC;do;oZuZ;ie;a04eTiOmitrNoFrag0uEwDylC;an,l0;ay3Hig4D;a3Gdl9nc0st3;minFnDri0ugCvydGy2S;!lF;!a36nCov0;e1Eie,y;go,iDykC;as;cCk;!k;i,y;armuFetDll1mitri7neCon,rk;sh;er,m6riC;ch;id;andLepak,j0lbeAmetri4nIon,rGsEvDwCxt2;ay30ey;en,in;hawn,moC;nd;ek,riC;ck;is,nC;is,y;rt;re;an,le,mKnIrEvC;e,iC;!d;en,iEne0PrCyl;eCin,yl;l45n;n,o,us;!iCny;el,lo;iCon;an,en,on;a0Fe0Ch03iar0lRoJrFuDyrC;il,us;rtC;!is;aEistC;iaCob12;no;ig;dy,lInErC;ey,neliCy;s,us;nEor,rDstaC;nt3;ad;or;by,e,in,l3t1;aHeEiCyde;fCnt,ve;fo0Xt1;menDt4;us;s,t;rFuDyC;!t1;dCs;e,io;enC;ce;aHeGrisC;!toC;phCs;!eC;!r;st2t;d,rCs;b5leC;s,y;cDdrCs6;ic;il;lHmFrC;ey,lDroCy;ll;!o7t1;er1iC;lo;!eb,v3;a09eZiVjorn,laUoSrEuCyr1;ddy,rtKst2;er;aKeFiEuDyC;an,ce,on;ce,no;an,ce;nDtC;!t;dDtC;!on;an,on;dFnC;dDisC;lav;en,on;!foOl9y;bby,gd0rCyd;is;i0Lke;bElDshC;al;al,lL;ek;nIrCshoi;at,nEtC;!raC;m,nd;aDhaCie;rd;rd8;!iDjam3nCs1;ie,y;to;kaMlazs,nHrC;n9rDtC;!holomew;eCy;tt;ey;dCeD;ar,iC;le;ar1Nb1Dd16fon15gust3hm12i0Zja0Yl0Bm07nTputsiSrGsaFugustEveDyCziz;a0kh0;ry;o,us;hi;aMchiKiJjun,mHnEon,tCy0;em,hCie,ur8;ur;aDoC;!ld;ud,v;aCin;an,nd8;!el,ki;baCe;ld;ta;aq;aMdHgel8tCw6;hoFoC;iDnC;!i8y;ne;ny;er7rCy;eDzC;ej;!as,i,j,s,w;!s;s,tolC;iCy;!y;ar,iEmaCos;nu5r;el;ne,r,t;aVbSdBeJfHiGl01onFphonsEt1vC;aPin;on;e,o;so,zo;!sR;!onZrC;ed;c,jaHksFssaHxC;!andC;er,rC;e,os,u;andCei;ar,er,r;ndC;ro;en;eDrecC;ht;rt8;dd3in,n,sC;taC;ir;ni;dDm6;ar;an,en;ad,eC;d,t;in;so;aGi,olErDvC;ik;ian8;f8ph;!o;mCn;!a;dGeFraDuC;!bakr,lfazl;hCm;am;!l;allFel,oulaye,ulC;!lDrahm0;an;ah,o;ah;av,on",
  "Uncountable": "true\xA60:2E;1:2L;2:33;a2Ub2Lc29d22e1Rf1Ng1Eh16i11j0Yk0Wl0Rm0Hn0Do0Cp03rZsLt9uran2Jv7w3you gu0E;a5his17i4oo3;d,l;ldlife,ne;rm8t1;apor,ernacul29i3;neg28ol1Otae;eDhBiAo8r4un3yranny;a,gst1B;aff2Oea1Ko4ue nor3;th;o08u3;bleshoot2Ose1Tt;night,othpas1Vwn3;foEsfoE;me off,n;er3und1;e,mod2S;a,nnis;aDcCeBhAi9ki8o7p6t4u3weepstak0;g1Unshi2Hshi;ati08e3;am,el;ace2Keci0;ap,cc1meth2C;n,ttl0;lk;eep,ingl0or1C;lf,na1Gri0;ene1Kisso1C;d0Wfe2l4nd,t3;i0Iurn;m1Ut;abi0e4ic3;e,ke15;c3i01laxa11search;ogni10rea10;a9e8hys7luto,o5re3ut2;amble,mis0s3ten20;en1Zs0L;l3rk;i28l0EyH; 16i28;a24tr0F;nt3ti0M;i0s;bstetri24vercrowd1Qxyg09;a5e4owada3utella;ys;ptu1Ows;il poliZtional securi2;aAe8o5u3;m3s1H;ps;n3o1K;ey,o3;gamy;a3cha0Elancholy,rchandi1Htallurgy;sl0t;chine3g1Aj1Hrs,thema1Q; learn1Cry;aught1e6i5ogi4u3;ck,g12;c,s1M;ce,ghtn18nguis1LteratWv1;ath1isVss;ara0EindergartPn3;icke0Aowled0Y;e3upit1;a3llyfiGwel0G;ns;ce,gnor6mp5n3;forma00ter3;net,sta07;atiSort3rov;an18;a7e6isto09o3ung1;ckey,mework,ne4o3rseradi8spitali2use arrest;ky;s2y;adquarteXre;ir,libut,ppiHs3;hi3te;sh;ene8l6o5r3um,ymnas11;a3eZ;niUss;lf,re;ut3yce0F;en; 3ti0W;edit0Hpo3;ol;aNicFlour,o4urnit3;ure;od,rgive3uri1wl;ness;arCcono0LducaBlectr9n7quip8thi0Pvery6x3;ist4per3;ti0B;en0J;body,o08th07;joy3tertain3;ment;ici2o3;ni0H;tiS;nings,th;emi02i6o4raugh3ynas2;ts;pe,wnstai3;rs;abet0ce,s3;honZrepu3;te;aDelciChAivi07l8o3urrency;al,ld w6mmenta5n3ral,ttIuscoB;fusiHt 3;ed;ry;ar;assi01oth0;es;aos,e3;eMwK;us;d,rO;a8i6lood,owlHread5u3;ntGtt1;er;!th;lliarJs3;on;g3ss;ga3;ge;cKdviJeroGirFmBn6ppeal court,r4spi3thleL;rin;ithmet3sen3;ic;i6y3;o4th3;ing;ne;se;en5n3;es2;ty;ds;craft;bi8d3nau7;yna3;mi6;ce;id,ous3;ti3;cs",
  "Infinitive": "true\xA60:9G;1:9T;2:AD;3:90;4:9Z;5:84;6:AH;7:A9;8:92;9:A0;A:AG;B:AI;C:9V;D:8R;E:8O;F:97;G:6H;H:7D;a94b8Hc7Jd68e4Zf4Mg4Gh4Ai3Qj3Nk3Kl3Bm34nou48o2Vp2Equ2Dr1Es0CtZuTvRwI;aOeNiLors5rI;eJiI;ng,te;ak,st3;d5e8TthI;draw,er;a2d,ep;i2ke,nIrn;d1t;aIie;liADniAry;nJpI;ho8Llift;cov1dJear8Hfound8DlIplug,rav82tie,ve94;eaAo3X;erIo;cut,go,staAFvalA3w2G;aSeQhNoMrIu73;aIe72;ffi3Smp3nsI;aBfo7CpI;i8oD;pp3ugh5;aJiJrIwaD;eat5i2;nk;aImA0;ch,se;ck3ilor,keImp1r8L;! paD;a0Ic0He0Fh0Bi0Al08mugg3n07o05p02qu01tUuLwI;aJeeIim;p,t5;ll7Wy;bNccMffLggeCmmKppJrI;mouFpa6Zvi2;o0re6Y;ari0on;er,i4;e7Numb;li9KmJsiIveD;de,st;er9it;aMe8MiKrI;ang3eIi2;ng27w;fIng;f5le;b,gg1rI;t3ve;a4AiA;a4UeJit,l7DoI;il,of;ak,nd;lIot7Kw;icEve;atGeak,i0O;aIi6;m,y;ft,ng,t;aKi6CoJriIun;nk,v6Q;ot,rt5;ke,rp5tt1;eIll,nd,que8Gv1w;!k,m;aven9ul8W;dd5tis1Iy;a0FeKiJoI;am,t,ut;d,p5;a0Ab08c06d05f01group,hea00iZjoi4lXmWnVpTq3MsOtMup,vI;amp,eJiIo3B;sEve;l,rI;e,t;i8rI;ie2ofE;eLiKpo8PtIurfa4;o24rI;aHiBuctu8;de,gn,st;mb3nt;el,hra0lIreseF;a4e71;d1ew,o07;aHe3Fo2;a7eFiIo6Jy;e2nq41ve;mbur0nf38;r0t;inKleBocus,rJuI;el,rbiA;aBeA;an4e;aBu4;ei2k8Bla43oIyc3;gni39nci3up,v1;oot,uI;ff;ct,d,liIp;se,ze;tt3viA;aAenGit,o7;aWerUinpoiFlumm1LoTrLuI;b47ke,niArIt;poDsuI;aFe;eMoI;cKd,fe4XhibEmo7noJpo0sp1tru6vI;e,i6o5L;un4;la3Nu8;aGclu6dJf1occupy,sup0JvI;a6BeF;etermi4TiB;aGllu7rtr5Ksse4Q;cei2fo4NiAmea7plex,sIva6;eve8iCua6;mp1rItrol,ve;a6It6E;bOccuNmEpMutLverIwe;l07sJtu6Yu0wI;helm;ee,h1F;gr5Cnu2Cpa4;era7i4Ipo0;py,r;ey,seItaH;r2ss;aMe0ViJoIultiply;leCu6Pw;micJnIspla4;ce,g3us;!k;iIke,na9;m,ntaH;aPeLiIo0u3N;ke,ng1quIv5;eIi6S;fy;aKnIss5;d,gI;th5;rn,ve;ng2Gu1N;eep,idnJnI;e4Cow;ap;oHuI;gg3xtaI;po0;gno8mVnIrk;cTdRfQgeChPitia7ju8q1CsNtKun6EvI;a6eIo11;nt,rt,st;erJimi6BoxiPrI;odu4u6;aBn,pr03ru6C;iCpi8tIu8;all,il,ruB;abEibE;eCo3Eu0;iIul9;ca7;i7lu6;b5Xmer0pI;aLer4Uin9ly,oJrI;e3Ais6Bo2;rt,se,veI;riA;le,rt;aLeKiIoiCuD;de,jaInd1;ck;ar,iT;mp1ng,pp5raIve;ng5Mss;ath1et,iMle27oLrI;aJeIow;et;b,pp3ze;!ve5A;gg3ve;aTer45i5RlSorMrJuI;lf4Cndrai0r48;eJiIolic;ght5;e0Qsh5;b3XeLfeEgJsI;a3Dee;eIi2;!t;clo0go,shIwa4Z;ad3F;att1ee,i36;lt1st5;a0OdEl0Mm0FnXquip,rWsVtGvTxI;aRcPeDhOiNpJtIu6;ing0Yol;eKi8lIo0un9;aHoI;it,re;ct,di7l;st,t;a3oDu3B;e30lI;a10u6;lt,mi28;alua7oI;ke,l2;chew,pou0tab19;a0u4U;aYcVdTfSgQhan4joy,lPqOrNsuMtKvI;e0YisI;a9i50;er,i4rI;aHenGuC;e,re;iGol0F;ui8;ar9iC;a9eIra2ulf;nd1;or4;ang1oIu8;r0w;irc3lo0ou0ErJuI;mb1;oaGy4D;b3ct;bKer9pI;hasiIow1;ze;aKody,rI;a4oiI;d1l;lm,rk;ap0eBuI;ci40de;rIt;ma0Rn;a0Re04iKo,rIwind3;aw,ed9oI;wn;agno0e,ff1g,mi2Kne,sLvI;eIul9;rIst;ge,t;aWbVcQlod9mant3pNru3TsMtI;iIoDu37;lJngI;uiA;!l;ol2ua6;eJlIo0ro2;a4ea0;n0r0;a2Xe36lKoIu0S;uIv1;ra9;aIo0;im;a3Kur0;b3rm;af5b01cVduBep5fUliTmQnOpMrLsiCtaGvI;eIol2;lop;ch;a20i2;aDiBloIoD;re,y;oIy;te,un4;eJoI;liA;an;mEv1;a4i0Ao06raud,y;ei2iMla8oKrI;ee,yI;!pt;de,mIup3;missi34po0;de,ma7ph1;aJrief,uI;g,nk;rk;mp5rk5uF;a0Dea0h0Ai09l08oKrIurta1G;a2ea7ipp3uI;mb3;ales4e04habEinci6ll03m00nIrro6;cXdUfQju8no7qu1sLtKvI;eIin4;ne,r9y;aHin2Bribu7;er2iLoli2Epi8tJuI;lt,me;itu7raH;in;d1st;eKiJoIroFu0;rm;de,gu8rm;ss;eJoI;ne;mn,n0;eIlu6ur;al,i2;buCe,men4pI;eIi3ly;l,te;eBi6u6;r4xiC;ean0iT;rcumveFte;eJirp,oI;o0p;riAw;ncIre5t1ulk;el;a02eSi6lQoPrKuI;iXrIy;st,y;aLeaKiJoad5;en;ng;stfeLtX;ke;il,l11mba0WrrMth1;eIow;ed;!coQfrie1LgPhMliLqueaKstJtrIwild1;ay;ow;th;e2tt3;a2eJoI;ld;ad;!in,ui3;me;bysEckfi8ff3tI;he;b15c0Rd0Iff0Ggree,l0Cm09n03ppZrXsQttOuMvJwaE;it;eDoI;id;rt;gIto0X;meF;aIeCraB;ch,in;pi8sJtoI;niA;aKeIi04u8;mb3rt,ss;le;il;re;g0Hi0ou0rI;an9i2;eaKly,oiFrI;ai0o2;nt;r,se;aMi0GnJtI;icipa7;eJoIul;un4y;al;ly0;aJu0;se;lga08ze;iKlI;e9oIu6;t,w;gn;ix,oI;rd;a03jNmiKoJsoI;rb;pt,rn;niIt;st1;er;ouJuC;st;rn;cLhie2knowled9quiItiva7;es4re;ce;ge;eQliOoKrJusI;e,tom;ue;mIst;moJpI;any,liA;da7;ma7;te;pt;andPduBet,i6oKsI;coKol2;ve;liArt,uI;nd;sh;de;ct;on",
  "Person": "true\xA60:1Q;a29b1Zc1Md1Ee18f15g13h0Ri0Qj0Nk0Jl0Gm09n06o05p00rPsItCusain bolt,v9w4xzibit,y1;anni,oko on2uji,v1;an,es;en,o;a3ednesday adams,i2o1;lfram,o0Q;ll ferrell,z khalifa;lt disn1Qr1;hol,r0G;a2i1oltai06;n dies0Zrginia wo17;lentino rossi,n goG;a4h3i2ripp,u1yra banks;lZpac shakur;ger woods,mba07;eresa may,or;kashi,t1ylor;um,ya1B;a5carlett johanss0h4i3lobodan milosevic,no2ocr1Lpider1uperm0Fwami; m0Em0E;op dogg,w whi1H;egfried,nbad;akespeaTerlock holm1Sia labeouf;ddam hussa16nt1;a cla11ig9;aAe6i5o3u1za;mi,n dmc,paul,sh limbau1;gh;bin hood,d stew16nald1thko;in0Mo;han0Yngo starr,valdo;ese witherspo0i1mbrandt;ll2nh1;old;ey,y;chmaninoff,ffi,iJshid,y roma1H;a4e3i2la16o1uff daddy;cahont0Ie;lar,p19;le,rZ;lm17ris hilt0;leg,prah winfr0Sra;a2e1iles cra1Bostradam0J; yo,l5tt06wmQ;pole0s;a5e4i2o1ubar03;by,lie5net,rriss0N;randa ju1tt romn0M;ly;rl0GssiaB;cklemo1rkov,s0ta hari,ya angelou;re;ady gaga,e1ibera0Pu;bron jam0Xch wale1e;sa;anye west,e3i1obe bryant;d cudi,efer suther1;la0P;ats,sha;a2effers0fk,k rowling,rr tolki1;en;ck the ripp0Mwaharlal nehru,y z;liTnez,ron m7;a7e5i3u1;lk hog5mphrey1sa01;! bog05;l1tl0H;de; m1dwig,nry 4;an;ile selassFlle ber4m3rrison1;! 1;ford;id,mo09;ry;ast0iannis,o1;odwPtye;ergus0lorence nightinga08r1;an1ederic chopN;s,z;ff5m2nya,ustaXzeki1;el;eril lagasse,i1;le zatop1nem;ek;ie;a6e4i2octor w1rake;ho;ck w1ego maradoC;olf;g1mi lovaOnzel washingt0;as;l1nHrth vadR;ai lNt0;a8h5lint0o1thulhu;n1olio;an,fuci1;us;on;aucKop2ristian baMy1;na;in;millo,ptain beefhe4r1;dinal wols2son1;! palmF;ey;art;a8e5hatt,i3oHro1;ck,n1;te;ll g1ng crosby;atB;ck,nazir bhut2rtil,yon1;ce;to;nksy,rack ob1;ama;l 6r3shton kutch2vril lavig8yn ra1;nd;er;chimed2istot1;le;es;capo2paci1;no;ne",
  "Adjective": "true\xA60:AI;1:BS;2:BI;3:BA;4:A8;5:84;6:AV;7:AN;8:AF;9:7H;A:BQ;B:AY;C:BC;D:BH;E:9Y;aA2b9Ec8Fd7We79f6Ng6Eh61i4Xj4Wk4Tl4Im41n3Po36p2Oquart7Pr2Ds1Dt14uSvOwFye29;aMeKhIiHoF;man5oFrth7G;dADzy;despreB1n w97s86;acked1UoleF;!sa6;ather1PeFll o70ste1D;!k5;nt1Ist6Ate4;aHeGiFola5T;bBUce versa,gi3Lle;ng67rsa5R;ca1gBSluAV;lt0PnLpHrGsFttermoBL;ef9Ku3;b96ge1; Hb32pGsFtiAH;ca6ide d4R;er,i85;f52to da2;a0Fbeco0Hc0Bd04e02f01gu1XheaBGiXkn4OmUnTopp06pRrNsJtHus0wF;aFiel3K;nt0rra0P;app0eXoF;ld,uS;eHi37o5ApGuF;perv06spec39;e1ok9O;en,ttl0;eFu5;cogn06gul2RlGqu84sF;erv0olv0;at0en33;aFrecede0E;id,rallel0;am0otic0;aFet;rri0tF;ch0;nFq26vers3;sur0terFv7U;eFrupt0;st0;air,inish0orese98;mploy0n7Ov97xpF;ect0lain0;eHisFocume01ue;clFput0;os0;cid0rF;!a8Scov9ha8Jlyi8nea8Gprivileg0sMwF;aFei9I;t9y;hGircumcFonvin2U;is0;aFeck0;lleng0rt0;b20ppea85ssuGttend0uthorF;iz0;mi8;i4Ara;aLeIhoHip 25oGrF;anspare1encha1i2;geth9leADp notch,rpB;rny,ugh6H;ena8DmpGrFs6U;r49tia4;eCo8P;leFst4M;nt0;a0Dc09e07h06i04ki03l01mug,nobbi4XoVpRqueami4XtKuFymb94;bHccinAi generis,pFr5;erFre7N;! dup9b,vi70;du0li7Lp6IsFurb7J;eq9Atanda9X;aKeJi16o2QrGubboFy4Q;rn;aightFin5GungS; fFfF;or7V;adfa9Pri6;lwa6Ftu82;arHeGir6NlendBot Fry;on;c3Qe1S;k5se; call0lImb9phistic16rHuFviV;ndFth1B;proof;dBry;dFub6; o2A;e60ipF;pe4shod;ll0n d7R;g2HnF;ceEg6ist9;am3Se9;co1Zem5lfFn6Are7; suf4Xi43;aGholFient3A;ar5;rlFt4A;et;cr0me,tisfac7F;aOeIheumatoBiGoF;bu8Ztt7Gy3;ghtFv3; 1Sf6X;cJdu8PlInown0pro69sGtF;ard0;is47oF;lu2na1;e1Suc45;alcit8Xe1ondi2;bBci3mpa1;aSePicayu7laOoNrGuF;bl7Tnjabi;eKiIoF;b7VfGmi49pFxi2M;er,ort81;a7uD;maFor,sti7va2;!ry;ciDexis0Ima2CpaB;in55puli8G;cBid;ac2Ynt 3IrFti2;ma40tFv7W;!i3Z;i2YrFss7R;anoBtF; 5XiF;al,s5V;bSffQkPld OnMrLth9utKverF;!aIbMdHhGni75seas,t,wF;ei74rou74;a63e7A;ue;ll;do1Ger,si6A;d3Qg2Aotu5Z; bFbFe on o7g3Uli7;oa80;fashion0school;!ay; gua7XbFha5Uli7;eat;eHligGsF;ce7er0So1C;at0;diFse;a1e1;aOeNiMoGuF;anc0de; moEnHrthFt6V;!eFwe7L;a7Krn;chaGdescri7Iprof30sF;top;la1;ght5;arby,cessa4ighbor5wlyw0xt;k0usiaFv3;ti8;aQeNiLoHuF;dIltiF;facet0p6;deHlGnFot,rbBst;ochro4Xth5;dy;rn,st;ddle ag0nF;dbloZi,or;ag9diocEga,naGrFtropolit4Q;e,ry;ci8;cIgenta,inHj0Fkeshift,mmGnFri4Oscu61ver18;da5Dy;ali4Lo4U;!stream;abEho;aOeLiIoFumberi8;ngFuti1R;stan3RtF;erm,i4H;ghtGteraF;l,ry,te;heart0wei5O;ft JgFss9th3;al,eFi0M;nda4;nguBps0te5;apGind5noF;wi8;ut;ad0itte4uniW;ce co0Hgno6Mll0Cm04nHpso 2UrF;a2releF;va1; ZaYcoWdReQfOgrNhibi4Ri05nMoLsHtFvalu5M;aAeF;nDrdepe2K;a7iGolFuboI;ub6ve1;de,gF;nifica1;rdi5N;a2er;own;eriIiLluenVrF;ar0eq5H;pt,rt;eHiGoFul1O;or;e,reA;fiFpe26termi5E;ni2;mpFnsideCrreA;le2;ccuCdeq5Ene,ppr4J;fFsitu,vitro;ro1;mJpF;arHeGl15oFrop9;li2r11;n2LrfeA;ti3;aGeFi18;d4BnD;tuE;egGiF;c0YteC;al,iF;tiF;ma2;ld;aOelNiLoFuma7;a4meInHrrGsFur5;ti6;if4E;e58o3U; ma3GsF;ick;ghfalut2HspF;an49;li00pf33;i4llow0ndGrdFtM; 05coEworki8;sy,y;aLener44iga3Blob3oKrGuF;il1Nng ho;aFea1Fizzl0;cGtF;ef2Vis;ef2U;ld3Aod;iFuc2D;nf2R;aVeSiQlOoJrF;aGeFil5ug3;q43tf2O;gFnt3S;i6ra1;lk13oHrF; keeps,eFge0Vm9tu41;g0Ei2Ds3R;liF;sh;ag4Mowe4uF;e1or45;e4nF;al,i2;d Gmini7rF;ti6ve1;up;bl0lDmIr Fst pac0ux;oGreacF;hi8;ff;ed,ili0R;aXfVlTmQnOqu3rMthere3veryday,xF;aApIquisi2traHuF;be48lF;ta1;!va2L;edRlF;icF;it;eAstF;whi6; Famor0ough,tiE;rou2sui2;erGiF;ne1;ge1;dFe2Aoq34;er5;ficF;ie1;g9sF;t,ygF;oi8;er;aWeMiHoGrFue;ea4owY;ci6mina1ne,r31ti8ubQ;dact2Jfficult,m,sGverF;ge1se;creGePjoi1paCtF;a1inA;et,te; Nadp0WceMfiLgeneCliJmuEpeIreliAsGvoF;id,ut;pFtitu2ul1L;eCoF;nde1;ca2ghF;tf13;a1ni2;as0;facto;i5ngero0I;ar0Ce09h07i06l05oOrIuF;rmudgeon5stoma4teF;sy;ly;aIeHu1EystalF; cleFli7;ar;epy;fFv17z0;ty;erUgTloSmPnGrpoCunterclVveFy;rt;cLdJgr21jIsHtrF;aFi2;dic0Yry;eq1Yta1;oi1ug3;escenFuN;di8;a1QeFiD;it0;atoDmensuCpF;ass1SulF;so4;ni3ss3;e1niza1;ci1J;ockwiD;rcumspeAvil;eFintzy;e4wy;leGrtaF;in;ba2;diac,ef00;a00ePiLliJoGrFuck nak0;and new,isk,on22;gGldface,naF; fi05fi05;us;nd,tF;he;gGpartisFzarE;an;tiF;me;autifOhiNlLnHsFyoN;iWtselF;li8;eGiFt;gn;aFfi03;th;at0oF;v0w;nd;ul;ckwards,rF;e,rT; priori,b13c0Zd0Tf0Ng0Ihe0Hl09mp6nt06pZrTsQttracti0MuLvIwF;aGkF;wa1B;ke,re;ant garGeraF;ge;de;diIsteEtF;heFoimmu7;nt07;re;to4;hGlFtu2;eep;en;bitIchiv3roHtF;ifiFsy;ci3;ga1;ra4;ry;pFt;aHetizi8rF;oprF;ia2;llFre1;ed,i8;ng;iquFsy;at0e;ed;cohKiJkaHl,oGriFterX;ght;ne,of;li7;ne;ke,ve;olF;ic;ad;ain07gressiIi6rF;eeF;ab6;le;ve;fGraB;id;ectGlF;ue1;ioF;na2; JaIeGvF;erD;pt,qF;ua2;ma1;hoc,infinitum;cuCquiGtu3u2;al;esce1;ra2;erSjeAlPoNrKsGuF;nda1;e1olu2trF;aAuD;se;te;eaGuF;pt;st;aFve;rd;aFe;ze;ct;ra1;nt",
  "Pronoun": "true\xA6elle,h3i2me,she,th0us,we,you;e0ou;e,m,y;!l,t;e,im",
  "Preposition": "true\xA6aPbMcLdKexcept,fIinGmid,notwithstandiWoDpXqua,sCt7u4v2w0;/o,hereSith0;! whHin,oW;ersus,i0;a,s a vis;n1p0;!on;like,til;h1ill,oward0;!s;an,ereby,r0;ough0u;!oM;ans,ince,o that,uch G;f1n0ut;!to;!f;! 0to;effect,part;or,r0;om;espite,own,u3;hez,irca;ar1e0oBy;sides,tween;ri7;bo8cross,ft7lo6m4propos,round,s1t0;!op;! 0;a whole,long 0;as;id0ong0;!st;ng;er;ut",
  "SportsTeam": "true\xA60:18;1:1E;2:1D;3:14;a1Db15c0Sd0Kfc dallas,g0Ihouston 0Hindiana0Gjacksonville jagua0k0El0Am01new UoRpKqueens parkJreal salt lake,sBt6utah jazz,vancouver whitecaps,w4yW;ashington 4h10;natio1Mredski2wizar0W;ampa bay 7e6o4;ronto 4ttenham hotspur;blue ja0Mrapto0;nnessee tita2xasD;buccanee0ra0K;a8eattle 6porting kansas0Wt4; louis 4oke0V;c1Drams;marine0s4;eah13ounH;cramento Rn 4;antonio spu0diego 4francisco gJjose earthquak1;char08paB; ran07;a9h6ittsburgh 5ortland t4;imbe0rail blaze0;pirat1steele0;il4oenix su2;adelphia 4li1;eagl1philNunE;dr1;akland 4klahoma city thunder,rlando magic;athle0Lrai4;de0;england 8orleans 7york 4;g5je3knYme3red bul0Xy4;anke1;ian3;pelica2sain3;patrio3revolut4;ion;anchEeAi4ontreal impact;ami 8lwaukee b7nnesota 4;t5vi4;kings;imberwolv1wi2;rewe0uc0J;dolphi2heat,marli2;mphis grizz4ts;li1;a6eic5os angeles 4;clippe0dodFlaB;esterV; galaxy,ke0;ansas city 4nF;chiefs,roya0D; pace0polis col3;astr05dynamo,rocke3texa2;olden state warrio0reen bay pac4;ke0;allas 8e4i04od6;nver 6troit 4;lio2pisto2ti4;ge0;broncYnugge3;cowbo5maver4;icZ;ys;arEelLhAincinnati 8leveland 6ol4;orado r4umbus crew sc;api7ocki1;brow2cavalie0guar4in4;dia2;bengaVre4;ds;arlotte horAicago 4;b5cubs,fire,wh4;iteB;ea0ulQ;diff4olina panthe0; city;altimore Alackburn rove0oston 6rooklyn 4uffalo bilN;ne3;ts;cel5red4; sox;tics;rs;oriol1rave2;rizona Ast8tlanta 4;brav1falco2h4;awA;ns;es;on villa,r4;os;c6di4;amondbac4;ks;ardi4;na4;ls",
  "Unit": "true\xA6a07b04cXdWexVfTgRhePinYjoule0BkMlJmDnan08oCp9quart0Bsq ft,t7volts,w6y2ze3\xB01\xB50;g,s;c,f,n;dVear1o0;ttR; 0s 0;old;att,b;erNon0;!ne02;ascals,e1i0;cXnt00;rcent,tJ;hms,unceY;/s,e4i0m\xB2,\xB2,\xB3;/h,cro2l0;e0liK;!\xB2;grLsR;gCtJ;it1u0;menQx;erPreP;b5elvins,ilo1m0notO;/h,ph,\xB2;!byGgrEmCs;ct0rtzL;aJogrC;allonJb0ig3rB;ps;a0emtEl oz,t4;hrenheit,radG;aby9;eci3m1;aratDe1m0oulombD;\xB2,\xB3;lsius,nti0;gr2lit1m0;et0;er8;am7;b1y0;te5;l,ps;c2tt0;os0;econd1;re0;!s",
  "Noun|Gerund": "true\xA60:3O;1:3M;2:3N;3:3D;4:32;5:2V;6:3E;7:3K;8:36;9:3J;A:3B;a3Pb37c2Jd27e23f1Vg1Sh1Mi1Ij1Gk1Dl18m13n11o0Wp0Pques0Sr0EsTtNunderMvKwFyDzB;eroi0oB;ni0o3P;aw2eB;ar2l3;aEed4hispe5i5oCrB;ap8est3i1;n0ErB;ki0r31;i1r2s9tc9;isualizi0oB;lunt1Vti0;stan4ta6;aFeDhin6iCraBy8;c6di0i2vel1M;mi0p8;aBs1;c9si0;l6n2s1;aUcReQhOiMkatKl2Wmo6nowJpeItFuCwB;ea5im37;b35f0FrB;fi0vB;e2Mi2J;aAoryt1KrCuB;d2KfS;etc9ugg3;l3n4;bCi0;ebBi0;oar4;gnBnAt1;a3i0;ip8oB;p8rte2u1;a1r27t1;hCo5reBulp1;a2Qe2;edu3oo3;i3yi0;aKeEi4oCuB;li0n2;oBwi0;fi0;aFcEhear7laxi0nDpor1sB;pon4tructB;r2Iu5;de5;or4yc3;di0so2;p8ti0;aFeacek20laEoCrBublis9;a1Teten4in1oces7;iso2siB;tio2;n2yi0;ckaAin1rB;ki0t1O;fEpeDrganiCvB;erco24ula1;si0zi0;ni0ra1;fe5;avi0QeBur7;gotia1twor6;aDeCi2oB;de3nito5;a2dita1e1ssaA;int0XnBrke1;ifUufactu5;aEeaDiBodAyi0;cen7f1mi1stB;e2i0;r2si0;n4ug9;iCnB;ea4it1;c6l3;ogAuB;dAgg3stif12;ci0llust0VmDnBro2;nova1sp0NterBven1;ac1vie02;agi2plo4;aDea1iCoBun1;l4w3;ki0ri0;nd3rB;roWvB;es1;aCene0Lli4rBui4;ee1ie0N;rde2the5;aHeGiDlCorBros1un4;e0Pmat1;ir1oo4;gh1lCnBs9;anZdi0;i0li0;e3nX;r0Zscina1;a1du01nCxB;erci7plo5;chan1di0ginB;ee5;aLeHiGoub1rCum8wB;el3;aDeCiB;bb3n6vi0;a0Qs7;wi0;rTscoDvi0;ba1coZlBvelo8;eCiB;ve5;ga1;nGti0;aVelebUhSlPoDrBur3yc3;aBos7yi0;f1w3;aLdi0lJmFnBo6pi0ve5;dDsCvinB;ci0;trBul1;uc1;muniDpB;lBo7;ai2;ca1;lBo5;ec1;c9ti0;ap8eaCimToBubT;ni0t9;ni0ri0;aBee5;n1t1;ra1;m8rCs1te5;ri0;vi0;aPeNitMlLoGrDuB;dge1il4llBr8;yi0;an4eat9oadB;cas1;di0;a1mEokB;i0kB;ee8;pi0;bi0;es7oa1;c9i0;gin2lonAt1;gi0;bysit1c6ki0tt3;li0;ki0;bando2cGdverti7gi0pproac9rgDssuCtB;trac1;mi0;ui0;hi0;si0;coun1ti0;ti0;ni0;ng",
  "PhrasalVerb": "true\xA60:92;1:96;2:8H;3:8V;4:8A;5:83;6:85;7:98;8:90;9:8G;A:8X;B:8R;C:8U;D:8S;E:70;F:97;G:8Y;H:81;I:7H;J:79;a9Fb7Uc6Rd6Le6Jf5Ig50h4Biron0j47k40l3Em31n2Yo2Wp2Cquiet Hr1Xs0KtZuXvacuu6QwNyammerBzK;ero Dip LonK;e0k0;by,ov9up;aQeMhLiKor0Mrit19;mp0n3Fpe0r5s5;ackAeel Di0S;aLiKn33;gh 3Wrd0;n Dr K;do1in,oJ;it 79k5lk Lrm 69sh Kt83v60;aw3do1o7up;aw3in,oC;rgeBsK;e 2herE;a00eYhViRoQrMuKypP;ckErn K;do1in,oJup;aLiKot0y 30;ckl7Zp F;ck HdK;e 5Y;n7Wp 3Es5K;ck MdLe Kghten 6me0p o0Rre0;aw3ba4do1in,up;e Iy 2;by,oG;ink Lrow K;aw3ba4in,up;ba4ov9up;aKe 77ll62;m 2r 5M;ckBke Llk K;ov9shit,u47;aKba4do1in,leave,o4Dup;ba4ft9pa69w3;a0Vc0Te0Mh0Ii0Fl09m08n07o06p01quar5GtQuOwK;earMiK;ngLtch K;aw3ba4o8K; by;cKi6Bm 2ss0;k 64;aReQiPoNrKud35;aigh2Det75iK;ke 7Sng K;al6Yup;p Krm2F;by,in,oG;c3Ln3Lr 2tc4O;p F;c3Jmp0nd LrKveAy 2O;e Ht 2L;ba4do1up;ar3GeNiMlLrKurB;ead0ingBuc5;a49it 6H;c5ll o3Cn 2;ak Fe1Xll0;a3Bber 2rt0und like;ap 5Vow Duggl5;ash 6Noke0;eep NiKow 6;cLp K;o6Dup;e 68;in,oK;ff,v9;de19gn 4NnKt 6Gz5;gKkE; al6Ale0;aMoKu5W;ot Kut0w 7M;aw3ba4f48oC;c2WdeEk6EveA;e Pll1Nnd Orv5tK; Ktl5J;do1foLin,o7upK;!on;ot,r5Z;aw3ba4do1in,o33up;oCto;al66out0rK;ap65ew 6J;ilAv5;aXeUiSoOuK;b 5Yle0n Kstl5;aLba4do1inKo2Ith4Nu5P;!to;c2Xr8w3;ll Mot LpeAuK;g3Ind17;a2Wf3Po7;ar8in,o7up;ng 68p oKs5;ff,p18;aKelAinEnt0;c6Hd K;o4Dup;c27t0;aZeYiWlToQrOsyc35uK;ll Mn5Kt K;aKba4do1in,oJto47up;pa4Dw3;a3Jdo1in,o21to45up;attleBess KiNop 2;ah2Fon;iLp Kr4Zu1Gwer 6N;do1in,o6Nup;nt0;aLuK;gEmp 6;ce u20y 6D;ck Kg0le 4An 6p5B;oJup;el 5NncilE;c53ir 39n0ss MtLy K;ba4oG; Hc2R;aw3ba4in,oJ;pKw4Y;e4Xt D;aLerd0oK;dAt53;il Hrrow H;aTeQiPoLuK;ddl5ll I;c1FnkeyMp 6uthAve K;aKdo1in,o4Lup;l4Nw3; wi4K;ss0x 2;asur5e3SlLss K;a21up;t 6;ke Ln 6rKs2Ax0;k 6ryA;do,fun,oCsure,up;a02eViQoLuK;ck0st I;aNc4Fg MoKse0;k Kse4D;aft9ba4do1forw37in56o0Zu46;in,oJ;d 6;e NghtMnLsKve 00;ten F;e 2k 2; 2e46;ar8do1in;aMt LvelK; oC;do1go,in,o7up;nEve K;in,oK;pKut;en;c5p 2sh LtchBughAy K;do1o59;in4Po7;eMick Lnock K;do1oCup;oCup;eLy K;in,up;l Ip K;aw3ba4do1f04in,oJto,up;aMoLuK;ic5mpE;ke3St H;c43zz 2;a01eWiToPuK;nLrrKsh 6;y 2;keLt K;ar8do1;r H;lKneErse3K;d Ke 2;ba4dKfast,o0Cup;ear,o1;de Lt K;ba4on,up;aw3o7;aKlp0;d Ml Ir Kt 2;fKof;rom;f11in,o03uW;cPm 2nLsh0ve Kz2P;at,it,to;d Lg KkerP;do1in,o2Tup;do1in,oK;ut,v9;k 2;aZeTive Rloss IoMrLunK; f0S;ab hold,in43ow 2U; Kof 2I;aMb1Mit,oLr8th1IuK;nd9;ff,n,v9;bo7ft9hQw3;aw3bKdo1in,oJrise,up,w3;a4ir2H;ar 6ek0t K;aLb1Fdo1in,oKr8up;ff,n,ut,v9;cLhKl2Fr8t,w3;ead;ross;d aKng 2;bo7;a0Ee07iYlUoQrMuK;ck Ke2N;ar8up;eLighten KownBy 2;aw3oG;eKshe27; 2z5;g 2lMol Krk I;aKwi20;bo7r8;d 6low 2;aLeKip0;sh0;g 6ke0mKrKtten H;e F;gRlPnNrLsKzzle0;h F;e Km 2;aw3ba4up;d0isK;h 2;e Kl 1T;aw3fPin,o7;ht ba4ure0;ePnLsK;s 2;cMd K;fKoG;or;e D;d04l 2;cNll Krm0t1G;aLbKdo1in,o09sho0Eth08victim;a4ehi2O;pa0C;e K;do1oGup;at Kdge0nd 12y5;in,o7up;aOi1HoNrK;aLess 6op KuN;aw3b03in,oC;gBwB; Ile0ubl1B;m 2;a0Ah05l02oOrLut K;aw3ba4do1oCup;ackBeep LoKy0;ss Dwd0;by,do1in,o0Uup;me NoLuntK; o2A;k 6l K;do1oG;aRbQforOin,oNtKu0O;hLoKrue;geth9;rough;ff,ut,v9;th,wK;ard;a4y;paKr8w3;rt;eaLose K;in,oCup;n 6r F;aNeLiK;ll0pE;ck Der Kw F;on,up;t 2;lRncel0rOsMtch LveE; in;o1Nup;h Dt K;doubt,oG;ry LvK;e 08;aw3oJ;l Km H;aLba4do1oJup;ff,n,ut;r8w3;a0Ve0MiteAl0Fo04rQuK;bblNckl05il0Dlk 6ndl05rLsKtMy FzzA;t 00;n 0HsK;t D;e I;ov9;anWeaUiLush K;oGup;ghQng K;aNba4do1forMin,oLuK;nd9p;n,ut;th;bo7lKr8w3;ong;teK;n 2;k K;do1in,o7up;ch0;arTg 6iRn5oPrNssMttlLunce Kx D;aw3ba4;e 6; ar8;e H;do1;k Dt 2;e 2;l 6;do1up;d 2;aPeed0oKurt0;cMw K;aw3ba4do1o7up;ck;k K;in,oC;ck0nk0stA; oQaNef 2lt0nd K;do1ov9up;er;up;r Lt K;do1in,oCup;do1o7;ff,nK;to;ck Pil0nMrgLsK;h D;ainBe D;g DkB; on;in,o7;aw3do1in,oCup;ff,ut;ay;ct FdQir0sk MuctionA; oG;ff;ar8o7;ouK;nd; o7;d K;do1oKup;ff,n;wn;o7up;ut",
  "ProperNoun": "true\xA6aIbDc8dalhousHe7f5gosford,h4iron maiden,kirby,landsdowne,m2nis,r1s0wembF;herwood,paldiB;iel,othwe1;cgi0ercedes,issy;ll;intBudsB;airview,lorence,ra0;mpt9nco;lmo,uro;a1h0;arlt6es5risti;rl0talina;et4i0;ng;arb3e0;et1nt0rke0;ley;on;ie;bid,jax",
  "Person|Place": "true\xA6a8d6h4jordan,k3orlando,s1vi0;ctor9rgin9;a0ydney;lvador,mara,ntia4;ent,obe;amil0ous0;ton;arw2ie0;go;lexandr1ust0;in;ia",
  "LastName": "true\xA60:BR;1:BF;2:B5;3:BH;4:AX;5:9Y;6:B6;7:BK;8:B0;9:AV;A:AL;B:8Q;C:8G;D:7K;E:BM;F:AH;aBDb9Zc8Wd88e81f7Kg6Wh64i60j5Lk4Vl4Dm39n2Wo2Op25quispe,r1Ls0Pt0Ev03wTxSyKzG;aIhGimmerm6A;aGou,u;ng,o;khar5ytsE;aKeun9BiHoGun;koya32shiBU;!lG;diGmaz;rim,z;maGng;da,g52mo83sGzaC;aChiBV;iao,u;aLeJiHoGright,u;jcA5lff,ng;lGmm0nkl0sniewsC;kiB1liams33s3;bGiss,lt0;b,er,st0;a6Vgn0lHtG;anabe,s3;k0sh,tG;e2Non;aLeKiHoGukD;gt,lk5roby5;dHllalGnogr3Kr1Css0val3S;ba,ob1W;al,ov4;lasHsel8W;lJn dIrgBEsHzG;qu7;ilyEqu7siljE;en b6Aijk,yk;enzueAIverde;aPeix1VhKi2j8ka43oJrIsui,uG;om5UrG;c2n0un1;an,emblA7ynisC;dorAMlst3Km4rrAth;atch0i8UoG;mHrG;are84laci79;ps3sG;en,on;hirDkah9Mnaka,te,varA;a06ch01eYhUiRmOoMtIuHvGzabo;en9Jobod3N;ar7bot4lliv2zuC;aIeHoG;i7Bj4AyanAB;ele,in2FpheBvens25;l8rm0;kol5lovy5re7Tsa,to,uG;ng,sa;iGy72;rn5tG;!h;l71mHnGrbu;at9cla9Egh;moBo7M;aIeGimizu;hu,vchG;en8Luk;la,r1G;gu9infe5YmGoh,pulveA7rra5P;jGyG;on5;evi6iltz,miHneid0roed0uGwarz;be3Elz;dHtG;!t,z;!t;ar4Th8ito,ka4OlJnGr4saCto,unde19v4;ch7dHtGz;a5Le,os;b53e16;as,ihDm4Po0Y;aVeSiPoJuHyG;a6oo,u;bio,iz,sG;so,u;bKc8Fdrigue67ge10j9YmJosevelt,sItHux,wG;e,li6;a9Ch;enb4Usi;a54e4L;erts15i93;bei4JcHes,vGzzo;as,e9;ci,hards12;ag2es,iHut0yG;es,nol5N;s,t0;dImHnGsmu97v6C;tan1;ir7os;ic,u;aUeOhMiJoHrGut8;asad,if6Zochazk27;lishc2GpGrti72u10we76;e3Aov51;cHe45nG;as,to;as70hl0;aGillips;k,m,n6I;a3Hde3Wete0Bna,rJtG;ersHrovGters54;!a,ic;!en,on;eGic,kiBss3;i9ra,tz,z;h86k,padopoulIrk0tHvG;ic,l4N;el,te39;os;bMconn2Ag2TlJnei6PrHsbor6XweBzG;dem7Rturk;ella4DtGwe6N;ega,iz;iGof7Hs8I;vGyn1R;ei9;aSri1;aPeNiJoGune50ym2;rHvGwak;ak4Qik5otn66;odahl,r4S;cholsZeHkolGls4Jx3;ic,ov84;ls1miG;!n1;ils3mG;co4Xec;gy,kaGray2sh,var38;jiGmu9shiG;ma;a07c04eZiWoMuHyeG;rs;lJnIrGssoli6S;atGp03r7C;i,ov4;oz,te58;d0l0;h2lOnNo0RrHsGza1A;er,s;aKeJiIoz5risHtG;e56on;!on;!n7K;au,i9no,t5J;!lA;r1Btgome59;i3El0;cracFhhail5kkeHlG;l0os64;ls1;hmeJiIj30lHn3Krci0ssiGyer2N;!er;n0Po;er,j0;dDti;cartHlG;aughl8e2;hy;dQe7Egnu68i0jer3TkPmNnMrItHyG;er,r;ei,ic,su21thews;iHkDquAroqu8tinG;ez,s;a5Xc,nG;!o;ci5Vn;a5UmG;ad5;ar5e6Kin1;rig77s1;aVeOiLoJuHyG;!nch;k4nGo;d,gu;mbarGpe3Fvr4we;di;!nGu,yana2B;coln,dG;b21holm,strom;bedEfeKhIitn0kaHn8rGw35;oy;!j;m11tG;in1on1;bvGvG;re;iGmmy,ng,rs2Qu,voie,ws3;ne,t1F;aZeYh2iWlUnez50oNrJuHvar2woG;k,n;cerGmar68znets5;a,o34;aHem0isGyeziu;h23t3O;m0sni4Fus3KvG;ch4O;bay57ch,rh0Usk16vaIwalGzl5;czGsC;yk;cIlG;!cGen4K;huk;!ev4ic,s;e8uiveG;rt;eff0kGl4mu9nnun1;ucF;ll0nnedy;hn,llKminsCne,pIrHstra3Qto,ur,yGzl5;a,s0;j0Rls22;l2oG;or;oe;aPenOha6im14oHuG;ng,r4;e32hInHrge32u6vG;anD;es,ss3;anHnsG;en,on,t3;nesGs1R;en,s1;kiBnings,s1;cJkob4EnGrv0E;kDsG;en,sG;en0Ion;ks3obs2A;brahimDglesi5Nke5Fl0Qno07oneIshikHto,vanoG;u,v54;awa;scu;aVeOiNjaltal8oIrist50uG;!aGb0ghAynh;m2ng;a6dz4fIjgaa3Hk,lHpUrGwe,x3X;ak1Gvat;mAt;er,fm3WmG;ann;ggiBtchcock;iJmingw4BnHrGss;nand7re9;deGriks1;rs3;kkiHnG;on1;la,n1;dz4g1lvoQmOns0ZqNrMsJuIwHyG;asFes;kiB;g1ng;anHhiG;mo14;i,ov0J;di6p0r10t;ue;alaG;in1;rs1;aVeorgUheorghe,iSjonRoLrJuGw3;errGnnar3Co,staf3Ctierr7zm2;a,eG;ro;ayli6ee2Lg4iffithGub0;!s;lIme0UnHodGrbachE;e,m2;calvAzale0S;dGubE;bGs0E;erg;aj,i;bs3l,mGordaO;en7;iev3U;gnMlJmaIndFo,rGsFuthi0;cGdn0za;ia;ge;eaHlG;agh0i,o;no;e,on;aVerQiLjeldsted,lKoIrHuG;chs,entAji41ll0;eem2iedm2;ntaGrt8urni0wl0;na;emi6orA;lipIsHtzgeraG;ld;ch0h0;ovG;!ic;hatDnanIrG;arGei9;a,i;deY;ov4;b0rre1D;dKinsJriksIsGvaB;cob3GpGtra3D;inoza,osiQ;en,s3;te8;er,is3warG;ds;aXePiNjurhuMoKrisco15uHvorakG;!oT;arte,boHmitru,nn,rGt3C;and,ic;is;g2he0Omingu7nErd1ItG;to;us;aGcki2Hmitr2Ossanayake,x3;s,z; JbnaIlHmirGrvisFvi,w2;!ov4;gado,ic;th;bo0groot,jo6lHsilGvriA;va;a cruz,e3uG;ca;hl,mcevsCnIt2WviG;dGes,s;ov,s3;ielsGku22;!en;ki;a0Be06hRiobQlarkPoIrGunningh1H;awfo0RivGuz;elli;h1lKntJoIrGs2Nx;byn,reG;a,ia;ke,p0;i,rer2K;em2liB;ns;!e;anu;aOeMiu,oIristGu6we;eGiaG;ns1;i,ng,p9uHwGy;!dH;dGng;huJ;!n,onGu6;!g;kJnIpm2ttHudhGv7;ry;erjee,o14;!d,g;ma,raboG;rty;bJl0Cng4rG;eghetHnG;a,y;ti;an,ota1C;cerAlder3mpbeLrIstGvadi0B;iGro;llo;doHl0Er,t0uGvalho;so;so,zo;ll;a0Fe01hYiXlUoNrKuIyG;rLtyG;qi;chan2rG;ke,ns;ank5iem,oGyant;oks,wG;ne;gdan5nIruya,su,uchaHyKziG;c,n5;rd;darGik;enG;ko;ov;aGond15;nco,zG;ev4;ancFshw16;a08oGuiy2;umGwmG;ik;ckRethov1gu,ktPnNrG;gJisInG;ascoGds1;ni;ha;er,mG;anG;!n;gtGit7nP;ss3;asF;hi;er,hG;am;b4ch,ez,hRiley,kk0ldw8nMrIshHtAu0;es;ir;bInHtlGua;ett;es,i0;ieYosa;dGik;a9yoG;padhyG;ay;ra;k,ng;ic;bb0Acos09d07g04kht05lZnPrLsl2tJyG;aHd8;in;la;chis3kiG;ns3;aImstro6sl2;an;ng;ujo,ya;dJgelHsaG;ri;ovG;!a;ersJov,reG;aGjEws;ss1;en;en,on,s3;on;eksejEiyEmeiIvG;ar7es;ez;da;ev;arwHuilG;ar;al;ams,l0;er;ta;as",
  "Ordinal": "true\xA6eBf7nin5s3t0zeroE;enDhir1we0;lfCn7;d,t3;e0ixt8;cond,vent7;et0th;e6ie7;i2o0;r0urt3;tie4;ft1rst;ight0lev1;e0h,ie1;en0;th",
  "Cardinal": "true\xA6bEeBf5mEnine7one,s4t0zero;en,h2rDw0;e0o;lve,n5;irt6ousands,ree;even2ix2;i3o0;r1ur0;!t2;ty;ft0ve;e2y;ight0lev1;!e0y;en;illions",
  "Multiple": "true\xA6b3hundred,m3qu2se1t0;housand,r2;pt1xt1;adr0int0;illion",
  "City": "true\xA60:74;1:61;2:6G;3:6J;4:5S;a68b53c4Id48e44f3Wg3Hh39i31j2Wk2Fl23m1Mn1Co19p0Wq0Ur0Os05tRuQvLwDxiBy9z5;a7h5i4Muri4O;a5e5ongsh0;ng3H;greb,nzib5G;ang2e5okoha3Sunfu;katerin3Hrev0;a5n0Q;m5Hn;arsBeAi6roclBu5;h0xi,zh5P;c7n5;d5nipeg,terth4;hoek,s1L;hi5Zkl3A;l63xford;aw;a8e6i5ladivost5Molgogr6L;en3lni6S;ni22r5;o3saill4N;lenc4Wncouv3Sr3ughn;lan bat1Crumqi,trecht;aFbilisi,eEheDiBo9r7u5;l21n63r5;in,ku;i5ondh62;es51poli;kyo,m2Zron1Pulo5;n,uS;an5jua3l2Tmisoa6Bra3;j4Tshui; hag62ssaloni2H;gucigal26hr0l av1U;briz,i6llinn,mpe56ng5rtu,shk2R;i3Esh0;an,chu1n0p2Eyu0;aEeDh8kopje,owe1Gt7u5;ra5zh4X;ba0Ht;aten is55ockholm,rasbou67uttga2V;an8e6i5;jiazhua1llo1m5Xy0;f50n5;ya1zh4H;gh3Kt4Q;att45o1Vv44;cramen16int ClBn5o paulo,ppo3Rrajevo; 7aa,t5;a 5o domin3E;a3fe,m1M;antonio,die3Cfrancisco,j5ped3Nsalvad0J;o5u0;se;em,t lake ci5Fz25;lou58peters24;a9e8i6o5;me,t59;ga,o5yadh;! de janei3F;cife,ims,nn3Jykjavik;b4Sip4lei2Inc2Pwalpindi;ingdao,u5;ez2i0Q;aFeEhDiCo9r7u6yong5;ya1;eb59ya1;a5etor3M;g52to;rt5zn0; 5la4Co;au prin0Melizabe24sa03;ls3Prae5Atts26;iladelph3Gnom pe1Aoenix;ki1tah tik3E;dua,lerYnaji,r4Ot5;na,r32;ak44des0Km1Mr6s5ttawa;a3Vlo;an,d06;a7ew5ing2Fovosibir1Jyc; 5cast36;del24orlea44taip14;g8iro4Wn5pl2Wshv33v0;ch6ji1t5;es,o1;a1o1;a6o5p4;ya;no,sa0W;aEeCi9o6u5;mb2Ani26sc3Y;gadishu,nt6s5;c13ul;evideo,pelli1Rre2Z;ami,l6n14s5;kolc,sissauga;an,waukee;cca,d5lbour2Mmph41ndo1Cssi3;an,ell2Xi3;cau,drAkass2Sl9n8r5shh4A;aca6ib5rakesh,se2L;or;i1Sy;a4EchFdal0Zi47;mo;id;aDeAi8o6u5vSy2;anMckn0Odhia3;n5s angel26;d2g bea1N;brev2Be3Lma5nz,sb2verpo28;!ss27; ma39i5;c5pzig;est16; p6g5ho2Wn0Cusan24;os;az,la33;aHharFiClaipeBo9rak0Du7y5;iv,o5;to;ala lump4n5;mi1sh0;hi0Hlka2Xpavog4si5wlo2;ce;da;ev,n5rkuk;gst2sha5;sa;k5toum;iv;bHdu3llakuric0Qmpa3Fn6ohsiu1ra5un1Iwaguc0Q;c0Pj;d5o,p4;ah1Ty;a7e6i5ohannesV;l1Vn0;dd36rusalem;ip4k5;ar2H;bad0mph1OnArkutUs7taXz5;mir,tapala5;pa;fah0l6tanb5;ul;am2Zi2H;che2d5;ianap2Mo20;aAe7o5yder2W; chi mi5ms,nolulu;nh;f6lsin5rakli2;ki;ei;ifa,lifax,mCn5rb1Dva3;g8nov01oi;aFdanEenDhCiPlasgBo9raz,u5;a5jr23;dal6ng5yaquil;zh1J;aja2Oupe;ld coa1Bthen5;bu2S;ow;ent;e0Uoa;sk;lw7n5za;dhi5gt1E;nag0U;ay;aisal29es,o8r6ukuya5;ma;ankfu5esno;rt;rt5sh0; wor6ale5;za;th;d5indhov0Pl paso;in5mont2;bur5;gh;aBe8ha0Xisp4o7resd0Lu5;b5esseldorf,nkirk,rb0shanbe;ai,l0I;ha,nggu0rtmu13;hradSl6nv5troit;er;hi;donghIe6k09l5masc1Zr es sala1KugavpiY;i0lU;gu,je2;aJebu,hAleve0Vo5raio02uriti1Q;lo7n6penhag0Ar5;do1Ok;akKst0V;gUm5;bo;aBen8i6ongqi1ristchur5;ch;ang m7ca5ttago1;go;g6n5;ai;du,zho1;ng5ttogr14;ch8sha,zh07;gliari,i9lga8mayenJn6pe town,r5tanO;acCdiff;ber1Ac5;un;ry;ro;aWeNhKirmingh0WoJr9u5;chareTdapeTenos air7r5s0tu0;g5sa;as;es;a9is6usse5;ls;ba6t5;ol;ne;sil8tisla7zzav5;il5;le;va;ia;goZst2;op6ubaneshw5;ar;al;iCl9ng8r5;g6l5n;in;en;aluru,hazi;fa6grade,o horizon5;te;st;ji1rut;ghd0BkFn9ot8r7s6yan n4;ur;el,r07;celo3i,ranquil09;ou;du1g6ja lu5;ka;alo6k5;ok;re;ng;ers5u;field;a05b02cc01ddis aba00gartaZhmedXizawl,lSmPnHqa00rEsBt7uck5;la5;nd;he7l5;an5;ta;ns;h5unci2;dod,gab5;at;li5;ngt2;on;a8c5kaOtwerp;hora6o3;na;ge;h7p5;ol5;is;eim;aravati,m0s5;terd5;am; 7buquerq6eppo,giers,ma5;ty;ue;basrah al qadim5mawsil al jadid5;ah;ab5;ad;la;ba;ra;idj0u dha5;bi;an;lbo6rh5;us;rg",
  "Region": "true\xA60:2O;1:2L;2:2U;3:2F;a2Sb2Fc21d1Wes1Vf1Tg1Oh1Ki1Fj1Bk16l13m0Sn09o07pYqVrSsJtEuBverAw6y4zacatec2W;akut0o0Fu4;cat1k09;a5est 4isconsin,yomi1O;bengal,virgin0;rwick3shington4;! dc;acruz,mont;dmurt0t4;ah,tar4; 2Pa12;a6e5laxca1Vripu21u4;scaEva;langa2nnessee,x2J;bas10m4smQtar29;aulip2Hil nadu;a9elang07i7o5taf16u4ylh1J;ff02rr09s1E;me1Gno1Uuth 4;cZdY;ber0c4kkim,naloa;hu1ily;n5rawak,skatchew1xo4;ny; luis potosi,ta catari2;a4hodeA;j4ngp0C;asth1shahi;ingh29u4;e4intana roo;bec,en6retaro;aAe6rince edward4unjab; i4;sl0G;i,n5r4;ak,nambu0F;a0Rnsylv4;an0;ha0Pra4;!na;axa0Zdisha,h4klaho21ntar4reg7ss0Dx0I;io;aLeEo6u4;evo le4nav0X;on;r4tt18va scot0;f9mandy,th4; 4ampton3;c6d5yo4;rk3;ako1O;aroli2;olk;bras1Nva0Dw4; 6foundland4;! and labrad4;or;brunswick,hamp3jers5mexiTyork4;! state;ey;galPyarit;aAeghala0Mi6o4;nta2r4;dov0elos;ch6dlanDn5ss4zor11;issippi,ouri;as geraPneso18;ig1oac1;dhy12harasht0Gine,lac07ni5r4ssachusetts;anhao,i el,ylG;p4toba;ur;anca3e4incoln3ouisI;e4iR;ds;a6e5h4omi;aka06ul2;dah,lant1ntucky,ra01;bardino,lmyk0ns0Qr4;achay,el0nata0X;alis6har4iangxi;kh4;and;co;daho,llino7n4owa;d5gush4;et0;ia2;is;a6ert5i4un1;dalFm0D;ford3;mp3rya2waii;ansu,eorg0lou7oa,u4;an4izhou,jarat;ajuato,gdo4;ng;cester3;lori4uji1;da;sex;ageUe7o5uran4;go;rs4;et;lawaMrby3;aFeaEh9o4rim08umbr0;ahui7l6nnectic5rsi4ventry;ca;ut;i03orado;la;e5hattisgarh,i4uvash0;apRhuahua;chn5rke4;ss0;ya;ra;lGm4;bridge3peche;a9ihar,r8u4;ck4ryat0;ingham3;shi4;re;emen,itish columb0;h0ja cal8lk7s4v7;hkorto4que;st1;an;ar0;iforn0;ia;dygHguascalientes,lBndhr9r5ss4;am;izo2kans5un4;achal 7;as;na;a 4;pradesh;a6ber5t4;ai;ta;ba5s4;ka;ma;ea",
  "Place": "true\xA60:4T;1:4V;2:44;3:4B;4:3I;a4Eb3Gc2Td2Ge26f25g1Vh1Ji1Fk1Cl14m0Vn0No0Jp08r04sTtNuLvJw7y5;a5o0Syz;kut1Bngtze;aDeChitBi9o5upatki,ycom2P;ki26o5;d5l1B;b3Ps5;i4to3Y;c0SllowbroCn5;c2Qgh2;by,chur1P;ed0ntw3Gs22;ke6r3St5;erf1f1; is0Gf3V;auxha3Mirgin is0Jost5;ok;laanbaatar,pto5xb3E;n,wn;a9eotihuac43h7ive49o6ru2Nsarskoe selo,u5;l2Dzigo47;nto,rquay,tt2J;am3e 5orn3E;bronx,hamptons;hiti,j mah0Iu1N;aEcotts bluff,eCfo,herbroQoApring9t7u5yd2F;dbu1Wn5;der03set3B;aff1ock2Nr5;atf1oud;hi37w24;ho,uth5; 1Iam1Zwo3E;a5i2O;f2Tt0;int lawrence riv3Pkhal2D;ayleigh,ed7i5oc1Z;chmo1Eo gran4ver5;be1Dfr09si4; s39cliffe,hi2Y;aCe9h8i5ompeii,utn2;c6ne5tcai2T; 2Pc0G;keri13t0;l,x;k,lh2mbr6n5r2J;n1Hzance;oke;cif38pahanaumokuak30r5;k5then0;si4w1K;ak7r6x5;f1l2X;ange county,d,f1inoco;mTw1G;e8i1Uo5;r5tt2N;th5wi0E; 0Sam19;uschwanste1Pw5; eng6a5h2market,po36;rk;la0P;a8co,e6i5uc;dt1Yll0Z;adow5ko0H;lands;chu picchu,gad2Ridsto1Ql8n7ple6r5;kh2; g1Cw11;hatt2Osf2B;ibu,t0ve1Z;a8e7gw,hr,in5owlOynd02;coln memori5dl2C;al;asi4w3;kefr7mbe1On5s,x;ca2Ig5si05;f1l27t0;ont;azan kreml14e6itchen2Gosrae,rasnoyar5ul;sk;ns0Hs1U;ax,cn,lf1n6ps5st;wiN;d5glew0Lverness;ian27ochina;aDeBi6kg,nd,ov5unti2H;d,enweep;gh6llc5;reL;bu03l5;and5;!s;r5yw0C;ef1tf1;libu24mp6r5stings;f1lem,row;stead,t0;aDodavari,r5uelph;avenAe5imsS;at 8en5; 6f1Fwi5;ch;acr3vall1H;brita0Flak3;hur5;st;ng3y villa0W;airhavHco,ra;aAgli9nf17ppi8u7ver6x5;et1Lf1;glad3t0;rope,st0;ng;nt0;rls1Ls5;t 5;e5si4;nd;aCe9fw,ig8o7ryd6u5xb;mfri3nstab00rh2tt0;en;nca18rcKv19wnt0B;by;n6r5vonpo1D;ry;!h2;nu8r5;l6t5;f1moor;ingt0;be;aLdg,eIgk,hClBo5royd0;l6m5rnwa0B;pt0;c7lingw6osse5;um;ood;he0S;earwat0St;a8el6i5uuk;chen itza,mney ro07natSricahua;m0Zt5;enh2;mor5rlottetPth2;ro;dar 5ntervilA;breaks,faZg5;rove;ld9m8r5versh2;lis6rizo pla5;in;le;bLpbellf1;weQ;aZcn,eNingl01kk,lackLolt0r5uckV;aGiAo5;ckt0ok5wns cany0;lyn,s5;i4to5;ne;de;dge6gh5;am,t0;n6t5;own;or5;th;ceb6m5;lNpt0;rid5;ge;bu5pool,wa8;rn;aconsfEdf1lBr9verly7x5;hi5;ll; hi5;lls;wi5;ck; air,l5;ingh2;am;ie5;ld;ltimore,rnsl6tters5;ea;ey;bLct0driadic,frica,ginJlGmFn9rc8s7tl6yleOzor3;es;!ant8;hcroft,ia; de triomphe,t6;adyr,ca8dov9tarct5;ic5; oce5;an;st5;er;ericas,s;be6dersh5hambra,list0;ot;rt0;cou5;rt;bot7i5;ngd0;on;sf1;ord",
  "Country": "true\xA60:38;1:2L;2:3B;a2Xb2Ec22d1Ye1Sf1Mg1Ch1Ai14j12k0Zl0Um0Gn05om2pZqat1KrXsKtCu7v5wal4yemTz3;a25imbabwe;es,lis and futu2Y;a3enezue32ietnam;nuatu,tican city;gTk6nited 4ruXs3zbeE; 2Ca,sr;arab emirat0Kkingdom,states3;! of am2Y;!raiV;a8haCimor les0Co7rinidad 5u3;nis0rk3valu;ey,me2Zs and caic1V;and t3t3;oba1L;go,kel10nga;iw2ji3nz2T;ki2V;aDcotl1eCi9lov8o6pa2Dri lanka,u5w3yr0;az3edAitzerl1;il1;d2riname;lomon1Xmal0uth 3;afr2KkMsud2;ak0en0;erra leoFn3;gapo1Yt maart3;en;negLrb0ychellZ;int 3moa,n marino,udi arab0;hele26luc0mart21;epublic of ir0Eom2Euss0w3;an27;a4eIhilippinUitcairn1Mo3uerto riN;l1rtugF;ki2Dl4nama,pua new0Vra3;gu7;au,esti3;ne;aBe9i7or3;folk1Ith4w3;ay; k3ern mariana1D;or0O;caragua,ger3ue;!ia;p3ther1Aw zeal1;al;mib0u3;ru;a7exi6icro0Bo3yanm06;ldova,n3roc5zambA;a4gol0t3;enegro,serrat;co;cAdagasc01l7r5urit4yot3;te;an0i16;shall0Xtin3;ique;a4div3i,ta;es;wi,ys0;ao,ed02;a6e5i3uxembourg;b3echtenste12thu1G;er0ya;ban0Isotho;os,tv0;azakh1Fe4iriba04o3uwait,yrgyz1F;rXsovo;eling0Knya;a3erG;ma16p2;c7nd6r4s3taly,vory coast;le of m2rael;a3el1;n,q;ia,oJ;el1;aiTon3ungary;dur0Ng kong;aBermany,ha0QibraltAre8u3;a6ern5inea3ya0P;! biss3;au;sey;deloupe,m,tema0Q;e3na0N;ce,nl1;ar;bUmb0;a7i6r3;ance,ench 3;guia0Epoly3;nes0;ji,nl1;lklandUroeU;ast tim7cu6gypt,l salv6ngl1quatorial4ritr5st3thiop0;on0; guin3;ea;ad3;or;enmark,jibou5ominica4r con3;go;!n C;ti;aBentral african Ah8o5roat0u4yprRzech3; 9ia;ba,racao;c4lo3morQngo brazzaville,okGsta r04te de ivoiL;mb0;osE;i3ristmasG;le,na;republic;m3naUpe verde,ymanA;bod0ero3;on;aGeDhut2o9r5u3;lgar0r3;kina faso,ma,undi;azil,itish 3unei;virgin3; is3;lands;liv0nai5snia and herzegoviHtswaHuvet3; isl1;and;re;l3n8rmuG;ar3gium,ize;us;h4ngladesh,rbad3;os;am4ra3;in;as;fghaGlDmBn6r4ustr3zerbaij2;al0ia;genti3men0uba;na;dorra,g5t3;arct7igua and barbu3;da;o3uil3;la;er3;ica;b3ger0;an0;ia;ni3;st2;an",
  "FirstName": "true\xA6aTblair,cQdOfrancoZgabMhinaLilya,jHkClBm6ni4quinn,re3s0;h0umit,yd;ay,e0iloh;a,lby;g9ne;co,ko0;!s;a1el0ina,org6;!okuhF;ds,naia,r1tt0xiB;i,y;ion,lo;ashawn,eif,uca;a3e1ir0rM;an;lsFn0rry;dall,yat5;i,sD;a0essIie,ude;i1m0;ie,mG;me;ta;rie0y;le;arcy,ev0;an,on;as1h0;arl8eyenne;ey,sidy;drien,kira,l4nd1ubr0vi;ey;i,r0;a,e0;a,y;ex2f1o0;is;ie;ei,is",
  "WeekDay": "true\xA6fri2mon2s1t0wednesd3;hurs1ues1;aturd1und1;!d0;ay0;!s",
  "Month": "true\xA6dec0february,july,nov0octo1sept0;em0;ber",
  "Date": "true\xA6ago,on4som4t1week0yesterd5; end,ends;mr1o0;d2morrow;!w;ed0;ay",
  "Duration": "true\xA6centurAd8h7m5q4se3w1y0;ear8r8;eek0k7;!end,s;ason,c5;tr,uarter;i0onth3;llisecond2nute2;our1r1;ay0ecade0;!s;ies,y",
  "FemaleName": "true\xA60:J7;1:JB;2:IJ;3:IK;4:J1;5:IO;6:JS;7:JO;8:HB;9:JK;A:H4;B:I2;C:IT;D:JH;E:IX;F:BA;G:I4;aGTbFLcDRdD0eBMfB4gADh9Ti9Gj8Dk7Cl5Wm48n3Lo3Hp33qu32r29s15t0Eu0Cv02wVxiTyOzH;aLeIineb,oHsof3;e3Sf3la,ra;h2iKlIna,ynH;ab,ep;da,ma;da,h2iHra;nab;aKeJi0FolB7uIvH;et8onDP;i0na;le0sen3;el,gm3Hn,rGLs8W;aoHme0nyi;m5XyAD;aMendDZhiDGiH;dele9lJnH;if48niHo0;e,f47;a,helmi0lHma;a,ow;ka0nB;aNeKiHusa5;ck84kIl8oleAviH;anFenJ4;ky,toriBK;da,lA8rHs0;a,nHoniH9;a,iFR;leHnesH9;nILrH;i1y;g9rHs6xHA;su5te;aYeUhRiNoLrIuHy2;i,la;acJ3iHu0J;c3na,sH;hFta;nHr0F;iFya;aJffaEOnHs6;a,gtiH;ng;!nFSra;aIeHomasi0;a,l9Oo8Ares1;l3ndolwethu;g9Fo88rIssH;!a,ie;eHi,ri7;sa,za;bOlMmKnIrHs6tia0wa0;a60yn;iHya;a,ka,s6;arFe2iHm77ra;!ka;a,iH;a,t6;at6it6;a0Ecarlett,e0AhWiSkye,neza0oQri,tNuIyH;bIGlvi1;ha,mayIJniAsIzH;an3Net8ie,y;anHi7;!a,e,nH;aCe;aIeH;fan4l5Dphan6E;cI5r5;b3fiAAm0LnHphi1;d2ia,ja,ya;er2lJmon1nIobh8QtH;a,i;dy;lETv3;aMeIirHo0risFDy5;a,lDM;ba,e0i5lJrH;iHr6Jyl;!d8Ifa;ia,lDZ;hd,iMki2nJrIu0w0yH;la,ma,na;i,le9on,ron,yn;aIda,ia,nHon;a,on;!ya;k6mH;!aa;lJrItaye82vH;da,inj;e0ife;en1i0ma;anA9bLd5Oh1SiBkKlJmInd2rHs6vannaC;aCi0;ant6i2;lDOma,ome;ee0in8Tu2;in1ri0;a05eZhXiUoHuthDM;bScRghQl8LnPsJwIxH;anB3ie,y;an,e0;aIeHie,lD;ann7ll1marDGtA;!lHnn1;iHyn;e,nH;a,dF;da,i,na;ayy8G;hel67io;bDRerAyn;a,cIkHmas,nFta,ya;ki,o;h8Xki;ea,iannGMoH;da,n1P;an0bJemFgi0iInHta,y0;a8Bee;han86na;a,eH;cHkaC;a,ca;bi0chIe,i0mo0nHquETy0;di,ia;aERelHiB;!e,le;een4ia0;aPeOhMiLoJrHute6A;iHudenCV;scil3LyamvaB;lHrt3;i0ly;a,paluk;ilome0oebe,ylH;is,lis;ggy,nelope,r5t2;ige,m0VnKo5rvaDMtIulH;a,et8in1;ricHt4T;a,e,ia;do2i07;ctav3dIfD3is6ksa0lHphD3umC5yunbileg;a,ga,iv3;eHvAF;l3t8;aWeUiMoIurHy5;!ay,ul;a,eJor,rIuH;f,r;aCeEma;ll1mi;aNcLhariBQkKlaJna,sHta,vi;anHha;ur;!y;a,iDZki;hoGk9YolH;a,e4P;!mh;hir,lHna,risDEsreE;!a,lBV;asuMdLh3i6Dl5nKomi7rgEVtH;aHhal4;lHs6;i1ya;cy,et8;e9iF0ya;nngu2X;a0Ackenz4e02iMoJrignayani,uriDJyH;a,rH;a,iOlNna,tG;bi0i2llBJnH;a,iH;ca,ka,qD9;a,cUdo4ZkaTlOmi,nMrItzi,yH;ar;aJiIlH;anET;am;!l,nB;dy,eHh,n4;nhGrva;aKdJe0iCUlH;iHy;cent,e;red;!gros;!e5;ae5hH;ae5el3Z;ag5DgNi,lKrH;edi7AiIjem,on,yH;em,l;em,sCG;an4iHliCF;nHsCJ;a,da;!an,han;b09cASd07e,g05ha,i04ja,l02n00rLsoum5YtKuIv84xBKyHz4;bell,ra,soBB;d7rH;a,eE;h8Gild1t4;a,cUgQiKjor4l7Un4s6tJwa,yH;!aHbe6Xja9lAE;m,nBL;a,ha,in1;!aJbCGeIja,lDna,sHt63;!a,ol,sa;!l1D;!h,mInH;!a,e,n1;!awit,i;arJeIie,oHr48ueri8;!t;!ry;et46i3B;el4Xi7Cy;dHon,ue5;akranAy;ak,en,iHlo3S;a,ka,nB;a,re,s4te;daHg4;!l3E;alDd4elHge,isDJon0;ei9in1yn;el,le;a0Ne0CiXoQuLyH;d3la,nH;!a,dIe2OnHsCT;!a,e2N;a,sCR;aD4cJel0Pis1lIna,pHz;e,iA;a,u,wa;iHy;a0Se,ja,l2NnB;is,l1UrItt1LuHvel4;el5is1;aKeIi7na,rH;aADi7;lHn1tA;ei;!in1;aTbb9HdSepa,lNnKsJvIzH;!a,be5Ret8z4;!ia;a,et8;!a,dH;a,sHy;ay,ey,i,y;a,iJja,lH;iHy;aA8e;!aH;!nF;ia,ya;!nH;!a,ne;aPda,e0iNjYla,nMoKsJtHx93y5;iHt4;c3t3;e2PlCO;la,nHra;a,ie,o2;a,or1;a,gh,laH;!ni;!h,nH;a,d2e,n5V;cOdon9DiNkes6mi9Gna,rMtJurIvHxmi,y5;ern1in3;a,e5Aie,yn;as6iIoH;nya,ya;fa,s6;a,isA9;a,la;ey,ie,y;a04eZhXiOlASoNrJyH;lHra;a,ee,ie;istHy6I;a,en,iIyH;!na;!e,n5F;nul,ri,urtnB8;aOerNlB7mJrHzzy;a,stH;en,in;!berlImernH;aq;eHi,y;e,y;a,stE;!na,ra;aHei2ongordzol;dij1w5;el7UiKjsi,lJnIrH;a,i,ri;d2na,za;ey,i,lBLs4y;ra,s6;biAcARdiat7MeBAiSlQmPnyakuma1DrNss6NtKviAyH;!e,lH;a,eH;e,i8T;!a6HeIhHi4TlDri0y;ar8Her8Hie,leErBAy;!lyn8Ori0;a,en,iHl5Xoli0yn;!ma,nFs95;a5il1;ei8Mi,lH;e,ie;a,tl6O;a0AeZiWoOuH;anMdLlHst88;es,iH;a8NeHs8X;!n9tH;!a,te;e5Mi3My;a,iA;!anNcelDdMelGhan7VleLni,sIva0yH;a,ce;eHie;fHlDph7Y;a,in1;en,n1;i7y;!a,e,n45;lHng;!i1DlH;!i1C;anNle0nKrJsH;i8JsH;!e,i8I;i,ri;!a,elGif2CnH;a,et8iHy;!e,f2A;a,eJiInH;a,eIiH;e,n1;!t8;cMda,mi,nIque4YsminFvie2y9zH;min7;a7eIiH;ce,e,n1s;!lHs82t0F;e,le;inIk6HlDquelH;in1yn;da,ta;da,lRmPnOo0rNsIvaHwo0zaro;!a0lu,na;aJiIlaHob89;!n9R;do2;belHdo2;!a,e,l3B;a7Ben1i0ma;di2es,gr72ji;a9elBogH;en1;a,e9iHo0se;a0na;aSeOiJoHus7Kyacin2C;da,ll4rten24snH;a,i9U;lImaH;ri;aIdHlaI;a,egard;ry;ath1BiJlInrietArmi9sH;sa,t1A;en2Uga,mi;di;bi2Fil8MlNnMrJsItHwa,yl8M;i5Tt4;n60ti;iHmo51ri53;etH;!te;aCnaC;a,ey,l4;a02eWiRlPoNrKunJwH;enHyne1R;!dolD;ay,el;acieIetHiselB;a,chE;!la;ld1CogooH;sh;adys,enHor3yn2K;a,da,na;aKgi,lIna,ov8EselHta;a,e,le;da,liH;an;!n0;mLnJorgIrH;ald5Si,m3Etrud7;et8i4X;a,eHna;s29vieve;ma;bIle,mHrnet,yG;al5Si5;iIrielH;a,l1;!ja;aTeQiPlorOoz3rH;anJeIiH;da,eB;da,ja;!cH;esIiHoi0P;n1s66;!ca;a,enc3;en,o0;lIn0rnH;anB;ec3ic3;jr,nArKtHy7;emIiHma,oumaA;ha,ma,n;eh;ah,iBrah,za0;cr4Rd0Re0Qi0Pk0Ol07mXn54rUsOtNuMvHwa;aKelIiH;!e,ta;inFyn;!a;!ngel4V;geni1ni47;h5Yien9ta;mLperanKtH;eIhHrel5;er;l31r7;za;a,eralB;iHma,ne4Lyn;cHka,n;a,ka;aPeNiKmH;aHe21ie,y;!li9nuH;elG;lHn1;e7iHy;a,e,ja;lHrald;da,y;!nue5;aWeUiNlMma,no2oKsJvH;a,iH;na,ra;a,ie;iHuiH;se;a,en,ie,y;a0c3da,e,f,nMsJzaH;!betHveA;e,h;aHe,ka;!beH;th;!a,or;anor,nH;!a,i;!in1na;ate1Rta;leEs6;vi;eIiHna,wi0;e,th;l,n;aYeMh3iLjeneKoH;lor5Vminiq4Ln3FrHtt4;a,eEis,la,othHthy;ea,y;ba;an09naCon9ya;anQbPde,eOiMlJmetr3nHsir5M;a,iH;ce,se;a,iIla,orHphi9;es,is;a,l6F;dHrdH;re;!d5Ena;!b2ForaCraC;a,d2nH;!a,e;hl3i0l0GmNnLphn1rIvi1WyH;le,na;a,by,cIia,lH;a,en1;ey,ie;a,et8iH;!ca,el1Aka,z;arHia;is;a0Re0Nh04i02lUoJristIynH;di,th3;al,i0;lPnMrIurH;tn1D;aJd2OiHn2Ori9;!nH;a,e,n1;!l4;cepci5Cn4sH;tanHuelo;ce,za;eHleE;en,t8;aJeoIotH;il54;!pat2;ir7rJudH;et8iH;a,ne;a,e,iH;ce,sZ;a2er2ndH;i,y;aReNloe,rH;isJyH;stH;al;sy,tH;a1Sen,iHy;an1e,n1;deJlseIrH;!i7yl;a,y;li9;nMrH;isKlImH;ai9;a,eHot8;n1t8;!sa;d2elGtH;al,elG;cIlH;es8i47;el3ilH;e,ia,y;itlYlXmilWndVrMsKtHy5;aIeIhHri0;er1IleErDy;ri0;a38sH;a37ie;a,iOlLmeJolIrH;ie,ol;!e,in1yn;lHn;!a,la;a,eIie,otHy;a,ta;ne,y;na,s1X;a0Ii0I;a,e,l1;isAl4;in,yn;a0Ke02iZlXoUrH;andi7eRiJoIyH;an0nn;nwDoke;an3HdgMgiLtH;n31tH;!aInH;ey,i,y;ny;d,t8;etH;!t7;an0e,nH;da,na;bbi7glarIlo07nH;iAn4;ka;ancHythe;a,he;an1Clja0nHsm3M;iAtH;ou;aWcVlinUniArPssOtJulaCvH;!erlH;ey,y;hJsy,tH;e,iHy7;e,na;!anH;ie,y;!ie;nItHyl;ha,ie;adIiH;ce;et8i9;ay,da;ca,ky;!triH;ce,z;rbJyaH;rmH;aa;a2o2ra;a2Ub2Od25g21i1Sj5l18m0Zn0Boi,r06sWtVuPvOwa,yIzH;ra,u0;aKes6gJlIn,seH;!l;in;un;!nH;a,na;a,i2K;drLguJrIsteH;ja;el3;stH;in1;a,ey,i,y;aahua,he0;hIi2Gja,miAs2DtrH;id;aMlIraqHt21;at;eIi7yH;!n;e,iHy;gh;!nH;ti;iJleIo6piA;ta;en,n1t8;aHelG;!n1J;a01dje5eZgViTjRnKohito,toHya;inet8nH;el5ia;te;!aKeIiHmJ;e,ka;!mHtt7;ar4;!belIliHmU;sa;!l1;a,eliH;ca;ka,sHta;a,sa;elHie;a,iH;a,ca,n1qH;ue;!tH;a,te;!bImHstasiMya;ar3;el;aLberKeliJiHy;e,l3naH;!ta;a,ja;!ly;hGiIl3nB;da;a,ra;le;aWba,ePiMlKthJyH;a,c3sH;a,on,sa;ea;iHys0N;e,s0M;a,cIn1sHza;a,e,ha,on,sa;e,ia,ja;c3is6jaKksaKna,sJxH;aHia;!nd2;ia,saH;nd2;ra;ia;i0nIyH;ah,na;a,is,naCoud;la;c6da,leEmNnLsH;haClH;inHyY;g,n;!h;a,o,slH;ey;ee;en;at6g4nIusH;ti0;es;ie;aWdiTelMrH;eJiH;anMenH;a,e,ne;an0;na;!aLeKiIyH;nn;a,n1;a,e;!ne;!iH;de;e,lDsH;on;yn;!lH;i9yn;ne;aKbIiHrL;!e,gaK;ey,i7y;!e;gaH;il;dKliyJradhIs6;ha;ya;ah;a,ya",
  "Honorific": "true\xA6director1field marsh2lieutenant1rear0sergeant major,vice0; admir1; gener0;al",
  "Adj|Gerund": "true\xA60:3F;1:3H;2:31;3:2X;4:35;5:33;6:3C;7:2Z;8:36;9:29;a33b2Tc2Bd1Te1If19g12h0Zi0Rl0Nm0Gnu0Fo0Ap04rYsKtEuBvAw1Ayiel3;ar6e08;nBpA;l1Rs0B;fol3n1Zsett2;aEeDhrBi4ouc7rAwis0;e0Bif2oub2us0yi1;ea1SiA;l2vi1;l2mp0rr1J;nt1Vxi1;aMcreec7enten2NhLkyrocke0lo0Vmi2oJpHtDuBweA;e0Ul2;pp2ArA;gi1pri5roun3;aBea8iAri2Hun9;mula0r4;gge4rA;t2vi1;ark2eAraw2;e3llb2F;aAot7;ki1ri1;i9oc29;dYtisf6;aEeBive0oAus7;a4l2;assu4defi9fres7ig9juve07mai9s0vAwar3;ea2italiAol1G;si1zi1;gi1ll6mb2vi1;a6eDier23lun1VrAun2C;eBoA;mi5vo1Z;ce3s5vai2;n3rpleA;xi1;ffCpWutBverAwi1;arc7lap04p0Pri3whel8;goi1l6st1J;en3sA;et0;m2Jrtu4;aEeDiCoBuAyst0L;mb2;t1Jvi1;s5tiga0;an1Rl0n3smeri26;dAtu4;de9;aCeaBiAo0U;fesa0Tvi1;di1ni1;c1Fg19s0;llumiGmFnArri0R;cDfurHsCtBviA;go23ti1;e1Oimi21oxica0rig0V;pi4ul0;orpo20r0K;po5;na0;eaBorr02umilA;ia0;li1rtwar8;lFrA;atiDipCoBuelA;i1li1;undbrea10wi1;pi1;f6ng;a4ea8;a3etc7it0lEoCrBulfA;il2;ee1FighXust1L;rAun3;ebo3thco8;aCoA;a0wA;e4i1;mi1tte4;lectrJmHnExA;aCci0hBis0pA;an3lo3;aOila1B;c0spe1A;ab2coura0CdBergi13ga0Clive9ric7s02tA;hral2i0J;ea4u4;barras5er09pA;owe4;if6;aQeIiBrA;if0;sAzz6;aEgDhearCsen0tA;rAur11;ac0es5;te9;us0;ppoin0r8;biliGcDfi9gra3ligh0mBpres5sAvasG;erE;an3ea9orA;ali0L;a6eiBli9rA;ea5;vi1;ta0;maPri1s7un0zz2;aPhMlo5oAripp2ut0;mGnArrespon3;cer9fDspi4tA;inBrA;as0ibu0ol2;ui1;lic0u5;ni1;fDmCpA;eAromi5;l2ti1;an3;or0;aAil2;llenAnAr8;gi1;l8ptAri1;iva0;aff2eGin3lFoDrBuA;d3st2;eathtaAui5;ki1;gg2i2o8ri1unA;ci1;in3;co8wiA;lAtc7;de4;bsorVcOgonMlJmHnno6ppea2rFsA;pi4su4toA;nBun3;di1;is7;hi1;res0;li1;aFu5;si1;ar8lu4;ri1;mi1;iAzi1;zi1;cAhi1;eleDomA;moBpan6;yi1;da0;ra0;ti1;bi1;ng",
  "Comparable": "true\xA60:3C;1:3Q;2:3F;a3Tb3Cc33d2Te2Mf2Ag1Wh1Li1Fj1Ek1Bl13m0Xn0So0Rp0Iqu0Gr07sHtCug0vAw4y3za0Q;el10ouN;ary,e6hi5i3ry;ck0Cde,l3n1ry,se;d,y;ny,te;a3i3R;k,ry;a3erda2ulgar;gue,in,st;a6en2Xhi5i4ouZr3;anqu2Cen1ue;dy,g36me0ny;ck,rs28;ll,me,rt,wd3I;aRcaPeOhMiLkin0BlImGoEpDt6u4w3;eet,ift;b3dd0Wperfi21rre28;sta26t21;a8e7iff,r4u3;pUr1;a4ict,o3;ng;ig2Vn0N;a1ep,rn;le,rk,te0;e1Si2Vright0;ci1Yft,l3on,re;emn,id;a3el0;ll,rt;e4i3y;g2Mm0Z;ek,nd2T;ck24l0mp1L;a3iRrill,y;dy,l01rp;ve0Jxy;n1Jr3;ce,y;d,fe,int0l1Hv0V;a8e6i5o3ude;mantic,o19sy,u3;gh;pe,t1P;a3d,mo0A;dy,l;gg4iFndom,p3re,w;id;ed;ai2i3;ck,et;hoAi1Fl9o8r5u3;ny,r3;e,p11;egna2ic4o3;fouSud;ey,k0;liXor;ain,easa2;ny;dd,i0ld,ranL;aive,e5i4o3u14;b0Sisy,rm0Ysy;bb0ce,mb0R;a3r1w;r,t;ad,e5ild,o4u3;nda12te;ist,o1;a4ek,l3;low;s0ty;a8e7i6o3ucky;f0Jn4o15u3ve0w10y0N;d,sy;e0g;ke0l,mp,tt0Eve0;e1Qwd;me,r3te;ge;e4i3;nd;en;ol0ui19;cy,ll,n3;secu6t3;e3ima4;llege2rmedia3;te;re;aAe7i6o5u3;ge,m3ng1C;bYid;me0t;gh,l0;a3fXsita2;dy,rWv3;en0y;nd13ppy,r3;d3sh;!y;aFenEhCiBlAoofy,r3;a8e6i5o3ue0Z;o3ss;vy;m,s0;at,e3y;dy,n;nd,y;ad,ib,ooD;a2d1;a3o3;st0;tDuiS;u1y;aCeebBi9l8o6r5u3;ll,n3r0N;!ny;aCesh,iend0;a3nd,rmD;my;at,ir7;erce,nan3;ci9;le;r,ul3;ty;a6erie,sse4v3xtre0B;il;nti3;al;r4s3;tern,y;ly,th0;appZe9i5ru4u3;mb;nk;r5vi4z3;zy;ne;e,ty;a3ep,n9;d3f,r;!ly;agey,h8l7o5r4u3;dd0r0te;isp,uel;ar3ld,mmon,st0ward0zy;se;evKou1;e3il0;ap,e3;sy;aHiFlCoAr5u3;ff,r0sy;ly;a6i3oad;g4llia2;nt;ht;sh,ve;ld,un3;cy;a4o3ue;nd,o1;ck,nd;g,tt3;er;d,ld,w1;dy;bsu6ng5we3;so3;me;ry;rd",
  "Adverb": "true\xA6a08b05d00eYfSheQinPjustOkinda,likewiZmMnJoEpCquite,r9s5t2u0very,well;ltima01p0; to,wards5;h1iny bit,o0wiO;o,t6;en,us;eldom,o0uch;!me1rt0; of;how,times,w0C;a1e0;alS;ndomRth05;ar excellenEer0oint blank; Lhaps;f3n0utright;ce0ly;! 0;ag05moX; courGten;ewJo0; longWt 0;onHwithstand9;aybe,eanwhiNore0;!ovT;! aboX;deed,steY;lla,n0;ce;or3u0;ck1l9rther0;!moK;ing; 0evK;exampCgood,suH;n mas0vI;se;e0irect2; 2fini0;te0;ly;juAtrop;ackward,y 0;far,no0; means,w; GbroFd nauseam,gEl7ny5part,s4t 2w0;ay,hi0;le;be7l0mo7wor7;arge,ea6; soon,i4;mo0way;re;l 3mo2ongsi1ready,so,togeth0ways;er;de;st;b1t0;hat;ut;ain;ad;lot,posteriori",
  "Conjunction": "true\xA6aXbTcReNhowMiEjust00noBo9p8supposing,t5wh0yet;e1il0o3;e,st;n1re0thN; if,by,vM;evL;h0il,o;erefOo0;!uU;lus,rovided th9;r0therwiM;! not; mattEr,w0;! 0;since,th4w7;f4n0; 0asmuch;as mIcaForder t0;h0o;at;! 0;only,t0w0;hen;!ev3;ith2ven0;! 0;if,tB;er;o0uz;s,z;e0ut,y the time;cau1f0;ore;se;lt3nd,s 0;far1if,m0soon1t2;uch0; as;hou0;gh",
  "Currency": "true\xA6$,aud,bQcOdJeurIfHgbp,hkd,iGjpy,kElDp8r7s3usd,x2y1z0\xA2,\xA3,\xA5,\u0434\u0435\u043D,\u043B\u0432,\u0440\u0443\u0431,\u0E3F,\u20A1,\u20A8,\u20AC,\u20AD,\uFDFC;lotyQ\u0142;en,uanP;af,of;h0t5;e0il5;k0q0;elK;oubleJp,upeeJ;e2ound st0;er0;lingG;n0soF;ceEnies;empi7i7;n,r0wanzaCyatC;!onaBw;ls,nr;ori7ranc9;!os;en3i2kk,o0;b0ll2;ra5;me4n0rham4;ar3;e0ny;nt1;aht,itcoin0;!s",
  "Determiner": "true\xA6aBboth,d9e6few,le5mu8neiDplenty,s4th2various,wh0;at0ich0;evC;a0e4is,ose;!t;everal,ome;!ast,s;a1l0very;!se;ch;e0u;!s;!n0;!o0y;th0;er",
  "Adj|Present": "true\xA6a07b04cVdQeNfJhollIidRlEmCnarrIoBp9qua8r7s3t2uttFw0;aKet,ro0;ng,u08;endChin;e2hort,l1mooth,our,pa9tray,u0;re,speU;i2ow;cu6da02leSpaN;eplica01i02;ck;aHerfePr0;eseUime,omV;bscu1pen,wn;atu0e3odeH;re;a2e1ive,ow0;er;an;st,y;ow;a2i1oul,r0;ee,inge;rm;iIke,ncy,st;l1mpty,x0;emHpress;abo4ic7;amp,e2i1oub0ry,ull;le;ffu9re6;fu8libe0;raE;alm,l5o0;mpleCn3ol,rr1unterfe0;it;e0u7;ct;juga8sum7;ea1o0;se;n,r;ankru1lu0;nt;pt;li2pproxi0rticula1;ma0;te;ght",
  "Person|Adj": "true\xA6b3du2earnest,frank,mi2r0san1woo1;an0ich,u1;dy;sty;ella,rown",
  "Modal": "true\xA6c5lets,m4ought3sh1w0;ill,o5;a0o4;ll,nt;! to,a;ight,ust;an,o0;uld",
  "Verb": "true\xA6born,cannot,gonna,has,keep tabs,msg",
  "Person|Verb": "true\xA6b8ch7dr6foster,gra5ja9lan4ma2ni9ollie,p1rob,s0wade;kip,pike,t5ue;at,eg,ier2;ck,r0;k,shal;ce;ce,nt;ew;ase,u1;iff,l1ob,u0;ck;aze,ossom",
  "Person|Date": "true\xA6a2j0sep;an0une;!uary;p0ugust,v0;ril"
};

// node_modules/efrt/src/encoding.js
var BASE = 36;
var seq = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
var cache = seq.split("").reduce(function(h2, c2, i3) {
  h2[c2] = i3;
  return h2;
}, {});
var toAlphaCode = function(n3) {
  if (seq[n3] !== void 0) {
    return seq[n3];
  }
  let places2 = 1;
  let range = BASE;
  let s3 = "";
  for (; n3 >= range; n3 -= range, places2++, range *= BASE) {
  }
  while (places2--) {
    const d2 = n3 % BASE;
    s3 = String.fromCharCode((d2 < 10 ? 48 : 55) + d2) + s3;
    n3 = (n3 - d2) / BASE;
  }
  return s3;
};
var fromAlphaCode = function(s3) {
  if (cache[s3] !== void 0) {
    return cache[s3];
  }
  let n3 = 0;
  let places2 = 1;
  let range = BASE;
  let pow = 1;
  for (; places2 < s3.length; n3 += range, places2++, range *= BASE) {
  }
  for (let i3 = s3.length - 1; i3 >= 0; i3--, pow *= BASE) {
    let d2 = s3.charCodeAt(i3) - 48;
    if (d2 > 10) {
      d2 -= 7;
    }
    n3 += d2 * pow;
  }
  return n3;
};
var encoding_default = {
  toAlphaCode,
  fromAlphaCode
};

// node_modules/efrt/src/unpack/symbols.js
var symbols = function(t3) {
  const reSymbol = new RegExp("([0-9A-Z]+):([0-9A-Z]+)");
  for (let i3 = 0; i3 < t3.nodes.length; i3++) {
    const m3 = reSymbol.exec(t3.nodes[i3]);
    if (!m3) {
      t3.symCount = i3;
      break;
    }
    t3.syms[encoding_default.fromAlphaCode(m3[1])] = encoding_default.fromAlphaCode(m3[2]);
  }
  t3.nodes = t3.nodes.slice(t3.symCount, t3.nodes.length);
};
var symbols_default = symbols;

// node_modules/efrt/src/unpack/traverse.js
var indexFromRef = function(trie, ref, index4) {
  const dnode = encoding_default.fromAlphaCode(ref);
  if (dnode < trie.symCount) {
    return trie.syms[dnode];
  }
  return index4 + dnode + 1 - trie.symCount;
};
var toArray = function(trie) {
  const all4 = [];
  const crawl = (index4, pref) => {
    let node = trie.nodes[index4];
    if (node[0] === "!") {
      all4.push(pref);
      node = node.slice(1);
    }
    const matches3 = node.split(/([A-Z0-9,]+)/g);
    for (let i3 = 0; i3 < matches3.length; i3 += 2) {
      const str = matches3[i3];
      const ref = matches3[i3 + 1];
      if (!str) {
        continue;
      }
      const have = pref + str;
      if (ref === "," || ref === void 0) {
        all4.push(have);
        continue;
      }
      const newIndex = indexFromRef(trie, ref, index4);
      crawl(newIndex, have);
    }
  };
  crawl(0, "");
  return all4;
};
var unpack = function(str) {
  const trie = {
    nodes: str.split(";"),
    syms: [],
    symCount: 0
  };
  if (str.match(":")) {
    symbols_default(trie);
  }
  return toArray(trie);
};
var traverse_default = unpack;

// node_modules/efrt/src/unpack/index.js
var unpack2 = function(str) {
  if (!str) {
    return {};
  }
  const obj = str.split("|").reduce((h2, s3) => {
    const arr = s3.split("\xA6");
    h2[arr[0]] = arr[1];
    return h2;
  }, {});
  const all4 = {};
  Object.keys(obj).forEach(function(cat) {
    const arr = traverse_default(obj[cat]);
    if (cat === "true") {
      cat = true;
    }
    for (let i3 = 0; i3 < arr.length; i3++) {
      const k2 = arr[i3];
      if (all4.hasOwnProperty(k2) === true) {
        if (Array.isArray(all4[k2]) === false) {
          all4[k2] = [all4[k2], cat];
        } else {
          all4[k2].push(cat);
        }
      } else {
        all4[k2] = cat;
      }
    }
  });
  return all4;
};
var unpack_default = unpack2;

// node_modules/compromise/src/2-two/preTagger/model/lexicon/misc.js
var prp = ["Possessive", "Pronoun"];
var misc = {
  // numbers
  "20th century fox": "Organization",
  "7 eleven": "Organization",
  "motel 6": "Organization",
  g8: "Organization",
  vh1: "Organization",
  "76ers": "SportsTeam",
  "49ers": "SportsTeam",
  q1: "Date",
  q2: "Date",
  q3: "Date",
  q4: "Date",
  km2: "Unit",
  m2: "Unit",
  dm2: "Unit",
  cm2: "Unit",
  mm2: "Unit",
  mile2: "Unit",
  in2: "Unit",
  yd2: "Unit",
  ft2: "Unit",
  m3: "Unit",
  dm3: "Unit",
  cm3: "Unit",
  in3: "Unit",
  ft3: "Unit",
  yd3: "Unit",
  // ampersands
  "at&t": "Organization",
  "black & decker": "Organization",
  "h & m": "Organization",
  "johnson & johnson": "Organization",
  "procter & gamble": "Organization",
  "ben & jerry's": "Organization",
  "&": "Conjunction",
  //pronouns
  i: ["Pronoun", "Singular"],
  he: ["Pronoun", "Singular"],
  she: ["Pronoun", "Singular"],
  it: ["Pronoun", "Singular"],
  they: ["Pronoun", "Plural"],
  we: ["Pronoun", "Plural"],
  was: ["Copula", "PastTense"],
  is: ["Copula", "PresentTense"],
  are: ["Copula", "PresentTense"],
  am: ["Copula", "PresentTense"],
  were: ["Copula", "PastTense"],
  // possessive pronouns
  her: prp,
  his: prp,
  hers: prp,
  their: prp,
  theirs: prp,
  themselves: prp,
  your: prp,
  our: prp,
  ours: prp,
  my: prp,
  its: prp,
  // misc
  vs: ["Conjunction", "Abbreviation"],
  if: ["Condition", "Preposition"],
  closer: "Comparative",
  closest: "Superlative",
  much: "Adverb",
  may: "Modal",
  // irregular conjugations with two forms
  babysat: "PastTense",
  blew: "PastTense",
  drank: "PastTense",
  drove: "PastTense",
  forgave: "PastTense",
  skiied: "PastTense",
  spilt: "PastTense",
  stung: "PastTense",
  swam: "PastTense",
  swung: "PastTense",
  guaranteed: "PastTense",
  shrunk: "PastTense",
  // support 'near', 'nears', 'nearing'
  nears: "PresentTense",
  nearing: "Gerund",
  neared: "PastTense",
  no: ["Negative", "Expression"]
  // '-': 'Preposition', //june - july
  // there: 'There'
};
var misc_default2 = misc;

// node_modules/compromise/src/2-two/preTagger/model/lexicon/frozenLex.js
var frozenLex_default = {
  "20th century fox": "Organization",
  "7 eleven": "Organization",
  "motel 6": "Organization",
  "excuse me": "Expression",
  "financial times": "Organization",
  "guns n roses": "Organization",
  "la z boy": "Organization",
  "labour party": "Organization",
  "new kids on the block": "Organization",
  "new york times": "Organization",
  "the guess who": "Organization",
  "thin lizzy": "Organization",
  "prime minister": "Actor",
  "free market": "Singular",
  "lay up": "Singular",
  "living room": "Singular",
  "living rooms": "Plural",
  "spin off": "Singular",
  "appeal court": "Uncountable",
  "cold war": "Uncountable",
  "gene pool": "Uncountable",
  "machine learning": "Uncountable",
  "nail polish": "Uncountable",
  "time off": "Uncountable",
  "take part": "Infinitive",
  "bill gates": "Person",
  "doctor who": "Person",
  "dr who": "Person",
  "he man": "Person",
  "iron man": "Person",
  "kid cudi": "Person",
  "run dmc": "Person",
  "rush limbaugh": "Person",
  "snow white": "Person",
  "tiger woods": "Person",
  "brand new": "Adjective",
  "en route": "Adjective",
  "left wing": "Adjective",
  "off guard": "Adjective",
  "on board": "Adjective",
  "part time": "Adjective",
  "right wing": "Adjective",
  "so called": "Adjective",
  "spot on": "Adjective",
  "straight forward": "Adjective",
  "super duper": "Adjective",
  "tip top": "Adjective",
  "top notch": "Adjective",
  "up to date": "Adjective",
  "win win": "Adjective",
  "brooklyn nets": "SportsTeam",
  "chicago bears": "SportsTeam",
  "houston astros": "SportsTeam",
  "houston dynamo": "SportsTeam",
  "houston rockets": "SportsTeam",
  "houston texans": "SportsTeam",
  "minnesota twins": "SportsTeam",
  "orlando magic": "SportsTeam",
  "san antonio spurs": "SportsTeam",
  "san diego chargers": "SportsTeam",
  "san diego padres": "SportsTeam",
  "iron maiden": "ProperNoun",
  "isle of man": "Country",
  "united states": "Country",
  "united states of america": "Country",
  "prince edward island": "Region",
  "cedar breaks": "Place",
  "cedar falls": "Place",
  "point blank": "Adverb",
  "tiny bit": "Adverb",
  "by the time": "Conjunction",
  "no matter": "Conjunction",
  "civil wars": "Plural",
  "credit cards": "Plural",
  "default rates": "Plural",
  "free markets": "Plural",
  "head starts": "Plural",
  "home runs": "Plural",
  "lay ups": "Plural",
  "phone calls": "Plural",
  "press releases": "Plural",
  "record labels": "Plural",
  "soft serves": "Plural",
  "student loans": "Plural",
  "tax returns": "Plural",
  "tv shows": "Plural",
  "video games": "Plural",
  "took part": "PastTense",
  "takes part": "PresentTense",
  "taking part": "Gerund",
  "taken part": "Participle",
  "light bulb": "Noun",
  "rush hour": "Noun",
  "fluid ounce": "Unit",
  "the rolling stones": "Organization"
};

// node_modules/compromise/src/2-two/preTagger/model/lexicon/emoticons.js
var emoticons_default = [
  ":(",
  ":)",
  ":P",
  ":p",
  ":O",
  ";(",
  ";)",
  ";P",
  ";p",
  ";O",
  ":3",
  ":|",
  ":/",
  ":\\",
  ":$",
  ":*",
  ":@",
  ":-(",
  ":-)",
  ":-P",
  ":-p",
  ":-O",
  ":-3",
  ":-|",
  ":-/",
  ":-\\",
  ":-$",
  ":-*",
  ":-@",
  ":^(",
  ":^)",
  ":^P",
  ":^p",
  ":^O",
  ":^3",
  ":^|",
  ":^/",
  ":^\\",
  ":^$",
  ":^*",
  ":^@",
  "):",
  "(:",
  "$:",
  "*:",
  ")-:",
  "(-:",
  "$-:",
  "*-:",
  ")^:",
  "(^:",
  "$^:",
  "*^:",
  "<3",
  "</3",
  "<\\3",
  "=("
];

// node_modules/compromise/src/2-two/preTagger/methods/transform/nouns/toPlural/_rules.js
var suffixes = {
  a: [
    [/(antenn|formul|nebul|vertebr|vit)a$/i, "$1ae"],
    [/ia$/i, "ia"]
  ],
  e: [
    [/(kn|l|w)ife$/i, "$1ives"],
    [/(hive)$/i, "$1s"],
    [/([m|l])ouse$/i, "$1ice"],
    [/([m|l])ice$/i, "$1ice"]
  ],
  f: [
    [/^(dwar|handkerchie|hoo|scar|whar)f$/i, "$1ves"],
    [/^((?:ca|e|ha|(?:our|them|your)?se|she|wo)l|lea|loa|shea|thie)f$/i, "$1ves"]
  ],
  i: [[/(octop|vir)i$/i, "$1i"]],
  m: [[/([ti])um$/i, "$1a"]],
  n: [[/^(oxen)$/i, "$1"]],
  o: [[/(al|ad|at|er|et|ed)o$/i, "$1oes"]],
  s: [
    [/(ax|test)is$/i, "$1es"],
    [/(alias|status)$/i, "$1es"],
    [/sis$/i, "ses"],
    [/(bu)s$/i, "$1ses"],
    [/(sis)$/i, "ses"],
    [/^(?!talis|.*hu)(.*)man$/i, "$1men"],
    [/(octop|vir|radi|nucle|fung|cact|stimul)us$/i, "$1i"]
  ],
  x: [
    [/(matr|vert|ind|cort)(ix|ex)$/i, "$1ices"],
    [/^(ox)$/i, "$1en"]
  ],
  y: [[/([^aeiouy]|qu)y$/i, "$1ies"]],
  z: [[/(quiz)$/i, "$1zes"]]
};
var rules_default = suffixes;

// node_modules/compromise/src/2-two/preTagger/methods/transform/nouns/toPlural/index.js
var addE = /([xsz]|ch|sh)$/;
var trySuffix = function(str) {
  let c2 = str[str.length - 1];
  if (rules_default.hasOwnProperty(c2) === true) {
    for (let i3 = 0; i3 < rules_default[c2].length; i3 += 1) {
      let reg = rules_default[c2][i3][0];
      if (reg.test(str) === true) {
        return str.replace(reg, rules_default[c2][i3][1]);
      }
    }
  }
  return null;
};
var pluralize = function(str = "", model5) {
  let { irregularPlurals, uncountable: uncountable2 } = model5.two;
  if (uncountable2.hasOwnProperty(str)) {
    return str;
  }
  if (irregularPlurals.hasOwnProperty(str)) {
    return irregularPlurals[str];
  }
  let plural2 = trySuffix(str);
  if (plural2 !== null) {
    return plural2;
  }
  if (addE.test(str)) {
    return str + "es";
  }
  return str + "s";
};
var toPlural_default = pluralize;

// node_modules/compromise/src/2-two/preTagger/model/lexicon/index.js
var hasSwitch = /\|/;
var lexicon3 = misc_default2;
var switches = {};
var tmpModel = { two: { irregularPlurals: plurals_default, uncountable: {} } };
Object.keys(data_default).forEach((tag2) => {
  let wordsObj = unpack_default(data_default[tag2]);
  if (!hasSwitch.test(tag2)) {
    Object.keys(wordsObj).forEach((w) => {
      lexicon3[w] = tag2;
    });
    return;
  }
  Object.keys(wordsObj).forEach((w) => {
    switches[w] = tag2;
    if (tag2 === "Noun|Verb") {
      let plural2 = toPlural_default(w, tmpModel);
      switches[plural2] = "Plural|Verb";
    }
  });
});
emoticons_default.forEach((str) => lexicon3[str] = "Emoticon");
delete lexicon3[""];
delete lexicon3[null];
delete lexicon3[" "];

// node_modules/compromise/src/2-two/preTagger/model/clues/_noun.js
var n2 = "Singular";
var noun_default = {
  beforeTags: {
    Determiner: n2,
    //the date
    Possessive: n2,
    //his date
    Acronym: n2,
    //u.s. state
    // ProperNoun:n,
    Noun: n2,
    //nasa funding
    Adjective: n2,
    //whole bottles
    // Verb:true, //save storm victims
    PresentTense: n2,
    //loves hiking
    Gerund: n2,
    //uplifting victims
    PastTense: n2,
    //saved storm victims
    Infinitive: n2,
    //profess love
    Date: n2,
    //9pm show
    Ordinal: n2,
    //first date
    Demonym: n2
    //dutch map
  },
  afterTags: {
    Value: n2,
    //date nine  -?
    Modal: n2,
    //date would
    Copula: n2,
    //fear is
    PresentTense: n2,
    //babysitting sucks
    PastTense: n2,
    //babysitting sucked
    // Noun:n, //talking therapy, planning process
    Demonym: n2,
    //american touch
    Actor: n2
    //dance therapist
  },
  // ownTags: { ProperNoun: n },
  beforeWords: {
    the: n2,
    //the brands
    with: n2,
    //with cakes
    without: n2,
    //
    // was:n, //was time  -- was working
    // is:n, //
    of: n2,
    //of power
    for: n2,
    //for rats
    any: n2,
    //any rats
    all: n2,
    //all tips
    on: n2,
    //on time
    // thing-ish verbs
    cut: n2,
    //cut spending
    cuts: n2,
    //cut spending
    increase: n2,
    // increase funding
    decrease: n2,
    //
    raise: n2,
    //
    drop: n2,
    //
    // give: n,//give parents
    save: n2,
    //
    saved: n2,
    //
    saves: n2,
    //
    make: n2,
    //
    makes: n2,
    //
    made: n2,
    //
    minus: n2,
    //minus laughing
    plus: n2,
    //
    than: n2,
    //more than age
    another: n2,
    //
    versus: n2,
    //
    neither: n2,
    //
    about: n2,
    //about claims
    // strong adjectives
    favorite: n2,
    //
    best: n2,
    //
    daily: n2,
    //
    weekly: n2,
    //
    linear: n2,
    //
    binary: n2,
    //
    mobile: n2,
    //
    lexical: n2,
    //
    technical: n2,
    //
    computer: n2,
    //
    scientific: n2,
    //
    security: n2,
    //
    government: n2,
    //
    popular: n2,
    //
    formal: n2,
    no: n2,
    //no worries
    more: n2,
    //more details
    one: n2,
    //one flood
    let: n2,
    //let fear
    her: n2,
    //her boots
    his: n2,
    //
    their: n2,
    //
    our: n2,
    //
    us: n2,
    //served us drinks
    sheer: n2,
    monthly: n2,
    yearly: n2,
    current: n2,
    previous: n2,
    upcoming: n2,
    last: n2,
    next: n2,
    main: n2,
    initial: n2,
    final: n2,
    beginning: n2,
    end: n2,
    top: n2,
    bottom: n2,
    future: n2,
    past: n2,
    major: n2,
    minor: n2,
    side: n2,
    central: n2,
    peripheral: n2,
    public: n2,
    private: n2
  },
  afterWords: {
    of: n2,
    //date of birth (preposition)
    system: n2,
    aid: n2,
    method: n2,
    utility: n2,
    tool: n2,
    reform: n2,
    therapy: n2,
    philosophy: n2,
    room: n2,
    authority: n2,
    says: n2,
    said: n2,
    wants: n2,
    wanted: n2,
    is: n2,
    did: n2,
    do: n2,
    can: n2,
    //parents can
    wise: n2
    //service-wise
    // they: n,//snakes they
  }
};

// node_modules/compromise/src/2-two/preTagger/model/clues/_verb.js
var v = "Infinitive";
var verb_default = {
  beforeTags: {
    Modal: v,
    //would date
    Adverb: v,
    //quickly date
    Negative: v,
    //not date
    Plural: v
    //characters drink
    // ProperNoun: vb,//google thought
  },
  afterTags: {
    Determiner: v,
    //flash the
    Adverb: v,
    //date quickly
    Possessive: v,
    //date his
    Reflexive: v,
    //resolve yourself
    // Noun:true, //date spencer
    Preposition: v,
    //date around, dump onto, grumble about
    // Conjunction: v, // dip to, dip through
    Cardinal: v,
    //cut 3 squares
    Comparative: v,
    //feel greater
    Superlative: v
    //feel greatest
  },
  beforeWords: {
    i: v,
    //i date
    we: v,
    //we date
    you: v,
    //you date
    they: v,
    //they date
    to: v,
    //to date
    please: v,
    //please check
    will: v,
    //will check
    have: v,
    had: v,
    would: v,
    could: v,
    should: v,
    do: v,
    did: v,
    does: v,
    can: v,
    must: v,
    us: v,
    me: v,
    let: v,
    even: v,
    when: v,
    help: v,
    //help combat
    // them: v,
    he: v,
    she: v,
    it: v,
    being: v,
    // prefixes
    bi: v,
    co: v,
    contra: v,
    de: v,
    inter: v,
    intra: v,
    mis: v,
    pre: v,
    out: v,
    counter: v,
    nobody: v,
    somebody: v,
    anybody: v,
    everybody: v
    // un: v,
    // over: v,
    // under: v,
  },
  afterWords: {
    the: v,
    //echo the
    me: v,
    //date me
    you: v,
    //date you
    him: v,
    //loves him
    us: v,
    //cost us
    her: v,
    //
    his: v,
    //
    them: v,
    //
    they: v,
    //
    it: v,
    //hope it
    himself: v,
    herself: v,
    itself: v,
    myself: v,
    ourselves: v,
    themselves: v,
    something: v,
    anything: v,
    a: v,
    //covers a
    an: v,
    //covers an
    // from: v, //ranges from
    up: v,
    //serves up
    down: v,
    //serves up
    by: v,
    // in: v, //bob in
    out: v,
    // on: v,
    off: v,
    under: v,
    what: v,
    //look what
    // when: v,//starts when
    // for:true, //settled for
    all: v,
    //shiver all night
    // conjunctions
    to: v,
    //dip to
    because: v,
    //
    although: v,
    //
    // after: v,
    // before: v,//
    how: v,
    //
    otherwise: v,
    //
    together: v,
    //fit together
    though: v,
    //
    into: v,
    //
    yet: v,
    //
    more: v,
    //kill more
    here: v,
    // look here
    there: v,
    //
    away: v
    //float away
  }
};

// node_modules/compromise/src/2-two/preTagger/model/clues/actor-verb.js
var clue = {
  beforeTags: Object.assign({}, verb_default.beforeTags, noun_default.beforeTags, {}),
  afterTags: Object.assign({}, verb_default.afterTags, noun_default.afterTags, {}),
  beforeWords: Object.assign({}, verb_default.beforeWords, noun_default.beforeWords, {}),
  afterWords: Object.assign({}, verb_default.afterWords, noun_default.afterWords, {})
};
var actor_verb_default = clue;

// node_modules/compromise/src/2-two/preTagger/model/clues/_adj.js
var jj = "Adjective";
var adj_default = {
  beforeTags: {
    Determiner: jj,
    //the detailed
    // Copula: jj, //is detailed
    Possessive: jj,
    //spencer's detailed
    Hyphenated: jj
    //rapidly-changing
  },
  afterTags: {
    // Noun: jj, //detailed plan, overwhelming evidence
    Adjective: jj
    //intoxicated little
  },
  beforeWords: {
    seem: jj,
    //seem prepared
    seemed: jj,
    seems: jj,
    feel: jj,
    //feel prepared
    feels: jj,
    felt: jj,
    stay: jj,
    appear: jj,
    appears: jj,
    appeared: jj,
    also: jj,
    over: jj,
    //over cooked
    under: jj,
    too: jj,
    //too insulting
    it: jj,
    //find it insulting
    but: jj,
    //nothing but frustrating
    still: jj,
    //still scared
    // adverbs that are adjective-ish
    really: jj,
    //really damaged
    quite: jj,
    well: jj,
    very: jj,
    truly: jj,
    how: jj,
    //how slow
    deeply: jj,
    hella: jj,
    // always: jj,
    // never: jj,
    profoundly: jj,
    extremely: jj,
    so: jj,
    badly: jj,
    mostly: jj,
    totally: jj,
    awfully: jj,
    rather: jj,
    nothing: jj,
    //nothing secret,
    something: jj,
    //something wrong
    anything: jj,
    not: jj,
    //not swell
    me: jj,
    //called me swell
    is: jj,
    face: jj,
    //faces shocking revelations
    faces: jj,
    faced: jj,
    look: jj,
    looks: jj,
    looked: jj,
    reveal: jj,
    reveals: jj,
    revealed: jj,
    sound: jj,
    sounded: jj,
    sounds: jj,
    remains: jj,
    remained: jj,
    prove: jj,
    //would prove shocking
    proves: jj,
    proved: jj,
    becomes: jj,
    stays: jj,
    tastes: jj,
    taste: jj,
    smells: jj,
    smell: jj,
    gets: jj,
    //gets shocking snowfall
    grows: jj,
    as: jj,
    rings: jj,
    radiates: jj,
    conveys: jj,
    convey: jj,
    conveyed: jj,
    of: jj
    // 'smacks of': jj,
    // 'reeks of': jj,
  },
  afterWords: {
    too: jj,
    //insulting too
    also: jj,
    //insulting too
    or: jj,
    //insulting or
    enough: jj,
    //cool enough
    as: jj
    //as shocking as
    //about: jj, //cool about
  }
};

// node_modules/compromise/src/2-two/preTagger/model/clues/_gerund.js
var g2 = "Gerund";
var gerund_default = {
  beforeTags: {
    // Verb: g, // loves shocking
    Adverb: g2,
    //quickly shocking
    Preposition: g2,
    //by insulting
    Conjunction: g2
    //to insulting
  },
  afterTags: {
    Adverb: g2,
    //shocking quickly
    Possessive: g2,
    //shocking spencer's
    Person: g2,
    //telling spencer
    Pronoun: g2,
    //shocking him
    Determiner: g2,
    //shocking the
    Copula: g2,
    //shocking is
    Preposition: g2,
    //dashing by, swimming in
    Conjunction: g2,
    //insulting to
    Comparative: g2
    //growing shorter
  },
  beforeWords: {
    been: g2,
    keep: g2,
    //keep going
    continue: g2,
    //
    stop: g2,
    //
    am: g2,
    //am watching
    be: g2,
    //be timing
    me: g2,
    //got me thinking
    // action-words
    began: g2,
    start: g2,
    starts: g2,
    started: g2,
    stops: g2,
    stopped: g2,
    help: g2,
    helps: g2,
    avoid: g2,
    avoids: g2,
    love: g2,
    //love painting
    loves: g2,
    loved: g2,
    hate: g2,
    hates: g2,
    hated: g2
    // was:g,//was working
    // is:g,
    // be:g,
  },
  afterWords: {
    you: g2,
    //telling you
    me: g2,
    //
    her: g2,
    //
    him: g2,
    //
    his: g2,
    //
    them: g2,
    //
    their: g2,
    // fighting their
    it: g2,
    //dumping it
    this: g2,
    //running this
    there: g2,
    // swimming there
    on: g2,
    // landing on
    about: g2,
    // talking about
    for: g2,
    // paying for
    up: g2,
    //speeding up
    down: g2
    //
  }
};

// node_modules/compromise/src/2-two/preTagger/model/clues/adj-gerund.js
var g3 = "Gerund";
var jj2 = "Adjective";
var clue2 = {
  beforeTags: Object.assign({}, adj_default.beforeTags, gerund_default.beforeTags, {
    // Copula: jj,
    Imperative: g3,
    //recommend living in
    Infinitive: jj2,
    //say charming things
    // PresentTense: g,
    Plural: g3
    //kids cutting
  }),
  afterTags: Object.assign({}, adj_default.afterTags, gerund_default.afterTags, {
    Noun: jj2
    //shocking ignorance
    // Plural: jj, //shocking lies
  }),
  beforeWords: Object.assign({}, adj_default.beforeWords, gerund_default.beforeWords, {
    is: jj2,
    are: g3,
    //is overflowing: JJ, are overflowing : VB ??
    was: jj2,
    of: jj2,
    //of varying
    suggest: g3,
    suggests: g3,
    suggested: g3,
    recommend: g3,
    recommends: g3,
    recommended: g3,
    imagine: g3,
    imagines: g3,
    imagined: g3,
    consider: g3,
    considered: g3,
    considering: g3,
    resist: g3,
    resists: g3,
    resisted: g3,
    avoid: g3,
    avoided: g3,
    avoiding: g3,
    except: jj2,
    accept: jj2,
    assess: g3,
    explore: g3,
    fear: g3,
    fears: g3,
    appreciate: g3,
    question: g3,
    help: g3,
    embrace: g3,
    with: jj2
    //filled with daring
  }),
  afterWords: Object.assign({}, adj_default.afterWords, gerund_default.afterWords, {
    to: g3,
    not: g3,
    //trying not to car
    the: g3
    //sweeping the country
  })
};
var adj_gerund_default = clue2;

// node_modules/compromise/src/2-two/preTagger/model/clues/adj-noun.js
var misc2 = {
  beforeTags: {
    Determiner: void 0,
    //the premier university
    Cardinal: "Noun",
    //1950 convertable
    PhrasalVerb: "Adjective"
    //starts out fine
  },
  afterTags: {
    // Pronoun: 'Noun'//as an adult i
  }
};
var clue3 = {
  beforeTags: Object.assign({}, adj_default.beforeTags, noun_default.beforeTags, misc2.beforeTags),
  afterTags: Object.assign({}, adj_default.afterTags, noun_default.afterTags, misc2.afterTags),
  beforeWords: Object.assign({}, adj_default.beforeWords, noun_default.beforeWords, {
    // are representative
    are: "Adjective",
    is: "Adjective",
    was: "Adjective",
    be: "Adjective",
    // phrasals
    off: "Adjective",
    //start off fine
    out: "Adjective"
    //comes out fine
  }),
  afterWords: Object.assign({}, adj_default.afterWords, noun_default.afterWords)
};
var adj_noun_default = clue3;

// node_modules/compromise/src/2-two/preTagger/model/clues/adj-past.js
var past = "PastTense";
var jj3 = "Adjective";
var adjPast = {
  beforeTags: {
    Adverb: past,
    //quickly detailed
    Pronoun: past,
    //he detailed
    ProperNoun: past,
    //toronto closed
    Auxiliary: past,
    Noun: past
    //eye closed  -- i guess.
  },
  afterTags: {
    Possessive: past,
    //hooked him
    Pronoun: past,
    //hooked me
    Determiner: past,
    //hooked the
    Adverb: past,
    //cooked perfectly
    Comparative: past,
    //closed higher
    Date: past,
    // alleged thursday
    Gerund: past
    //left dancing
  },
  beforeWords: {
    be: past,
    //be hooked vs be embarrassed
    who: past,
    //who lost
    get: jj3,
    //get charged
    had: past,
    has: past,
    have: past,
    been: past,
    it: past,
    //it intoxicated him
    as: past,
    //as requested
    for: jj3,
    //for discounted items
    more: jj3,
    //more broken promises
    always: jj3
  },
  afterWords: {
    by: past,
    //damaged by
    back: past,
    //charged back
    out: past,
    //charged out
    in: past,
    //crowded in
    up: past,
    //heated up
    down: past,
    //hammered down
    before: past,
    //
    after: past,
    //
    for: past,
    //settled for
    the: past,
    //settled the
    with: past,
    //obsessed with
    as: past,
    //known as
    on: past,
    //focused on
    at: past,
    //recorded at
    between: past,
    //settled between
    to: past,
    //dedicated to
    into: past,
    //pumped into
    us: past,
    //charged us
    them: past,
    //charged us
    his: past,
    //shared his
    her: past,
    //
    their: past,
    //
    our: past,
    //
    me: past,
    //
    about: jj3
  }
};
var adj_past_default = {
  beforeTags: Object.assign({}, adj_default.beforeTags, adjPast.beforeTags),
  afterTags: Object.assign({}, adj_default.afterTags, adjPast.afterTags),
  beforeWords: Object.assign({}, adj_default.beforeWords, adjPast.beforeWords),
  afterWords: Object.assign({}, adj_default.afterWords, adjPast.afterWords)
};

// node_modules/compromise/src/2-two/preTagger/model/clues/adj-present.js
var misc3 = {
  afterTags: {
    Noun: "Adjective",
    //ruling party
    Conjunction: void 0
    //clean and excellent
  }
};
var clue4 = {
  beforeTags: Object.assign({}, adj_default.beforeTags, verb_default.beforeTags, {
    // always clean
    Adverb: void 0,
    Negative: void 0
  }),
  afterTags: Object.assign({}, adj_default.afterTags, verb_default.afterTags, misc3.afterTags),
  beforeWords: Object.assign({}, adj_default.beforeWords, verb_default.beforeWords, {
    // have seperate contracts
    have: void 0,
    had: void 0,
    not: void 0,
    //went wrong, got wrong
    went: "Adjective",
    goes: "Adjective",
    got: "Adjective",
    // be sure
    be: "Adjective"
  }),
  afterWords: Object.assign({}, adj_default.afterWords, verb_default.afterWords, {
    to: void 0,
    //slick to the touch
    as: "Adjective"
    //pale as
  })
};
var adj_present_default = clue4;

// node_modules/compromise/src/2-two/preTagger/model/clues/noun-gerund.js
var misc4 = {
  beforeTags: {
    Copula: "Gerund",
    PastTense: "Gerund",
    PresentTense: "Gerund",
    Infinitive: "Gerund"
  },
  afterTags: {
    Value: "Gerund"
    //maintaining 500
  },
  beforeWords: {
    are: "Gerund",
    were: "Gerund",
    be: "Gerund",
    no: "Gerund",
    without: "Gerund",
    //are you playing
    you: "Gerund",
    we: "Gerund",
    they: "Gerund",
    he: "Gerund",
    she: "Gerund",
    //stop us playing
    us: "Gerund",
    them: "Gerund"
  },
  afterWords: {
    // offering the
    the: "Gerund",
    this: "Gerund",
    that: "Gerund",
    //got me thinking
    me: "Gerund",
    us: "Gerund",
    them: "Gerund"
  }
};
var clue5 = {
  beforeTags: Object.assign({}, gerund_default.beforeTags, noun_default.beforeTags, misc4.beforeTags),
  afterTags: Object.assign({}, gerund_default.afterTags, noun_default.afterTags, misc4.afterTags),
  beforeWords: Object.assign({}, gerund_default.beforeWords, noun_default.beforeWords, misc4.beforeWords),
  afterWords: Object.assign({}, gerund_default.afterWords, noun_default.afterWords, misc4.afterWords)
};
var noun_gerund_default = clue5;

// node_modules/compromise/src/2-two/preTagger/model/clues/noun-verb.js
var nn = "Singular";
var vb = "Infinitive";
var clue6 = {
  beforeTags: Object.assign({}, verb_default.beforeTags, noun_default.beforeTags, {
    // Noun: undefined
    Adjective: nn,
    //great name
    Particle: nn
    //brought under control
  }),
  afterTags: Object.assign({}, verb_default.afterTags, noun_default.afterTags, {
    ProperNoun: vb,
    Gerund: vb,
    Adjective: vb,
    Copula: nn
  }),
  beforeWords: Object.assign({}, verb_default.beforeWords, noun_default.beforeWords, {
    // is time
    is: nn,
    was: nn,
    //balance of power
    of: nn,
    have: null
    //have cash
  }),
  afterWords: Object.assign({}, verb_default.afterWords, noun_default.afterWords, {
    // for: vb,//work for
    instead: vb,
    // that: nn,//subject that was
    // for: vb,//work for
    about: vb,
    //talk about
    his: vb,
    //shot his
    her: vb,
    //
    to: null,
    by: null,
    in: null
  })
};
var noun_verb_default = clue6;

// node_modules/compromise/src/2-two/preTagger/model/clues/_person.js
var p2 = "Person";
var person_default = {
  beforeTags: {
    Honorific: p2,
    Person: p2
    // Preposition: p, //with sue
  },
  afterTags: {
    Person: p2,
    ProperNoun: p2,
    Verb: p2
    //bob could
    // Modal:true, //bob could
    // Copula:true, //bob is
    // PresentTense:true, //bob seems
  },
  ownTags: {
    ProperNoun: p2
    //capital letter
  },
  beforeWords: {
    hi: p2,
    hey: p2,
    yo: p2,
    dear: p2,
    hello: p2
  },
  afterWords: {
    // person-usually verbs
    said: p2,
    says: p2,
    told: p2,
    tells: p2,
    feels: p2,
    felt: p2,
    seems: p2,
    thinks: p2,
    thought: p2,
    spends: p2,
    spendt: p2,
    plays: p2,
    played: p2,
    sing: p2,
    sang: p2,
    learn: p2,
    learned: p2,
    wants: p2,
    wanted: p2
    // and:true, //sue and jeff
  }
};

// node_modules/compromise/src/2-two/preTagger/model/clues/person-date.js
var m = "Month";
var p3 = "Person";
var month = {
  beforeTags: {
    Date: m,
    Value: m
  },
  afterTags: {
    Date: m,
    Value: m
  },
  beforeWords: {
    by: m,
    in: m,
    on: m,
    during: m,
    after: m,
    before: m,
    between: m,
    until: m,
    til: m,
    sometime: m,
    of: m,
    //5th of april
    this: m,
    //this april
    next: m,
    last: m,
    previous: m,
    following: m,
    with: p3
    // for: p,
  },
  afterWords: {
    sometime: m,
    in: m,
    of: m,
    until: m,
    the: m
    //june the 4th
  }
};
var person_date_default = {
  beforeTags: Object.assign({}, person_default.beforeTags, month.beforeTags),
  afterTags: Object.assign({}, person_default.afterTags, month.afterTags),
  beforeWords: Object.assign({}, person_default.beforeWords, month.beforeWords),
  afterWords: Object.assign({}, person_default.afterWords, month.afterWords)
};

// node_modules/compromise/src/2-two/preTagger/model/clues/person-noun.js
var clue7 = {
  beforeTags: Object.assign({}, noun_default.beforeTags, person_default.beforeTags),
  afterTags: Object.assign({}, noun_default.afterTags, person_default.afterTags),
  beforeWords: Object.assign({}, noun_default.beforeWords, person_default.beforeWords, { i: "Infinitive", we: "Infinitive" }),
  afterWords: Object.assign({}, noun_default.afterWords, person_default.afterWords)
};
var person_noun_default = clue7;

// node_modules/compromise/src/2-two/preTagger/model/clues/person-verb.js
var clues = {
  beforeTags: Object.assign({}, noun_default.beforeTags, person_default.beforeTags, verb_default.beforeTags),
  afterTags: Object.assign({}, noun_default.afterTags, person_default.afterTags, verb_default.afterTags),
  beforeWords: Object.assign({}, noun_default.beforeWords, person_default.beforeWords, verb_default.beforeWords),
  afterWords: Object.assign({}, noun_default.afterWords, person_default.afterWords, verb_default.afterWords)
};
var person_verb_default = clues;

// node_modules/compromise/src/2-two/preTagger/model/clues/person-place.js
var p4 = "Place";
var place = {
  beforeTags: {
    Place: p4
  },
  afterTags: {
    Place: p4,
    Abbreviation: p4
  },
  beforeWords: {
    in: p4,
    by: p4,
    near: p4,
    from: p4,
    to: p4
  },
  afterWords: {
    in: p4,
    by: p4,
    near: p4,
    from: p4,
    to: p4,
    government: p4,
    council: p4,
    region: p4,
    city: p4
  }
};
var clue8 = {
  beforeTags: Object.assign({}, place.beforeTags, person_default.beforeTags),
  afterTags: Object.assign({}, place.afterTags, person_default.afterTags),
  beforeWords: Object.assign({}, place.beforeWords, person_default.beforeWords),
  afterWords: Object.assign({}, place.afterWords, person_default.afterWords)
};
var person_place_default = clue8;

// node_modules/compromise/src/2-two/preTagger/model/clues/person-adj.js
var clues2 = {
  beforeTags: Object.assign({}, person_default.beforeTags, adj_default.beforeTags),
  afterTags: Object.assign({}, person_default.afterTags, adj_default.afterTags),
  beforeWords: Object.assign({}, person_default.beforeWords, adj_default.beforeWords),
  afterWords: Object.assign({}, person_default.afterWords, adj_default.afterWords)
};
var person_adj_default = clues2;

// node_modules/compromise/src/2-two/preTagger/model/clues/unit-noun.js
var un = "Unit";
var clues3 = {
  beforeTags: { Value: un },
  afterTags: {},
  beforeWords: {
    per: un,
    every: un,
    each: un,
    square: un,
    //square km
    cubic: un,
    sq: un,
    metric: un
    //metric ton
  },
  afterWords: {
    per: un,
    squared: un,
    cubed: un,
    long: un
    //foot long
  }
};
var unit_noun_default = clues3;

// node_modules/compromise/src/2-two/preTagger/model/clues/index.js
var clues4 = {
  "Actor|Verb": actor_verb_default,
  "Adj|Gerund": adj_gerund_default,
  "Adj|Noun": adj_noun_default,
  "Adj|Past": adj_past_default,
  "Adj|Present": adj_present_default,
  "Noun|Verb": noun_verb_default,
  "Noun|Gerund": noun_gerund_default,
  "Person|Noun": person_noun_default,
  "Person|Date": person_date_default,
  "Person|Verb": person_verb_default,
  "Person|Place": person_place_default,
  "Person|Adj": person_adj_default,
  "Unit|Noun": unit_noun_default
};
var copy = (obj, more) => {
  let res = Object.keys(obj).reduce((h2, k2) => {
    h2[k2] = obj[k2] === "Infinitive" ? "PresentTense" : "Plural";
    return h2;
  }, {});
  return Object.assign(res, more);
};
clues4["Plural|Verb"] = {
  beforeWords: copy(clues4["Noun|Verb"].beforeWords, {
    had: "Plural",
    //had tears
    have: "Plural"
  }),
  afterWords: copy(clues4["Noun|Verb"].afterWords, {
    his: "PresentTense",
    her: "PresentTense",
    its: "PresentTense",
    in: null,
    to: null,
    is: "PresentTense",
    //the way it works is
    by: "PresentTense"
    //it works by
  }),
  beforeTags: copy(clues4["Noun|Verb"].beforeTags, {
    Conjunction: "PresentTense",
    //and changes
    Noun: void 0,
    //the century demands
    ProperNoun: "PresentTense"
    //john plays
  }),
  afterTags: copy(clues4["Noun|Verb"].afterTags, {
    Gerund: "Plural",
    //ice caps disappearing
    Noun: "PresentTense",
    //changes gears
    Value: "PresentTense"
    //changes seven gears
  })
};
var clues_default = clues4;

// node_modules/compromise/src/2-two/preTagger/model/patterns/suffixes.js
var Adj = "Adjective";
var Inf = "Infinitive";
var Pres = "PresentTense";
var Sing = "Singular";
var Past = "PastTense";
var Avb = "Adverb";
var Plrl = "Plural";
var Actor = "Actor";
var Vb = "Verb";
var Noun = "Noun";
var Prop = "ProperNoun";
var Last = "LastName";
var Modal = "Modal";
var Place = "Place";
var Prt = "Participle";
var suffixes_default2 = [
  null,
  null,
  {
    //2-letter
    ea: Sing,
    ia: Noun,
    ic: Adj,
    ly: Avb,
    "'n": Vb,
    "'t": Vb
  },
  {
    //3-letter
    oed: Past,
    ued: Past,
    xed: Past,
    " so": Avb,
    "'ll": Modal,
    "'re": "Copula",
    azy: Adj,
    eer: Noun,
    end: Vb,
    ped: Past,
    ffy: Adj,
    ify: Inf,
    ing: "Gerund",
    ize: Inf,
    ibe: Inf,
    lar: Adj,
    mum: Adj,
    nes: Pres,
    nny: Adj,
    // oid: Adj,
    ous: Adj,
    que: Adj,
    ger: Noun,
    ber: Noun,
    rol: Sing,
    sis: Sing,
    ogy: Sing,
    oid: Sing,
    ian: Sing,
    zes: Pres,
    eld: Past,
    ken: Prt,
    //awoken
    ven: Prt,
    //woven
    ten: Prt,
    //brighten
    ect: Inf,
    ict: Inf,
    // ide: Inf,
    ign: Inf,
    oze: Inf,
    ful: Adj,
    bal: Adj,
    ton: Noun,
    pur: Place
  },
  {
    //4-letter
    amed: Past,
    aped: Past,
    ched: Past,
    lked: Past,
    rked: Past,
    reed: Past,
    nded: Past,
    mned: Adj,
    cted: Past,
    dged: Past,
    ield: Sing,
    akis: Last,
    cede: Inf,
    chuk: Last,
    czyk: Last,
    ects: Pres,
    iend: Sing,
    ends: Vb,
    enko: Last,
    ette: Sing,
    iary: Sing,
    wner: Sing,
    //owner
    fies: Pres,
    fore: Avb,
    gate: Inf,
    gone: Adj,
    ices: Plrl,
    ints: Plrl,
    ruct: Inf,
    ines: Plrl,
    ions: Plrl,
    ners: Plrl,
    pers: Plrl,
    lers: Plrl,
    less: Adj,
    llen: Adj,
    made: Adj,
    nsen: Last,
    oses: Pres,
    ould: Modal,
    some: Adj,
    sson: Last,
    ians: Plrl,
    // tage: Inf,
    tion: Sing,
    tage: Noun,
    ique: Sing,
    tive: Adj,
    tors: Noun,
    vice: Sing,
    lier: Sing,
    fier: Sing,
    wned: Past,
    gent: Sing,
    tist: Actor,
    pist: Actor,
    rist: Actor,
    mist: Actor,
    yist: Actor,
    vist: Actor,
    ists: Actor,
    lite: Sing,
    site: Sing,
    rite: Sing,
    mite: Sing,
    bite: Sing,
    mate: Sing,
    date: Sing,
    ndal: Sing,
    vent: Sing,
    uist: Actor,
    gist: Actor,
    note: Sing,
    cide: Sing,
    //homicide
    ence: Sing,
    //absence
    wide: Adj,
    //nationwide
    // side: Adj,//alongside
    vide: Inf,
    //provide
    ract: Inf,
    duce: Inf,
    pose: Inf,
    eive: Inf,
    lyze: Inf,
    lyse: Inf,
    iant: Adj,
    nary: Adj,
    ghty: Adj,
    uent: Adj,
    erer: Actor,
    //caterer
    bury: Place,
    dorf: Noun,
    esty: Noun,
    wych: Place,
    dale: Place,
    folk: Place,
    vale: Place,
    abad: Place,
    sham: Place,
    wick: Place,
    view: Place
  },
  {
    //5-letter
    elist: Actor,
    holic: Sing,
    phite: Sing,
    tized: Past,
    urned: Past,
    eased: Past,
    ances: Plrl,
    bound: Adj,
    ettes: Plrl,
    fully: Avb,
    ishes: Pres,
    ities: Plrl,
    marek: Last,
    nssen: Last,
    ology: Noun,
    osome: Sing,
    tment: Sing,
    ports: Plrl,
    rough: Adj,
    tches: Pres,
    tieth: "Ordinal",
    tures: Plrl,
    wards: Avb,
    where: Avb,
    archy: Noun,
    pathy: Noun,
    opoly: Noun,
    embly: Noun,
    phate: Noun,
    ndent: Sing,
    scent: Sing,
    onist: Actor,
    anist: Actor,
    alist: Actor,
    olist: Actor,
    icist: Actor,
    ounce: Inf,
    iable: Adj,
    borne: Adj,
    gnant: Adj,
    inant: Adj,
    igent: Adj,
    atory: Adj,
    // ctory: Adj,
    rient: Sing,
    dient: Sing,
    maker: Actor,
    burgh: Place,
    mouth: Place,
    ceter: Place,
    ville: Place,
    hurst: Place,
    stead: Place,
    endon: Place,
    brook: Place,
    shire: Place,
    worth: Noun,
    field: Prop,
    ridge: Place
  },
  {
    //6-letter
    auskas: Last,
    parent: Sing,
    cedent: Sing,
    ionary: Sing,
    cklist: Sing,
    brooke: Place,
    keeper: Actor,
    logist: Actor,
    teenth: "Value",
    worker: Actor,
    master: Actor,
    writer: Actor,
    brough: Place,
    cester: Place,
    ington: Place,
    cliffe: Place,
    ingham: Place
  },
  {
    //7-letter
    chester: Place,
    logists: Actor,
    opoulos: Last,
    borough: Place,
    sdottir: Last
    //swedish female
  }
];

// node_modules/compromise/src/2-two/preTagger/model/patterns/prefixes.js
var Adj2 = "Adjective";
var Noun2 = "Noun";
var Verb = "Verb";
var prefixes_default2 = [
  null,
  null,
  {
    // 2-letter
  },
  {
    // 3-letter
    neo: Noun2,
    bio: Noun2,
    // pre: Noun,
    "de-": Verb,
    "re-": Verb,
    "un-": Verb,
    "ex-": Noun2
  },
  {
    // 4-letter
    anti: Noun2,
    auto: Noun2,
    faux: Adj2,
    hexa: Noun2,
    kilo: Noun2,
    mono: Noun2,
    nano: Noun2,
    octa: Noun2,
    poly: Noun2,
    semi: Adj2,
    tele: Noun2,
    "pro-": Adj2,
    "mis-": Verb,
    "dis-": Verb,
    "pre-": Adj2
    //hmm
  },
  {
    // 5-letter
    anglo: Noun2,
    centi: Noun2,
    ethno: Noun2,
    ferro: Noun2,
    grand: Noun2,
    hepta: Noun2,
    hydro: Noun2,
    intro: Noun2,
    macro: Noun2,
    micro: Noun2,
    milli: Noun2,
    nitro: Noun2,
    penta: Noun2,
    quasi: Adj2,
    radio: Noun2,
    tetra: Noun2,
    "omni-": Adj2,
    "post-": Adj2
  },
  {
    // 6-letter
    pseudo: Adj2,
    "extra-": Adj2,
    "hyper-": Adj2,
    "inter-": Adj2,
    "intra-": Adj2,
    "deca-": Adj2
    // 'trans-': Noun,
  },
  {
    // 7-letter
    electro: Noun2
  }
];

// node_modules/compromise/src/2-two/preTagger/model/patterns/endsWith.js
var Adj3 = "Adjective";
var Inf2 = "Infinitive";
var Pres2 = "PresentTense";
var Sing2 = "Singular";
var Past2 = "PastTense";
var Adverb = "Adverb";
var Exp = "Expression";
var Actor2 = "Actor";
var Verb2 = "Verb";
var Noun3 = "Noun";
var Last2 = "LastName";
var endsWith_default = {
  a: [
    [/.[aeiou]na$/, Noun3, "tuna"],
    [/.[oau][wvl]ska$/, Last2],
    [/.[^aeiou]ica$/, Sing2, "harmonica"],
    [/^([hyj]a+)+$/, Exp, "haha"]
    //hahah
  ],
  c: [[/.[^aeiou]ic$/, Adj3]],
  d: [
    //==-ed==
    //double-consonant
    [/[aeiou](pp|ll|ss|ff|gg|tt|rr|bb|nn|mm)ed$/, Past2, "popped"],
    //double-vowel
    [/.[aeo]{2}[bdgmnprvz]ed$/, Past2, "rammed"],
    //-hed
    [/.[aeiou][sg]hed$/, Past2, "gushed"],
    //-rd
    [/.[aeiou]red$/, Past2, "hired"],
    [/.[aeiou]r?ried$/, Past2, "hurried"],
    // ard
    [/[^aeiou]ard$/, Sing2, "steward"],
    // id
    [/[aeiou][^aeiou]id$/, Adj3, ""],
    [/.[vrl]id$/, Adj3, "livid"],
    // ===== -ed ======
    //-led
    [/..led$/, Past2, "hurled"],
    //-sed
    [/.[iao]sed$/, Past2, ""],
    [/[aeiou]n?[cs]ed$/, Past2, ""],
    //-med
    [/[aeiou][rl]?[mnf]ed$/, Past2, ""],
    //-ked
    [/[aeiou][ns]?c?ked$/, Past2, "bunked"],
    //-gned
    [/[aeiou]gned$/, Past2],
    //-ged
    [/[aeiou][nl]?ged$/, Past2],
    //-ted
    [/.[tdbwxyz]ed$/, Past2],
    [/[^aeiou][aeiou][tvx]ed$/, Past2],
    //-ied
    [/.[cdflmnprstv]ied$/, Past2, "emptied"]
  ],
  e: [
    [/.[lnr]ize$/, Inf2, "antagonize"],
    [/.[^aeiou]ise$/, Inf2, "antagonise"],
    [/.[aeiou]te$/, Inf2, "bite"],
    [/.[^aeiou][ai]ble$/, Adj3, "fixable"],
    [/.[^aeiou]eable$/, Adj3, "maleable"],
    [/.[ts]ive$/, Adj3, "festive"],
    [/[a-z]-like$/, Adj3, "woman-like"]
  ],
  h: [
    [/.[^aeiouf]ish$/, Adj3, "cornish"],
    [/.v[iy]ch$/, Last2, "..ovich"],
    [/^ug?h+$/, Exp, "ughh"],
    [/^uh[ -]?oh$/, Exp, "uhoh"],
    [/[a-z]-ish$/, Adj3, "cartoon-ish"]
  ],
  i: [[/.[oau][wvl]ski$/, Last2, "polish-male"]],
  k: [
    [/^(k){2}$/, Exp, "kkkk"]
    //kkkk
  ],
  l: [
    [/.[gl]ial$/, Adj3, "familial"],
    [/.[^aeiou]ful$/, Adj3, "fitful"],
    [/.[nrtumcd]al$/, Adj3, "natal"],
    [/.[^aeiou][ei]al$/, Adj3, "familial"]
  ],
  m: [
    [/.[^aeiou]ium$/, Sing2, "magnesium"],
    [/[^aeiou]ism$/, Sing2, "schism"],
    [/^[hu]m+$/, Exp, "hmm"],
    [/^\d+ ?[ap]m$/, "Date", "3am"]
  ],
  n: [
    [/.[lsrnpb]ian$/, Adj3, "republican"],
    [/[^aeiou]ician$/, Actor2, "musician"],
    [/[aeiou][ktrp]in'$/, "Gerund", "cookin'"]
    // 'cookin', 'hootin'
  ],
  o: [
    [/^no+$/, Exp, "noooo"],
    [/^(yo)+$/, Exp, "yoo"],
    [/^wo{2,}[pt]?$/, Exp, "woop"]
    //woo
  ],
  r: [
    [/.[bdfklmst]ler$/, "Noun"],
    [/[aeiou][pns]er$/, Sing2],
    [/[^i]fer$/, Inf2],
    [/.[^aeiou][ao]pher$/, Actor2],
    [/.[lk]er$/, "Noun"],
    [/.ier$/, "Comparative"]
  ],
  t: [
    [/.[di]est$/, "Superlative"],
    [/.[icldtgrv]ent$/, Adj3],
    [/[aeiou].*ist$/, Adj3],
    [/^[a-z]et$/, Verb2]
  ],
  s: [
    [/.[^aeiou]ises$/, Pres2],
    [/.[rln]ates$/, Pres2],
    [/.[^z]ens$/, Verb2],
    [/.[lstrn]us$/, Sing2],
    [/.[aeiou]sks$/, Pres2],
    [/.[aeiou]kes$/, Pres2],
    [/[aeiou][^aeiou]is$/, Sing2],
    [/[a-z]'s$/, Noun3],
    [/^yes+$/, Exp]
    //yessss
  ],
  v: [
    [/.[^aeiou][ai][kln]ov$/, Last2]
    //east-europe
  ],
  y: [
    [/.[cts]hy$/, Adj3],
    [/.[st]ty$/, Adj3],
    [/.[tnl]ary$/, Adj3],
    [/.[oe]ry$/, Sing2],
    [/[rdntkbhs]ly$/, Adverb],
    [/.(gg|bb|zz)ly$/, Adj3],
    [/...lly$/, Adverb],
    [/.[gk]y$/, Adj3],
    [/[bszmp]{2}y$/, Adj3],
    [/.[ai]my$/, Adj3],
    [/[ea]{2}zy$/, Adj3],
    [/.[^aeiou]ity$/, Sing2]
  ]
};

// node_modules/compromise/src/2-two/preTagger/model/patterns/neighbours.js
var vb2 = "Verb";
var nn2 = "Noun";
var neighbours_default = {
  // looking at the previous word's tags:
  leftTags: [
    ["Adjective", nn2],
    ["Possessive", nn2],
    ["Determiner", nn2],
    ["Adverb", vb2],
    ["Pronoun", vb2],
    ["Value", nn2],
    ["Ordinal", nn2],
    ["Modal", vb2],
    ["Superlative", nn2],
    ["Demonym", nn2],
    ["Honorific", "Person"]
    //dr. Smith
  ],
  // looking at the previous word:
  leftWords: [
    ["i", vb2],
    ["first", nn2],
    ["it", vb2],
    ["there", vb2],
    ["not", vb2],
    ["because", nn2],
    ["if", nn2],
    ["but", nn2],
    ["who", vb2],
    ["this", nn2],
    ["his", nn2],
    ["when", nn2],
    ["you", vb2],
    ["very", "Adjective"],
    ["old", nn2],
    ["never", vb2],
    ["before", nn2],
    ["a", nn2],
    ["the", nn2],
    ["been", vb2]
  ],
  // looking at the next word's tags:
  rightTags: [
    ["Copula", nn2],
    ["PastTense", nn2],
    ["Conjunction", nn2],
    ["Modal", nn2]
  ],
  // looking at the next word:
  rightWords: [
    ["there", vb2],
    ["me", vb2],
    ["man", "Adjective"],
    // ['only', vb],
    ["him", vb2],
    ["it", vb2],
    //relaunch it
    ["were", nn2],
    ["took", nn2],
    ["himself", vb2],
    ["went", nn2],
    ["who", nn2],
    ["jr", "Person"]
  ]
};

// node_modules/compromise/src/2-two/preTagger/model/models/_data.js
var data_default2 = {
  "Comparative": {
    "fwd": "3:ser,ier\xA61er:h,t,f,l,n\xA61r:e\xA62er:ss,or,om",
    "both": "3er:ver,ear,alm\xA63ner:hin\xA63ter:lat\xA62mer:im\xA62er:ng,rm,mb\xA62ber:ib\xA62ger:ig\xA61er:w,p,k,d\xA6ier:y",
    "rev": "1:tter,yer\xA62:uer,ver,ffer,oner,eler,ller,iler,ster,cer,uler,sher,ener,gher,aner,adder,nter,eter,rter,hter,rner,fter\xA63:oser,ooler,eafer,user,airer,bler,maler,tler,eater,uger,rger,ainer,urer,ealer,icher,pler,emner,icter,nser,iser\xA64:arser,viner,ucher,rosser,somer,ndomer,moter,oother,uarer,hiter\xA65:nuiner,esser,emier\xA6ar:urther",
    "ex": "worse:bad\xA6better:good\xA64er:fair,gray,poor\xA61urther:far\xA63ter:fat,hot,wet\xA63der:mad,sad\xA63er:shy,fun\xA64der:glad\xA6:\xA64r:cute,dire,fake,fine,free,lame,late,pale,rare,ripe,rude,safe,sore,tame,wide\xA65r:eerie,stale"
  },
  "Gerund": {
    "fwd": "1:nning,tting,rring,pping,eing,mming,gging,dding,bbing,kking\xA62:eking,oling,eling,eming\xA63:velling,siting,uiting,fiting,loting,geting,ialing,celling\xA64:graming",
    "both": "1:aing,iing,fing,xing,ying,oing,hing,wing\xA62:tzing,rping,izzing,bting,mning,sping,wling,rling,wding,rbing,uping,lming,wning,mping,oning,lting,mbing,lking,fting,hting,sking,gning,pting,cking,ening,nking,iling,eping,ering,rting,rming,cting,lping,ssing,nting,nding,lding,sting,rning,rding,rking\xA63:belling,siping,toming,yaking,uaking,oaning,auling,ooping,aiding,naping,euring,tolling,uzzing,ganing,haning,ualing,halling,iasing,auding,ieting,ceting,ouling,voring,ralling,garing,joring,oaming,oaking,roring,nelling,ooring,uelling,eaming,ooding,eaping,eeting,ooting,ooming,xiting,keting,ooking,ulling,airing,oaring,biting,outing,oiting,earing,naling,oading,eeding,ouring,eaking,aiming,illing,oining,eaning,onging,ealing,aining,eading\xA64:thoming,melling,aboring,ivoting,weating,dfilling,onoring,eriting,imiting,tialling,rgining,otoring,linging,winging,lleting,louding,spelling,mpelling,heating,feating,opelling,choring,welling,ymaking,ctoring,calling,peating,iloring,laiting,utoring,uditing,mmaking,loating,iciting,waiting,mbating,voiding,otalling,nsoring,nselling,ocusing,itoring,eloping\xA65:rselling,umpeting,atrolling,treating,tselling,rpreting,pringing,ummeting,ossoming,elmaking,eselling,rediting,totyping,onmaking,rfeiting,ntrolling\xA65e:chmaking,dkeeping,severing,erouting,ecreting,ephoning,uthoring,ravening,reathing,pediting,erfering,eotyping,fringing,entoring,ombining,ompeting\xA64e:emaking,eething,twining,rruling,chuting,xciting,rseding,scoping,edoring,pinging,lunging,agining,craping,pleting,eleting,nciting,nfining,ncoding,tponing,ecoding,writing,esaling,nvening,gnoring,evoting,mpeding,rvening,dhering,mpiling,storing,nviting,ploring\xA63e:tining,nuring,saking,miring,haling,ceding,xuding,rining,nuting,laring,caring,miling,riding,hoking,piring,lading,curing,uading,noting,taping,futing,paring,hading,loding,siring,guring,vading,voking,during,niting,laning,caping,luting,muting,ruding,ciding,juring,laming,caling,hining,uoting,liding,ciling,duling,tuting,puting,cuting,coring,uiding,tiring,turing,siding,rading,enging,haping,buting,lining,taking,anging,haring,uiring,coming,mining,moting,suring,viding,luding\xA62e:tring,zling,uging,oging,gling,iging,vring,fling,lging,obing,psing,pling,ubing,cling,dling,wsing,iking,rsing,dging,kling,ysing,tling,rging,eging,nsing,uning,osing,uming,using,ibing,bling,aging,ising,asing,ating\xA62ie:rlying\xA61e:zing,uing,cing,ving",
    "rev": "ying:ie\xA61ing:se,ke,te,we,ne,re,de,pe,me,le,c,he\xA62ing:ll,ng,dd,ee,ye,oe,rg,us\xA62ning:un\xA62ging:og,ag,ug,ig,eg\xA62ming:um\xA62bing:ub,ab,eb,ob\xA63ning:lan,can,hin,pin,win\xA63ring:cur,lur,tir,tar,pur,car\xA63ing:ait,del,eel,fin,eat,oat,eem,lel,ool,ein,uin\xA63ping:rop,rap,top,uip,wap,hip,hop,lap,rip,cap\xA63ming:tem,wim,rim,kim,lim\xA63ting:mat,cut,pot,lit,lot,hat,set,pit,put\xA63ding:hed,bed,bid\xA63king:rek\xA63ling:cil,pel\xA63bing:rib\xA64ning:egin\xA64ing:isit,ruit,ilot,nsit,dget,rkel,ival,rcel\xA64ring:efer,nfer\xA64ting:rmit,mmit,ysit,dmit,emit,bmit,tfit,gret\xA64ling:evel,xcel,ivel\xA64ding:hred\xA65ing:arget,posit,rofit\xA65ring:nsfer\xA65ting:nsmit,orget,cquit\xA65ling:ancel,istil",
    "ex": "3:adding,eating,aiming,aiding,airing,outing,gassing,setting,getting,putting,cutting,winning,sitting,betting,mapping,tapping,letting,bidding,hitting,tanning,netting,popping,fitting,capping,lapping,barring,banning,vetting,topping,rotting,tipping,potting,wetting,pitting,dipping,budding,hemming,pinning,jetting,kidding,padding,podding,sipping,wedding,bedding,donning,warring,penning,gutting,cueing,wadding,petting,ripping,napping,matting,tinning,binning,dimming,hopping,mopping,nodding,panning,rapping,ridding,sinning\xA64:selling,falling,calling,waiting,editing,telling,rolling,heating,boating,hanging,beating,coating,singing,tolling,felling,polling,discing,seating,voiding,gelling,yelling,baiting,reining,ruining,seeking,spanning,stepping,knitting,emitting,slipping,quitting,dialing,omitting,clipping,shutting,skinning,abutting,flipping,trotting,cramming,fretting,suiting\xA65:bringing,treating,spelling,stalling,trolling,expelling,rivaling,wringing,deterring,singeing,befitting,refitting\xA66:enrolling,distilling,scrolling,strolling,caucusing,travelling\xA67:installing,redefining,stencilling,recharging,overeating,benefiting,unraveling,programing\xA69:reprogramming\xA6is:being\xA62e:using,aging,owing\xA63e:making,taking,coming,noting,hiring,filing,coding,citing,doping,baking,coping,hoping,lading,caring,naming,voting,riding,mining,curing,lining,ruling,typing,boring,dining,firing,hiding,piling,taping,waning,baling,boning,faring,honing,wiping,luring,timing,wading,piping,fading,biting,zoning,daring,waking,gaming,raking,ceding,tiring,coking,wining,joking,paring,gaping,poking,pining,coring,liming,toting,roping,wiring,aching\xA64e:writing,storing,eroding,framing,smoking,tasting,wasting,phoning,shaking,abiding,braking,flaking,pasting,priming,shoring,sloping,withing,hinging\xA65e:defining,refining,renaming,swathing,fringing,reciting\xA61ie:dying,tying,lying,vying\xA67e:sunbathing"
  },
  "Participle": {
    "fwd": "1:mt\xA62:llen\xA63:iven,aken\xA6:ne\xA6y:in",
    "both": "1:wn\xA62:me,aten\xA63:seen,bidden,isen\xA64:roven,asten\xA63l:pilt\xA63d:uilt\xA62e:itten\xA61im:wum\xA61eak:poken\xA61ine:hone\xA61ose:osen\xA61in:gun\xA61ake:woken\xA6ear:orn\xA6eal:olen\xA6eeze:ozen\xA6et:otten\xA6ink:unk\xA6ing:ung",
    "rev": "2:un\xA6oken:eak\xA6ought:eek\xA6oven:eave\xA61ne:o\xA61own:ly\xA61den:de\xA61in:ay\xA62t:am\xA62n:ee\xA63en:all\xA64n:rive,sake,take\xA65n:rgive",
    "ex": "2:been\xA63:seen,run\xA64:given,taken\xA65:shaken\xA62eak:broken\xA61ive:dove\xA62y:flown\xA63e:hidden,ridden\xA61eek:sought\xA61ake:woken\xA61eave:woven"
  },
  "PastTense": {
    "fwd": "1:tted,wed,gged,nned,een,rred,pped,yed,bbed,oed,dded,rd,wn,mmed\xA62:eed,nded,et,hted,st,oled,ut,emed,eled,lded,ken,rt,nked,apt,ant,eped,eked\xA63:eared,eat,eaded,nelled,ealt,eeded,ooted,eaked,eaned,eeted,mited,bid,uit,ead,uited,ealed,geted,velled,ialed,belled\xA64:ebuted,hined,comed\xA6y:ied\xA6ome:ame\xA6ear:ore\xA6ind:ound\xA6ing:ung,ang\xA6ep:pt\xA6ink:ank,unk\xA6ig:ug\xA6all:ell\xA6ee:aw\xA6ive:ave\xA6eeze:oze\xA6old:eld\xA6ave:ft\xA6ake:ook\xA6ell:old\xA6ite:ote\xA6ide:ode\xA6ine:one\xA6in:un,on\xA6eal:ole\xA6im:am\xA6ie:ay\xA6and:ood\xA61ise:rose\xA61eak:roke\xA61ing:rought\xA61ive:rove\xA61el:elt\xA61id:bade\xA61et:got\xA61y:aid\xA61it:sat\xA63e:lid\xA63d:pent",
    "both": "1:aed,fed,xed,hed\xA62:sged,xted,wled,rped,lked,kied,lmed,lped,uped,bted,rbed,rked,wned,rled,mped,fted,mned,mbed,zzed,omed,ened,cked,gned,lted,sked,ued,zed,nted,ered,rted,rmed,ced,sted,rned,ssed,rded,pted,ved,cted\xA63:cled,eined,siped,ooned,uked,ymed,jored,ouded,ioted,oaned,lged,asped,iged,mured,oided,eiled,yped,taled,moned,yled,lit,kled,oaked,gled,naled,fled,uined,oared,valled,koned,soned,aided,obed,ibed,meted,nicked,rored,micked,keted,vred,ooped,oaded,rited,aired,auled,filled,ouled,ooded,ceted,tolled,oited,bited,aped,tled,vored,dled,eamed,nsed,rsed,sited,owded,pled,sored,rged,osed,pelled,oured,psed,oated,loned,aimed,illed,eured,tred,ioned,celled,bled,wsed,ooked,oiled,itzed,iked,iased,onged,ased,ailed,uned,umed,ained,auded,nulled,ysed,eged,ised,aged,oined,ated,used,dged,doned\xA64:ntied,efited,uaked,caded,fired,roped,halled,roked,himed,culed,tared,lared,tuted,uared,routed,pited,naked,miled,houted,helled,hared,cored,caled,tired,peated,futed,ciled,called,tined,moted,filed,sided,poned,iloted,honed,lleted,huted,ruled,cured,named,preted,vaded,sured,talled,haled,peded,gined,nited,uided,ramed,feited,laked,gured,ctored,unged,pired,cuted,voked,eloped,ralled,rined,coded,icited,vided,uaded,voted,mined,sired,noted,lined,nselled,luted,jured,fided,puted,piled,pared,olored,cided,hoked,enged,tured,geoned,cotted,lamed,uiled,waited,udited,anged,luded,mired,uired,raded\xA65:modelled,izzled,eleted,umpeted,ailored,rseded,treated,eduled,ecited,rammed,eceded,atrolled,nitored,basted,twined,itialled,ncited,gnored,ploded,xcited,nrolled,namelled,plored,efeated,redited,ntrolled,nfined,pleted,llided,lcined,eathed,ibuted,lloted,dhered,cceded\xA63ad:sled\xA62aw:drew\xA62ot:hot\xA62ke:made\xA62ow:hrew,grew\xA62ose:hose\xA62d:ilt\xA62in:egan\xA61un:ran\xA61ink:hought\xA61ick:tuck\xA61ike:ruck\xA61eak:poke,nuck\xA61it:pat\xA61o:did\xA61ow:new\xA61ake:woke\xA6go:went",
    "rev": "3:rst,hed,hut,cut,set\xA64:tbid\xA65:dcast,eread,pread,erbid\xA6ought:uy,eek\xA61ied:ny,ly,dy,ry,fy,py,vy,by,ty,cy\xA61ung:ling,ting,wing\xA61pt:eep\xA61ank:rink\xA61ore:bear,wear\xA61ave:give\xA61oze:reeze\xA61ound:rind,wind\xA61ook:take,hake\xA61aw:see\xA61old:sell\xA61ote:rite\xA61ole:teal\xA61unk:tink\xA61am:wim\xA61ay:lie\xA61ood:tand\xA61eld:hold\xA62d:he,ge,re,le,leed,ne,reed,be,ye,lee,pe,we\xA62ed:dd,oy,or,ey,gg,rr,us,ew,to\xA62ame:ecome,rcome\xA62ped:ap\xA62ged:ag,og,ug,eg\xA62bed:ub,ab,ib,ob\xA62lt:neel\xA62id:pay\xA62ang:pring\xA62ove:trive\xA62med:um\xA62ode:rride\xA62at:ysit\xA63ted:mit,hat,mat,lat,pot,rot,bat\xA63ed:low,end,tow,und,ond,eem,lay,cho,dow,xit,eld,ald,uld,law,lel,eat,oll,ray,ank,fin,oam,out,how,iek,tay,haw,ait,vet,say,cay,bow\xA63d:ste,ede,ode,ete,ree,ude,ame,oke,ote,ime,ute,ade\xA63red:lur,cur,pur,car\xA63ped:hop,rop,uip,rip,lip,tep,top\xA63ded:bed,rod,kid\xA63ade:orbid\xA63led:uel\xA63ned:lan,can,kin,pan,tun\xA63med:rim,lim\xA64ted:quit,llot\xA64ed:pear,rrow,rand,lean,mand,anel,pand,reet,link,abel,evel,imit,ceed,ruit,mind,peal,veal,hool,head,pell,well,mell,uell,band,hear,weak\xA64led:nnel,qual,ebel,ivel\xA64red:nfer,efer,sfer\xA64n:sake,trew\xA64d:ntee\xA64ded:hred\xA64ned:rpin\xA65ed:light,nceal,right,ndear,arget,hread,eight,rtial,eboot\xA65d:edite,nvite\xA65ted:egret\xA65led:ravel",
    "ex": "2:been,upped\xA63:added,aged,aided,aimed,aired,bid,died,dyed,egged,erred,eyed,fit,gassed,hit,lied,owed,pent,pied,tied,used,vied,oiled,outed,banned,barred,bet,canned,cut,dipped,donned,ended,feed,inked,jarred,let,manned,mowed,netted,padded,panned,pitted,popped,potted,put,set,sewn,sowed,tanned,tipped,topped,vowed,weed,bowed,jammed,binned,dimmed,hopped,mopped,nodded,pinned,rigged,sinned,towed,vetted\xA64:ached,baked,baled,boned,bored,called,caned,cared,ceded,cited,coded,cored,cubed,cured,dared,dined,edited,exited,faked,fared,filed,fined,fired,fuelled,gamed,gelled,hired,hoped,joked,lined,mined,named,noted,piled,poked,polled,pored,pulled,reaped,roamed,rolled,ruled,seated,shed,sided,timed,tolled,toned,voted,waited,walled,waned,winged,wiped,wired,zoned,yelled,tamed,lubed,roped,faded,mired,caked,honed,banged,culled,heated,raked,welled,banded,beat,cast,cooled,cost,dealt,feared,folded,footed,handed,headed,heard,hurt,knitted,landed,leaked,leapt,linked,meant,minded,molded,neared,needed,peaked,plodded,plotted,pooled,quit,read,rooted,sealed,seeded,seeped,shipped,shunned,skimmed,slammed,sparred,stemmed,stirred,suited,thinned,twinned,swayed,winked,dialed,abutted,blotted,fretted,healed,heeded,peeled,reeled\xA65:basted,cheated,equalled,eroded,exiled,focused,opined,pleated,primed,quoted,scouted,shored,sloped,smoked,sniped,spelled,spouted,routed,staked,stored,swelled,tasted,treated,wasted,smelled,dwelled,honored,prided,quelled,eloped,scared,coveted,sweated,breaded,cleared,debuted,deterred,freaked,modeled,pleaded,rebutted,speeded\xA66:anchored,defined,endured,impaled,invited,refined,revered,strolled,cringed,recast,thrust,unfolded\xA67:authored,combined,competed,conceded,convened,excreted,extruded,redefined,restored,secreted,rescinded,welcomed\xA68:expedited,infringed\xA69:interfered,intervened,persevered\xA610:contravened\xA6eat:ate\xA6is:was\xA6go:went\xA6are:were\xA63d:bent,lent,rent,sent\xA63e:bit,fled,hid,lost\xA63ed:bled,bred\xA62ow:blew,grew\xA61uy:bought\xA62tch:caught\xA61o:did\xA61ive:dove,gave\xA62aw:drew\xA62ed:fed\xA62y:flew,laid,paid,said\xA61ight:fought\xA61et:got\xA62ve:had\xA61ang:hung\xA62ad:led\xA62ght:lit\xA62ke:made\xA62et:met\xA61un:ran\xA61ise:rose\xA61it:sat\xA61eek:sought\xA61each:taught\xA61ake:woke,took\xA61eave:wove\xA62ise:arose\xA61ear:bore,tore,wore\xA61ind:bound,found,wound\xA62eak:broke\xA62ing:brought,wrung\xA61ome:came\xA62ive:drove\xA61ig:dug\xA61all:fell\xA62el:felt\xA64et:forgot\xA61old:held\xA62ave:left\xA61ing:rang,sang\xA61ide:rode\xA61ink:sank\xA61ee:saw\xA62ine:shone\xA64e:slid\xA61ell:sold,told\xA64d:spent\xA62in:spun\xA61in:won"
  },
  "PresentTense": {
    "fwd": "1:oes\xA61ve:as",
    "both": "1:xes\xA62:zzes,ches,shes,sses\xA63:iases\xA62y:llies,plies\xA61y:cies,bies,ties,vies,nies,pies,dies,ries,fies\xA6:s",
    "rev": "1ies:ly\xA62es:us,go,do\xA63es:cho,eto",
    "ex": "2:does,goes\xA63:gasses\xA65:focuses\xA6is:are\xA63y:relies\xA62y:flies\xA62ve:has"
  },
  "Superlative": {
    "fwd": "1st:e\xA61est:l,m,f,s\xA61iest:cey\xA62est:or,ir\xA63est:ver",
    "both": "4:east\xA65:hwest\xA65lest:erful\xA64est:weet,lgar,tter,oung\xA64most:uter\xA63est:ger,der,rey,iet,ong,ear\xA63test:lat\xA63most:ner\xA62est:pt,ft,nt,ct,rt,ht\xA62test:it\xA62gest:ig\xA61est:b,k,n,p,h,d,w\xA6iest:y",
    "rev": "1:ttest,nnest,yest\xA62:sest,stest,rmest,cest,vest,lmest,olest,ilest,ulest,ssest,imest,uest\xA63:rgest,eatest,oorest,plest,allest,urest,iefest,uelest,blest,ugest,amest,yalest,ealest,illest,tlest,itest\xA64:cerest,eriest,somest,rmalest,ndomest,motest,uarest,tiffest\xA65:leverest,rangest\xA6ar:urthest\xA63ey:riciest",
    "ex": "best:good\xA6worst:bad\xA65est:great\xA64est:fast,full,fair,dull\xA63test:hot,wet,fat\xA64nest:thin\xA61urthest:far\xA63est:gay,shy,ill\xA64test:neat\xA64st:late,wide,fine,safe,cute,fake,pale,rare,rude,sore,ripe,dire\xA66st:severe"
  },
  "AdjToNoun": {
    "fwd": "1:tistic,eable,lful,sful,ting,tty\xA62:onate,rtable,geous,ced,seful,ctful\xA63:ortive,ented\xA6arity:ear\xA6y:etic\xA6fulness:begone\xA61ity:re\xA61y:tiful,gic\xA62ity:ile,imous,ilous,ime\xA62ion:ated\xA62eness:iving\xA62y:trious\xA62ation:iring\xA62tion:vant\xA63ion:ect\xA63ce:mant,mantic\xA63tion:irable\xA63y:est,estic\xA63m:mistic,listic\xA63ess:ning\xA64n:utious\xA64on:rative,native,vative,ective\xA64ce:erant",
    "both": "1:king,wing\xA62:alous,ltuous,oyful,rdous\xA63:gorous,ectable,werful,amatic\xA64:oised,usical,agical,raceful,ocused,lined,ightful\xA65ness:stful,lding,itous,nuous,ulous,otous,nable,gious,ayful,rvous,ntous,lsive,peful,entle,ciful,osive,leful,isive,ncise,reful,mious\xA65ty:ivacious\xA65ties:ubtle\xA65ce:ilient,adiant,atient\xA65cy:icient\xA65sm:gmatic\xA65on:sessive,dictive\xA65ity:pular,sonal,eative,entic\xA65sity:uminous\xA65ism:conic\xA65nce:mperate\xA65ility:mitable\xA65ment:xcited\xA65n:bitious\xA64cy:brant,etent,curate\xA64ility:erable,acable,icable,ptable\xA64ty:nacious,aive,oyal,dacious\xA64n:icious\xA64ce:vient,erent,stent,ndent,dient,quent,ident\xA64ness:adic,ound,hing,pant,sant,oing,oist,tute\xA64icity:imple\xA64ment:fined,mused\xA64ism:otic\xA64ry:dantic\xA64ity:tund,eral\xA64edness:hand\xA64on:uitive\xA64lity:pitable\xA64sm:eroic,namic\xA64sity:nerous\xA63th:arm\xA63ility:pable,bable,dable,iable\xA63cy:hant,nant,icate\xA63ness:red,hin,nse,ict,iet,ite,oud,ind,ied,rce\xA63ion:lute\xA63ity:ual,gal,volous,ial\xA63ce:sent,fensive,lant,gant,gent,lent,dant\xA63on:asive\xA63m:fist,sistic,iastic\xA63y:terious,xurious,ronic,tastic\xA63ur:amorous\xA63e:tunate\xA63ation:mined\xA63sy:rteous\xA63ty:ain\xA63ry:ave\xA63ment:azed\xA62ness:de,on,ue,rn,ur,ft,rp,pe,om,ge,rd,od,ay,ss,er,ll,oy,ap,ht,ld,ad,rt\xA62inousness:umous\xA62ity:neous,ene,id,ane\xA62cy:bate,late\xA62ation:ized\xA62ility:oble,ible\xA62y:odic\xA62e:oving,aring\xA62s:ost\xA62itude:pt\xA62dom:ee\xA62ance:uring\xA62tion:reet\xA62ion:oted\xA62sion:ending\xA62liness:an\xA62or:rdent\xA61th:ung\xA61e:uable\xA61ness:w,h,k,f\xA61ility:mble\xA61or:vent\xA61ement:ging\xA61tiquity:ncient\xA61ment:hed\xA6verty:or\xA6ength:ong\xA6eat:ot\xA6pth:ep\xA6iness:y",
    "rev": "",
    "ex": "5:forceful,humorous\xA68:charismatic\xA613:understanding\xA65ity:active\xA611ness:adventurous,inquisitive,resourceful\xA68on:aggressive,automatic,perceptive\xA67ness:amorous,fatuous,furtive,ominous,serious\xA65ness:ample,sweet\xA612ness:apprehensive,cantankerous,contemptuous,ostentatious\xA613ness:argumentative,conscientious\xA69ness:assertive,facetious,imperious,inventive,oblivious,rapacious,receptive,seditious,whimsical\xA610ness:attractive,expressive,impressive,loquacious,salubrious,thoughtful\xA63edom:boring\xA64ness:calm,fast,keen,tame\xA68ness:cheerful,gracious,specious,spurious,timorous,unctuous\xA65sity:curious\xA69ion:deliberate\xA68ion:desperate\xA66e:expensive\xA67ce:fragrant\xA63y:furious\xA69ility:ineluctable\xA66ism:mystical\xA68ity:physical,proactive,sensitive,vertical\xA65cy:pliant\xA67ity:positive\xA69ity:practical\xA612ism:professional\xA66ce:prudent\xA63ness:red\xA66cy:vagrant\xA63dom:wise"
  }
};

// node_modules/suffix-thumb/src/convert/index.js
var checkEx = function(str, ex = {}) {
  if (ex.hasOwnProperty(str)) {
    return ex[str];
  }
  return null;
};
var checkSame = function(str, same = []) {
  for (let i3 = 0; i3 < same.length; i3 += 1) {
    if (str.endsWith(same[i3])) {
      return str;
    }
  }
  return null;
};
var checkRules = function(str, fwd, both = {}) {
  fwd = fwd || {};
  let max3 = str.length - 1;
  for (let i3 = max3; i3 >= 1; i3 -= 1) {
    let size = str.length - i3;
    let suff = str.substring(size, str.length);
    if (fwd.hasOwnProperty(suff) === true) {
      return str.slice(0, size) + fwd[suff];
    }
    if (both.hasOwnProperty(suff) === true) {
      return str.slice(0, size) + both[suff];
    }
  }
  if (fwd.hasOwnProperty("")) {
    return str += fwd[""];
  }
  if (both.hasOwnProperty("")) {
    return str += both[""];
  }
  return null;
};
var convert = function(str = "", model5 = {}) {
  let out2 = checkEx(str, model5.ex);
  out2 = out2 || checkSame(str, model5.same);
  out2 = out2 || checkRules(str, model5.fwd, model5.both);
  out2 = out2 || str;
  return out2;
};
var convert_default = convert;

// node_modules/suffix-thumb/src/reverse/index.js
var flipObj = function(obj) {
  return Object.entries(obj).reduce((h2, a2) => {
    h2[a2[1]] = a2[0];
    return h2;
  }, {});
};
var reverse2 = function(model5 = {}) {
  return {
    reversed: true,
    // keep these two
    both: flipObj(model5.both),
    ex: flipObj(model5.ex),
    // swap this one in
    fwd: model5.rev || {}
  };
};
var reverse_default = reverse2;

// node_modules/suffix-thumb/src/compress/unpack.js
var prefix2 = /^([0-9]+)/;
var toObject = function(txt) {
  let obj = {};
  txt.split("\xA6").forEach((str) => {
    let [key2, vals] = str.split(":");
    vals = (vals || "").split(",");
    vals.forEach((val) => {
      obj[val] = key2;
    });
  });
  return obj;
};
var growObject = function(key2 = "", val = "") {
  val = String(val);
  let m3 = val.match(prefix2);
  if (m3 === null) {
    return val;
  }
  let num = Number(m3[1]) || 0;
  let pre = key2.substring(0, num);
  let full = pre + val.replace(prefix2, "");
  return full;
};
var unpackOne = function(str) {
  let obj = toObject(str);
  return Object.keys(obj).reduce((h2, k2) => {
    h2[k2] = growObject(k2, obj[k2]);
    return h2;
  }, {});
};
var uncompress = function(model5 = {}) {
  if (typeof model5 === "string") {
    model5 = JSON.parse(model5);
  }
  model5.fwd = unpackOne(model5.fwd || "");
  model5.both = unpackOne(model5.both || "");
  model5.rev = unpackOne(model5.rev || "");
  model5.ex = unpackOne(model5.ex || "");
  return model5;
};
var unpack_default2 = uncompress;

// node_modules/compromise/src/2-two/preTagger/model/models/index.js
var fromPast = unpack_default2(data_default2.PastTense);
var fromPresent = unpack_default2(data_default2.PresentTense);
var fromGerund = unpack_default2(data_default2.Gerund);
var fromParticiple = unpack_default2(data_default2.Participle);
var toPast = reverse_default(fromPast);
var toPresent = reverse_default(fromPresent);
var toGerund = reverse_default(fromGerund);
var toParticiple = reverse_default(fromParticiple);
var toComparative = unpack_default2(data_default2.Comparative);
var toSuperlative = unpack_default2(data_default2.Superlative);
var fromComparative = reverse_default(toComparative);
var fromSuperlative = reverse_default(toSuperlative);
var adjToNoun = unpack_default2(data_default2.AdjToNoun);
var models_default = {
  fromPast,
  fromPresent,
  fromGerund,
  fromParticiple,
  toPast,
  toPresent,
  toGerund,
  toParticiple,
  // adjectives
  toComparative,
  toSuperlative,
  fromComparative,
  fromSuperlative,
  adjToNoun
};

// node_modules/compromise/src/2-two/preTagger/model/regex/regex-normal.js
var regex_normal_default = [
  //web tags
  [/^[\w.]+@[\w.]+\.[a-z]{2,3}$/, "Email"],
  [/^(https?:\/\/|www\.)+\w+\.[a-z]{2,3}/, "Url", "http.."],
  [/^[a-z0-9./].+\.(com|net|gov|org|ly|edu|info|biz|dev|ru|jp|de|in|uk|br|io|ai)/, "Url", ".com"],
  // timezones
  [/^[PMCE]ST$/, "Timezone", "EST"],
  //names
  [/^ma?c'[a-z]{3}/, "LastName", "mc'neil"],
  [/^o'[a-z]{3}/, "LastName", "o'connor"],
  [/^ma?cd[aeiou][a-z]{3}/, "LastName", "mcdonald"],
  //slang things
  [/^(lol)+[sz]$/, "Expression", "lol"],
  [/^wo{2,}a*h?$/, "Expression", "wooah"],
  [/^(hee?){2,}h?$/, "Expression", "hehe"],
  [/^(un|de|re)\\-[a-z\u00C0-\u00FF]{2}/, "Verb", "un-vite"],
  // m/h
  [/^(m|k|cm|km)\/(s|h|hr)$/, "Unit", "5 k/m"],
  // g/g
  [/^(ug|ng|mg)\/(l|m3|ft3)$/, "Unit", "ug/L"],
  // love/hate
  [/[^:/]\/\p{Letter}/u, "SlashedTerm", "love/hate"]
];

// node_modules/compromise/src/2-two/preTagger/model/regex/regex-text.js
var regex_text_default = [
  // #coolguy
  [/^#[\p{Number}_]*\p{Letter}/u, "HashTag"],
  // can't be all numbers
  // @spencermountain
  [/^@\w{2,}$/, "AtMention"],
  // period-ones acronyms - f.b.i.
  [/^([A-Z]\.){2}[A-Z]?/i, ["Acronym", "Noun"], "F.B.I"],
  //ascii-only
  // ending-apostrophes
  [/.{3}[lkmnp]in['`]$/, "Gerund", "chillin'"],
  [/.{4}s['`]$/, "Possessive", "flanders'"],
  //from https://www.regextester.com/106421
  // [/^([\u00a9\u00ae\u2319-\u3300]|\ud83c[\ud000-\udfff]|\ud83d[\ud000-\udfff]|\ud83e[\ud000-\udfff])/, 'Emoji', 'emoji-range']
  // unicode character range
  [/^[\p{Emoji_Presentation}\p{Extended_Pictographic}]/u, "Emoji", "emoji-class"]
];

// node_modules/compromise/src/2-two/preTagger/model/regex/regex-numbers.js
var regex_numbers_default = [
  [/^@1?[0-9](am|pm)$/i, "Time", "3pm"],
  [/^@1?[0-9]:[0-9]{2}(am|pm)?$/i, "Time", "3:30pm"],
  [/^'[0-9]{2}$/, "Year"],
  // times
  [/^[012]?[0-9](:[0-5][0-9])(:[0-5][0-9])$/, "Time", "3:12:31"],
  [/^[012]?[0-9](:[0-5][0-9])?(:[0-5][0-9])? ?(am|pm)$/i, "Time", "1:12pm"],
  [/^[012]?[0-9](:[0-5][0-9])(:[0-5][0-9])? ?(am|pm)?$/i, "Time", "1:12:31pm"],
  //can remove?
  // iso-dates
  [/^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}/i, "Date", "iso-date"],
  [/^[0-9]{1,4}-[0-9]{1,2}-[0-9]{1,4}$/, "Date", "iso-dash"],
  [/^[0-9]{1,4}\/[0-9]{1,2}\/([0-9]{4}|[0-9]{2})$/, "Date", "iso-slash"],
  [/^[0-9]{1,4}\.[0-9]{1,2}\.[0-9]{1,4}$/, "Date", "iso-dot"],
  [/^[0-9]{1,4}-[a-z]{2,9}-[0-9]{1,4}$/i, "Date", "12-dec-2019"],
  // timezones
  [/^utc ?[+-]?[0-9]+$/, "Timezone", "utc-9"],
  [/^(gmt|utc)[+-][0-9]{1,2}$/i, "Timezone", "gmt-3"],
  //phone numbers
  [/^[0-9]{3}-[0-9]{4}$/, "PhoneNumber", "421-0029"],
  [/^(\+?[0-9][ -])?[0-9]{3}[ -]?[0-9]{3}-[0-9]{4}$/, "PhoneNumber", "1-800-"],
  //money
  //like $5.30
  [/^[-+]?\p{Currency_Symbol}[-+]?[0-9]+(,[0-9]{3})*(\.[0-9]+)?([kmb]|bn)?\+?$/u, ["Money", "Value"], "$5.30"],
  //like 5.30$
  [/^[-+]?[0-9]+(,[0-9]{3})*(\.[0-9]+)?\p{Currency_Symbol}\+?$/u, ["Money", "Value"], "5.30\xA3"],
  //like
  [/^[-+]?[$]?[0-9]([0-9,.])+(usd|eur|jpy|gbp|cad|aud|chf|cny|hkd|nzd|kr|rub)$/i, ["Money", "Value"], "$400usd"],
  //numbers
  // 50 | -50 | 3.23  | 5,999.0  | 10+
  [/^[-+]?[0-9]+(,[0-9]{3})*(\.[0-9]+)?\+?$/, ["Cardinal", "NumericValue"], "5,999"],
  [/^[-+]?[0-9]+(,[0-9]{3})*(\.[0-9]+)?(st|nd|rd|r?th)$/, ["Ordinal", "NumericValue"], "53rd"],
  // .73th
  [/^\.[0-9]+\+?$/, ["Cardinal", "NumericValue"], ".73th"],
  //percent
  [/^[-+]?[0-9]+(,[0-9]{3})*(\.[0-9]+)?%\+?$/, ["Percent", "Cardinal", "NumericValue"], "-4%"],
  [/^\.[0-9]+%$/, ["Percent", "Cardinal", "NumericValue"], ".3%"],
  //fraction
  [/^[0-9]{1,4}\/[0-9]{1,4}(st|nd|rd|th)?s?$/, ["Fraction", "NumericValue"], "2/3rds"],
  //range
  [/^[0-9.]{1,3}[a-z]{0,2}[-][0-9]{1,3}[a-z]{0,2}$/, ["Value", "NumberRange"], "3-4"],
  //time-range
  [/^[0-9]{1,2}(:[0-9][0-9])?(am|pm)? ?[-] ?[0-9]{1,2}(:[0-9][0-9])?(am|pm)$/, ["Time", "NumberRange"], "3-4pm"],
  //number with unit
  [/^[0-9.]+([a-z]{1,4})$/, "NumericValue", "9km"]
];

// node_modules/compromise/src/2-two/preTagger/model/orgWords.js
var orgWords_default = [
  "academy",
  "administration",
  "agence",
  "agences",
  "agencies",
  "agency",
  "airlines",
  "airways",
  "army",
  "assoc",
  "associates",
  "association",
  "assurance",
  "authority",
  "autorite",
  "aviation",
  "bank",
  "banque",
  "board",
  "boys",
  "brands",
  "brewery",
  "brotherhood",
  "brothers",
  "bureau",
  "cafe",
  "co",
  "caisse",
  "capital",
  "care",
  "cathedral",
  "center",
  "centre",
  "chemicals",
  "choir",
  "chronicle",
  "church",
  "circus",
  "clinic",
  "clinique",
  "club",
  "co",
  "coalition",
  "coffee",
  "collective",
  "college",
  "commission",
  "committee",
  "communications",
  "community",
  "company",
  "comprehensive",
  "computers",
  "confederation",
  "conference",
  "conseil",
  "consulting",
  "containers",
  "corporation",
  "corps",
  "corp",
  "council",
  "crew",
  "data",
  "departement",
  "department",
  "departments",
  "design",
  "development",
  "directorate",
  "division",
  "drilling",
  "education",
  "eglise",
  "electric",
  "electricity",
  "energy",
  "ensemble",
  "enterprise",
  "enterprises",
  "entertainment",
  "estate",
  "etat",
  "faculty",
  "faction",
  "federation",
  "financial",
  "fm",
  "foundation",
  "fund",
  "gas",
  "gazette",
  "girls",
  "government",
  "group",
  "guild",
  "herald",
  "holdings",
  "hospital",
  "hotel",
  "hotels",
  "inc",
  "industries",
  "institut",
  "institute",
  "institutes",
  "insurance",
  "international",
  "interstate",
  "investment",
  "investments",
  "investors",
  "journal",
  "laboratory",
  "labs",
  "llc",
  "ltd",
  "limited",
  "machines",
  "magazine",
  "management",
  "marine",
  "marketing",
  "markets",
  "media",
  "memorial",
  "ministere",
  "ministry",
  "military",
  "mobile",
  "motor",
  "motors",
  "musee",
  "museum",
  "news",
  "observatory",
  "office",
  "oil",
  "optical",
  "orchestra",
  "organization",
  "partners",
  "partnership",
  "petrol",
  "petroleum",
  "pharmacare",
  "pharmaceutical",
  "pharmaceuticals",
  "pizza",
  "plc",
  "police",
  "politburo",
  "polytechnic",
  "post",
  "power",
  "press",
  "productions",
  "quartet",
  "radio",
  "reserve",
  "resources",
  "restaurant",
  "restaurants",
  "savings",
  "school",
  "securities",
  "service",
  "services",
  "societe",
  "subsidiary",
  "society",
  "sons",
  // 'standard',
  "subcommittee",
  "syndicat",
  "systems",
  "telecommunications",
  "telegraph",
  "television",
  "times",
  "tribunal",
  "tv",
  "union",
  "university",
  "utilities",
  "workers"
].reduce((h2, str) => {
  h2[str] = true;
  return h2;
}, {});

// node_modules/compromise/src/2-two/preTagger/model/placeWords.js
var placeWords_default = [
  // geology
  "atoll",
  "basin",
  "bay",
  "beach",
  "bluff",
  "bog",
  "camp",
  "canyon",
  "canyons",
  "cape",
  "cave",
  "caves",
  // 'cliff',
  "cliffs",
  "coast",
  "cove",
  "coves",
  "crater",
  "crossing",
  "creek",
  "desert",
  "dune",
  "dunes",
  "downs",
  "estates",
  "escarpment",
  "estuary",
  "falls",
  "fjord",
  "fjords",
  "forest",
  "forests",
  "glacier",
  "gorge",
  "gorges",
  "grove",
  "gulf",
  "gully",
  "highland",
  "heights",
  "hollow",
  "hill",
  "hills",
  "inlet",
  "island",
  "islands",
  "isthmus",
  "junction",
  "knoll",
  "lagoon",
  "lake",
  "lakeshore",
  "marsh",
  "marshes",
  "mount",
  "mountain",
  "mountains",
  "narrows",
  "peninsula",
  "plains",
  "plateau",
  "pond",
  "rapids",
  "ravine",
  "reef",
  "reefs",
  "ridge",
  // 'river delta',
  "river",
  "rivers",
  "sandhill",
  "shoal",
  "shore",
  "shoreline",
  "shores",
  "strait",
  "straits",
  "springs",
  "stream",
  "swamp",
  "tombolo",
  "trail",
  "trails",
  "trench",
  "valley",
  "vallies",
  "village",
  "volcano",
  "waterfall",
  "watershed",
  "wetland",
  "woods",
  "acres",
  // districts
  "burough",
  "county",
  "district",
  "municipality",
  "prefecture",
  "province",
  "region",
  "reservation",
  "state",
  "territory",
  "borough",
  "metropolis",
  "downtown",
  "uptown",
  "midtown",
  "city",
  "town",
  "township",
  "hamlet",
  "country",
  "kingdom",
  "enclave",
  "neighbourhood",
  "neighborhood",
  "kingdom",
  "ward",
  "zone",
  // 'range',
  //building/ complex
  "airport",
  "amphitheater",
  "arch",
  "arena",
  "auditorium",
  "bar",
  "barn",
  "basilica",
  "battlefield",
  "bridge",
  "building",
  "castle",
  "centre",
  "coliseum",
  "cineplex",
  "complex",
  "dam",
  "farm",
  "field",
  "fort",
  "garden",
  "gardens",
  // 'grounds',
  "gymnasium",
  "hall",
  "house",
  "levee",
  "library",
  "manor",
  "memorial",
  "monument",
  "museum",
  "gallery",
  "palace",
  "pillar",
  "pits",
  // 'pit',
  // 'place',
  // 'point',
  // 'room',
  "plantation",
  "playhouse",
  "quarry",
  // 'ruins',
  "sportsfield",
  "sportsplex",
  "stadium",
  // 'statue',
  "terrace",
  "terraces",
  "theater",
  "tower",
  "park",
  "parks",
  "site",
  "ranch",
  "raceway",
  "sportsplex",
  // 'sports centre',
  // 'sports field',
  // 'soccer complex',
  // 'soccer centre',
  // 'sports complex',
  // 'civic centre',
  // roads
  "ave",
  "st",
  "street",
  "rd",
  "road",
  "lane",
  "landing",
  "crescent",
  "cr",
  "way",
  "tr",
  "terrace",
  "avenue"
].reduce((h2, str) => {
  h2[str] = true;
  return h2;
}, {});

// node_modules/compromise/src/2-two/preTagger/methods/transform/nouns/toSingular/_rules.js
var rules_default2 = [
  [/([^v])ies$/i, "$1y"],
  [/(ise)s$/i, "$1"],
  //promises
  [/(kn|[^o]l|w)ives$/i, "$1ife"],
  [/^((?:ca|e|ha|(?:our|them|your)?se|she|wo)l|lea|loa|shea|thie)ves$/i, "$1f"],
  [/^(dwar|handkerchie|hoo|scar|whar)ves$/i, "$1f"],
  [/(antenn|formul|nebul|vertebr|vit)ae$/i, "$1a"],
  [/(octop|vir|radi|nucle|fung|cact|stimul)(i)$/i, "$1us"],
  [/(buffal|tomat|tornad)(oes)$/i, "$1o"],
  [/(ause)s$/i, "$1"],
  //causes
  [/(ease)s$/i, "$1"],
  //diseases
  [/(ious)es$/i, "$1"],
  //geniouses
  [/(ouse)s$/i, "$1"],
  //houses
  [/(ose)s$/i, "$1"],
  //roses
  [/(..ase)s$/i, "$1"],
  [/(..[aeiu]s)es$/i, "$1"],
  [/(vert|ind|cort)(ices)$/i, "$1ex"],
  [/(matr|append)(ices)$/i, "$1ix"],
  [/([xo]|ch|ss|sh)es$/i, "$1"],
  [/men$/i, "man"],
  [/(n)ews$/i, "$1ews"],
  [/([ti])a$/i, "$1um"],
  [/([^aeiouy]|qu)ies$/i, "$1y"],
  [/(s)eries$/i, "$1eries"],
  [/(m)ovies$/i, "$1ovie"],
  [/(cris|ax|test)es$/i, "$1is"],
  [/(alias|status)es$/i, "$1"],
  [/(ss)$/i, "$1"],
  [/(ic)s$/i, "$1"],
  [/s$/i, ""]
];

// node_modules/compromise/src/2-two/preTagger/methods/transform/nouns/toSingular/index.js
var invertObj = function(obj) {
  return Object.keys(obj).reduce((h2, k2) => {
    h2[obj[k2]] = k2;
    return h2;
  }, {});
};
var toSingular = function(str, model5) {
  const { irregularPlurals } = model5.two;
  let invert = invertObj(irregularPlurals);
  if (invert.hasOwnProperty(str)) {
    return invert[str];
  }
  for (let i3 = 0; i3 < rules_default2.length; i3++) {
    if (rules_default2[i3][0].test(str) === true) {
      str = str.replace(rules_default2[i3][0], rules_default2[i3][1]);
      return str;
    }
  }
  return str;
};
var toSingular_default = toSingular;

// node_modules/compromise/src/2-two/preTagger/methods/transform/nouns/index.js
var all = function(str, model5) {
  let arr = [str];
  let p5 = toPlural_default(str, model5);
  if (p5 !== str) {
    arr.push(p5);
  }
  let s3 = toSingular_default(str, model5);
  if (s3 !== str) {
    arr.push(s3);
  }
  return arr;
};
var nouns_default2 = { toPlural: toPlural_default, toSingular: toSingular_default, all };

// node_modules/compromise/src/2-two/preTagger/methods/transform/verbs/getTense/_guess.js
var guessVerb = {
  Gerund: ["ing"],
  Actor: ["erer"],
  Infinitive: [
    "ate",
    "ize",
    "tion",
    "rify",
    "then",
    "ress",
    "ify",
    "age",
    "nce",
    "ect",
    "ise",
    "ine",
    "ish",
    "ace",
    "ash",
    "ure",
    "tch",
    "end",
    "ack",
    "and",
    "ute",
    "ade",
    "ock",
    "ite",
    "ase",
    "ose",
    "use",
    "ive",
    "int",
    "nge",
    "lay",
    "est",
    "ain",
    "ant",
    "ent",
    "eed",
    "er",
    "le",
    "unk",
    "ung",
    "upt",
    "en"
  ],
  PastTense: ["ept", "ed", "lt", "nt", "ew", "ld"],
  PresentTense: [
    "rks",
    "cks",
    "nks",
    "ngs",
    "mps",
    "tes",
    "zes",
    "ers",
    "les",
    "acks",
    "ends",
    "ands",
    "ocks",
    "lays",
    "eads",
    "lls",
    "els",
    "ils",
    "ows",
    "nds",
    "ays",
    "ams",
    "ars",
    "ops",
    "ffs",
    "als",
    "urs",
    "lds",
    "ews",
    "ips",
    "es",
    "ts",
    "ns"
  ],
  Participle: ["ken", "wn"]
};
guessVerb = Object.keys(guessVerb).reduce((h2, k2) => {
  guessVerb[k2].forEach((a2) => h2[a2] = k2);
  return h2;
}, {});
var guess_default = guessVerb;

// node_modules/compromise/src/2-two/preTagger/methods/transform/verbs/getTense/index.js
var getTense = function(str) {
  let three = str.substring(str.length - 3);
  if (guess_default.hasOwnProperty(three) === true) {
    return guess_default[three];
  }
  let two = str.substring(str.length - 2);
  if (guess_default.hasOwnProperty(two) === true) {
    return guess_default[two];
  }
  let one = str.substring(str.length - 1);
  if (one === "s") {
    return "PresentTense";
  }
  return null;
};
var getTense_default = getTense;

// node_modules/compromise/src/2-two/preTagger/methods/transform/verbs/toInfinitive/index.js
var toParts = function(str, model5) {
  let prefix5 = "";
  let prefixes2 = {};
  if (model5.one && model5.one.prefixes) {
    prefixes2 = model5.one.prefixes;
  }
  let [verb, particle] = str.split(/ /);
  if (particle && prefixes2[verb] === true) {
    prefix5 = verb;
    verb = particle;
    particle = "";
  }
  return {
    prefix: prefix5,
    verb,
    particle
  };
};
var copulaMap = {
  are: "be",
  were: "be",
  been: "be",
  is: "be",
  am: "be",
  was: "be",
  be: "be",
  being: "be"
};
var toInfinitive = function(str, model5, tense) {
  const { fromPast: fromPast2, fromPresent: fromPresent2, fromGerund: fromGerund2, fromParticiple: fromParticiple2 } = model5.two.models;
  let { prefix: prefix5, verb, particle } = toParts(str, model5);
  let inf = "";
  if (!tense) {
    tense = getTense_default(str);
  }
  if (copulaMap.hasOwnProperty(str)) {
    inf = copulaMap[str];
  } else if (tense === "Participle") {
    inf = convert_default(verb, fromParticiple2);
  } else if (tense === "PastTense") {
    inf = convert_default(verb, fromPast2);
  } else if (tense === "PresentTense") {
    inf = convert_default(verb, fromPresent2);
  } else if (tense === "Gerund") {
    inf = convert_default(verb, fromGerund2);
  } else {
    return str;
  }
  if (particle) {
    inf += " " + particle;
  }
  if (prefix5) {
    inf = prefix5 + " " + inf;
  }
  return inf;
};
var toInfinitive_default = toInfinitive;

// node_modules/compromise/src/2-two/preTagger/methods/transform/verbs/conjugate/index.js
var parse3 = (inf) => {
  if (/ /.test(inf)) {
    return inf.split(/ /);
  }
  return [inf, ""];
};
var conjugate = function(inf, model5) {
  const { toPast: toPast5, toPresent: toPresent4, toGerund: toGerund4, toParticiple: toParticiple2 } = model5.two.models;
  if (inf === "be") {
    return {
      Infinitive: inf,
      Gerund: "being",
      PastTense: "was",
      PresentTense: "is"
    };
  }
  let [str, particle] = parse3(inf);
  let found = {
    Infinitive: str,
    PastTense: convert_default(str, toPast5),
    PresentTense: convert_default(str, toPresent4),
    Gerund: convert_default(str, toGerund4),
    FutureTense: "will " + str
  };
  let pastPrt = convert_default(str, toParticiple2);
  if (pastPrt !== inf && pastPrt !== found.PastTense) {
    let lex = model5.one.lexicon || {};
    if (lex[pastPrt] === "Participle" || lex[pastPrt] === "Adjective") {
      if (inf === "play") {
        pastPrt = "played";
      }
      found.Participle = pastPrt;
    }
  }
  if (particle) {
    Object.keys(found).forEach((k2) => {
      found[k2] += " " + particle;
    });
  }
  return found;
};
var conjugate_default = conjugate;

// node_modules/compromise/src/2-two/preTagger/methods/transform/verbs/index.js
var all2 = function(str, model5) {
  let res = conjugate_default(str, model5);
  delete res.FutureTense;
  return Object.values(res).filter((s3) => s3);
};
var verbs_default = {
  toInfinitive: toInfinitive_default,
  conjugate: conjugate_default,
  all: all2
};

// node_modules/compromise/src/2-two/preTagger/methods/transform/adjectives/inflect.js
var toSuperlative2 = function(adj, model5) {
  const mod = model5.two.models.toSuperlative;
  return convert_default(adj, mod);
};
var toComparative2 = function(adj, model5) {
  const mod = model5.two.models.toComparative;
  return convert_default(adj, mod);
};
var fromComparative2 = function(adj, model5) {
  const mod = model5.two.models.fromComparative;
  return convert_default(adj, mod);
};
var fromSuperlative2 = function(adj, model5) {
  const mod = model5.two.models.fromSuperlative;
  return convert_default(adj, mod);
};
var toNoun = function(adj, model5) {
  const mod = model5.two.models.adjToNoun;
  return convert_default(adj, mod);
};

// node_modules/compromise/src/2-two/preTagger/methods/transform/adjectives/conjugate/lib.js
var suffixLoop = function(str = "", suffixes5 = []) {
  const len = str.length;
  let max3 = len <= 6 ? len - 1 : 6;
  for (let i3 = max3; i3 >= 1; i3 -= 1) {
    let suffix = str.substring(len - i3, str.length);
    if (suffixes5[suffix.length].hasOwnProperty(suffix) === true) {
      let pre = str.slice(0, len - i3);
      let post = suffixes5[suffix.length][suffix];
      return pre + post;
    }
  }
  return null;
};
var lib_default6 = suffixLoop;

// node_modules/compromise/src/2-two/preTagger/methods/transform/adjectives/conjugate/fromAdverb.js
var s2 = "ically";
var ical = /* @__PURE__ */ new Set([
  "analyt" + s2,
  //analytical
  "chem" + s2,
  // chemical
  "class" + s2,
  //classical
  "clin" + s2,
  // clinical
  "crit" + s2,
  // critical
  "ecolog" + s2,
  // ecological
  "electr" + s2,
  // electrical
  "empir" + s2,
  // empirical
  "frant" + s2,
  // frantical
  "grammat" + s2,
  // grammatical
  "ident" + s2,
  // identical
  "ideolog" + s2,
  // ideological
  "log" + s2,
  // logical
  "mag" + s2,
  //magical
  "mathemat" + s2,
  // mathematical
  "mechan" + s2,
  // mechanical
  "med" + s2,
  // medical
  "method" + s2,
  // methodical
  "method" + s2,
  // methodical
  "mus" + s2,
  // musical
  "phys" + s2,
  // physical
  "phys" + s2,
  // physical
  "polit" + s2,
  // political
  "pract" + s2,
  // practical
  "rad" + s2,
  //radical
  "satir" + s2,
  // satirical
  "statist" + s2,
  // statistical
  "techn" + s2,
  // technical
  "technolog" + s2,
  // technological
  "theoret" + s2,
  // theoretical
  "typ" + s2,
  // typical
  "vert" + s2,
  // vertical
  "whims" + s2
  // whimsical
]);
var suffixes2 = [
  null,
  {},
  { "ly": "" },
  {
    "ily": "y",
    "bly": "ble",
    "ply": "ple"
  },
  {
    "ally": "al",
    "rply": "rp"
  },
  {
    "ually": "ual",
    "ially": "ial",
    "cally": "cal",
    "eally": "eal",
    "rally": "ral",
    "nally": "nal",
    "mally": "mal",
    "eeply": "eep",
    "eaply": "eap"
  },
  {
    ically: "ic"
  }
];
var noAdj = /* @__PURE__ */ new Set([
  "early",
  "only",
  "hourly",
  "daily",
  "weekly",
  "monthly",
  "yearly",
  "mostly",
  "duly",
  "unduly",
  "especially",
  "undoubtedly",
  "conversely",
  "namely",
  "exceedingly",
  "presumably",
  "accordingly",
  "overly",
  "best",
  "latter",
  "little",
  "long",
  "low"
]);
var exceptions = {
  wholly: "whole",
  fully: "full",
  truly: "true",
  gently: "gentle",
  singly: "single",
  customarily: "customary",
  idly: "idle",
  publically: "public",
  quickly: "quick",
  superbly: "superb",
  cynically: "cynical",
  well: "good"
  // -?
};
var toAdjective = function(str) {
  if (!str.endsWith("ly")) {
    return null;
  }
  if (ical.has(str)) {
    return str.replace(/ically/, "ical");
  }
  if (noAdj.has(str)) {
    return null;
  }
  if (exceptions.hasOwnProperty(str)) {
    return exceptions[str];
  }
  return lib_default6(str, suffixes2) || str;
};
var fromAdverb_default = toAdjective;

// node_modules/compromise/src/2-two/preTagger/methods/transform/adjectives/conjugate/toAdverb.js
var suffixes3 = [
  null,
  {
    y: "ily"
  },
  {
    ly: "ly",
    //unchanged
    ic: "ically"
  },
  {
    ial: "ially",
    ual: "ually",
    tle: "tly",
    ble: "bly",
    ple: "ply",
    ary: "arily"
  },
  {},
  {},
  {}
];
var exceptions2 = {
  cool: "cooly",
  whole: "wholly",
  full: "fully",
  good: "well",
  idle: "idly",
  public: "publicly",
  single: "singly",
  special: "especially"
};
var toAdverb = function(str) {
  if (exceptions2.hasOwnProperty(str)) {
    return exceptions2[str];
  }
  let adv = lib_default6(str, suffixes3);
  if (!adv) {
    adv = str + "ly";
  }
  return adv;
};
var toAdverb_default = toAdverb;

// node_modules/compromise/src/2-two/preTagger/methods/transform/adjectives/index.js
var all3 = function(str, model5) {
  let arr = [str];
  arr.push(toSuperlative2(str, model5));
  arr.push(toComparative2(str, model5));
  arr.push(toAdverb_default(str));
  arr = arr.filter((s3) => s3);
  arr = new Set(arr);
  return Array.from(arr);
};
var adjectives_default = {
  toSuperlative: toSuperlative2,
  toComparative: toComparative2,
  toAdverb: toAdverb_default,
  toNoun,
  fromAdverb: fromAdverb_default,
  fromSuperlative: fromSuperlative2,
  fromComparative: fromComparative2,
  all: all3
};

// node_modules/compromise/src/2-two/preTagger/methods/transform/index.js
var transform_default = {
  noun: nouns_default2,
  verb: verbs_default,
  adjective: adjectives_default
};

// node_modules/compromise/src/2-two/preTagger/methods/expand/byTag.js
var byTag_default = {
  // add plural forms of singular nouns
  Singular: (word, lex, methods17, model5) => {
    let already = model5.one.lexicon;
    let plural2 = methods17.two.transform.noun.toPlural(word, model5);
    if (!already[plural2]) {
      lex[plural2] = lex[plural2] || "Plural";
    }
  },
  // 'lawyer', 'manager' plural forms
  Actor: (word, lex, methods17, model5) => {
    let already = model5.one.lexicon;
    let plural2 = methods17.two.transform.noun.toPlural(word, model5);
    if (!already[plural2]) {
      lex[plural2] = lex[plural2] || ["Plural", "Actor"];
    }
  },
  // superlative/ comparative forms for adjectives
  Comparable: (word, lex, methods17, model5) => {
    let already = model5.one.lexicon;
    let { toSuperlative: toSuperlative3, toComparative: toComparative3 } = methods17.two.transform.adjective;
    let sup = toSuperlative3(word, model5);
    if (!already[sup]) {
      lex[sup] = lex[sup] || "Superlative";
    }
    let comp = toComparative3(word, model5);
    if (!already[comp]) {
      lex[comp] = lex[comp] || "Comparative";
    }
    lex[word] = "Adjective";
  },
  // 'german' -> 'germans'
  Demonym: (word, lex, methods17, model5) => {
    let plural2 = methods17.two.transform.noun.toPlural(word, model5);
    lex[plural2] = lex[plural2] || ["Demonym", "Plural"];
  },
  // conjugate all forms of these verbs
  Infinitive: (word, lex, methods17, model5) => {
    let already = model5.one.lexicon;
    let all4 = methods17.two.transform.verb.conjugate(word, model5);
    Object.entries(all4).forEach((a2) => {
      if (!already[a2[1]] && !lex[a2[1]] && a2[0] !== "FutureTense") {
        lex[a2[1]] = a2[0];
      }
    });
  },
  // 'walk up' should conjugate, too
  PhrasalVerb: (word, lex, methods17, model5) => {
    let already = model5.one.lexicon;
    lex[word] = ["PhrasalVerb", "Infinitive"];
    let _multi = model5.one._multiCache;
    let [inf, rest] = word.split(" ");
    if (!already[inf]) {
      lex[inf] = lex[inf] || "Infinitive";
    }
    let all4 = methods17.two.transform.verb.conjugate(inf, model5);
    delete all4.FutureTense;
    Object.entries(all4).forEach((a2) => {
      if (a2[0] === "Actor" || a2[1] === "") {
        return;
      }
      if (!lex[a2[1]] && !already[a2[1]]) {
        lex[a2[1]] = a2[0];
      }
      _multi[a2[1]] = 2;
      let str = a2[1] + " " + rest;
      lex[str] = lex[str] || [a2[0], "PhrasalVerb"];
    });
  },
  // expand 'million'
  Multiple: (word, lex) => {
    lex[word] = ["Multiple", "Cardinal"];
    lex[word + "th"] = ["Multiple", "Ordinal"];
    lex[word + "ths"] = ["Multiple", "Fraction"];
  },
  // expand number-words
  Cardinal: (word, lex) => {
    lex[word] = ["TextValue", "Cardinal"];
  },
  // 'millionth'
  Ordinal: (word, lex) => {
    lex[word] = ["TextValue", "Ordinal"];
    lex[word + "s"] = ["TextValue", "Fraction"];
  },
  // 'thames'
  Place: (word, lex) => {
    lex[word] = ["Place", "ProperNoun"];
  },
  // 'ontario'
  Region: (word, lex) => {
    lex[word] = ["Region", "ProperNoun"];
  }
};

// node_modules/compromise/src/2-two/preTagger/methods/expand/index.js
var expand3 = function(words, world2) {
  const { methods: methods17, model: model5 } = world2;
  let lex = {};
  let _multi = {};
  Object.keys(words).forEach((word) => {
    let tag2 = words[word];
    word = word.toLowerCase().trim();
    word = word.replace(/'s\b/, "");
    let split3 = word.split(/ /);
    if (split3.length > 1) {
      if (_multi[split3[0]] === void 0 || split3.length > _multi[split3[0]]) {
        _multi[split3[0]] = split3.length;
      }
    }
    if (byTag_default.hasOwnProperty(tag2) === true) {
      byTag_default[tag2](word, lex, methods17, model5);
    }
    lex[word] = lex[word] || tag2;
  });
  delete lex[""];
  delete lex[null];
  delete lex[" "];
  return { lex, _multi };
};
var expand_default2 = expand3;

// node_modules/compromise/src/2-two/preTagger/methods/quickSplit.js
var splitOn = function(terms, i3) {
  const isNum = /^[0-9]+$/;
  let term = terms[i3];
  if (!term) {
    return false;
  }
  const maybeDate = /* @__PURE__ */ new Set(["may", "april", "august", "jan"]);
  if (term.normal === "like" || maybeDate.has(term.normal)) {
    return false;
  }
  if (term.tags.has("Place") || term.tags.has("Date")) {
    return false;
  }
  if (terms[i3 - 1]) {
    let lastTerm = terms[i3 - 1];
    if (lastTerm.tags.has("Date") || maybeDate.has(lastTerm.normal)) {
      return false;
    }
    if (lastTerm.tags.has("Adjective") || term.tags.has("Adjective")) {
      return false;
    }
  }
  let str = term.normal;
  if (str.length === 1 || str.length === 2 || str.length === 4) {
    if (isNum.test(str)) {
      return false;
    }
  }
  return true;
};
var quickSplit = function(document2) {
  const splitHere = /[,:;]/;
  let arr = [];
  document2.forEach((terms) => {
    let start2 = 0;
    terms.forEach((term, i3) => {
      if (splitHere.test(term.post) && splitOn(terms, i3 + 1)) {
        arr.push(terms.slice(start2, i3 + 1));
        start2 = i3 + 1;
      }
    });
    if (start2 < terms.length) {
      arr.push(terms.slice(start2, terms.length));
    }
  });
  return arr;
};
var quickSplit_default = quickSplit;

// node_modules/compromise/src/2-two/preTagger/methods/looksPlural.js
var isPlural = {
  e: ["mice", "louse", "antennae", "formulae", "nebulae", "vertebrae", "vitae"],
  i: ["tia", "octopi", "viri", "radii", "nuclei", "fungi", "cacti", "stimuli"],
  n: ["men"],
  t: ["feet"]
};
var exceptions3 = /* @__PURE__ */ new Set([
  // 'formulas',
  // 'umbrellas',
  // 'gorillas',
  // 'koalas',
  "israelis",
  "menus",
  "logos"
]);
var notPlural = [
  "bus",
  "mas",
  //christmas
  "was",
  // 'las',
  "ias",
  //alias
  "xas",
  "vas",
  "cis",
  //probocis
  "lis",
  "nis",
  //tennis
  "ois",
  "ris",
  "sis",
  //thesis
  "tis",
  //mantis, testis
  "xis",
  "aus",
  "cus",
  "eus",
  //nucleus
  "fus",
  //doofus
  "gus",
  //fungus
  "ius",
  //radius
  "lus",
  //stimulus
  "nus",
  "das",
  "ous",
  "pus",
  //octopus
  "rus",
  //virus
  "sus",
  //census
  "tus",
  //status,cactus
  "xus",
  "aos",
  //chaos
  "igos",
  "ados",
  //barbados
  "ogos",
  "'s",
  "ss"
];
var looksPlural = function(str) {
  if (!str || str.length <= 3) {
    return false;
  }
  if (exceptions3.has(str)) {
    return true;
  }
  let end2 = str[str.length - 1];
  if (isPlural.hasOwnProperty(end2)) {
    return isPlural[end2].find((suff) => str.endsWith(suff));
  }
  if (end2 !== "s") {
    return false;
  }
  if (notPlural.find((suff) => str.endsWith(suff))) {
    return false;
  }
  return true;
};
var looksPlural_default = looksPlural;

// node_modules/compromise/src/2-two/preTagger/methods/index.js
var methods_default9 = {
  two: {
    quickSplit: quickSplit_default,
    expandLexicon: expand_default2,
    transform: transform_default,
    looksPlural: looksPlural_default
  }
};

// node_modules/compromise/src/2-two/preTagger/model/_expand/irregulars.js
var expandIrregulars = function(model5) {
  const { irregularPlurals } = model5.two;
  const { lexicon: lexicon4 } = model5.one;
  Object.entries(irregularPlurals).forEach((a2) => {
    lexicon4[a2[0]] = lexicon4[a2[0]] || "Singular";
    lexicon4[a2[1]] = lexicon4[a2[1]] || "Plural";
  });
  return model5;
};
var irregulars_default = expandIrregulars;

// node_modules/compromise/src/2-two/preTagger/model/_expand/index.js
var tmpModel2 = {
  one: { lexicon: {} },
  two: { models: models_default }
};
var switchDefaults = {
  // 'pilot'
  "Actor|Verb": "Actor",
  //
  // 'amusing'
  "Adj|Gerund": "Adjective",
  //+conjugations
  // 'standard'
  "Adj|Noun": "Adjective",
  // 'boiled'
  "Adj|Past": "Adjective",
  //+conjugations
  // 'smooth'
  "Adj|Present": "Adjective",
  //+conjugations
  // 'box'
  "Noun|Verb": "Singular",
  //+conjugations (no-present)
  //'singing'
  "Noun|Gerund": "Gerund",
  //+conjugations
  // 'hope'
  "Person|Noun": "Noun",
  // 'April'
  "Person|Date": "Month",
  // 'rob'
  "Person|Verb": "FirstName",
  //+conjugations
  // 'victoria'
  "Person|Place": "Person",
  // 'rusty'
  "Person|Adj": "Comparative",
  // 'boxes'
  "Plural|Verb": "Plural",
  //(these are already derivative)
  // 'miles'
  "Unit|Noun": "Noun"
};
var expandLexicon = function(words, model5) {
  const world2 = { model: model5, methods: methods_default9 };
  let { lex, _multi } = methods_default9.two.expandLexicon(words, world2);
  Object.assign(model5.one.lexicon, lex);
  Object.assign(model5.one._multiCache, _multi);
  return model5;
};
var addUncountables = function(words, model5) {
  Object.keys(words).forEach((k2) => {
    if (words[k2] === "Uncountable") {
      model5.two.uncountable[k2] = true;
      words[k2] = "Uncountable";
    }
  });
  return model5;
};
var expandVerb = function(str, words, doPresent) {
  let obj = conjugate_default(str, tmpModel2);
  words[obj.PastTense] = words[obj.PastTense] || "PastTense";
  words[obj.Gerund] = words[obj.Gerund] || "Gerund";
  if (doPresent === true) {
    words[obj.PresentTense] = words[obj.PresentTense] || "PresentTense";
  }
};
var expandAdjective = function(str, words, model5) {
  let sup = toSuperlative2(str, model5);
  words[sup] = words[sup] || "Superlative";
  let comp = toComparative2(str, model5);
  words[comp] = words[comp] || "Comparative";
};
var expandNoun = function(str, words, model5) {
  let plur = toPlural_default(str, model5);
  words[plur] = words[plur] || "Plural";
};
var expandVariable = function(switchWords, model5) {
  let words = {};
  const lex = model5.one.lexicon;
  Object.keys(switchWords).forEach((w) => {
    const name = switchWords[w];
    words[w] = switchDefaults[name];
    if (name === "Noun|Verb" || name === "Person|Verb" || name === "Actor|Verb") {
      expandVerb(w, lex, false);
    }
    if (name === "Adj|Present") {
      expandVerb(w, lex, true);
      expandAdjective(w, lex, model5);
    }
    if (name === "Person|Adj") {
      expandAdjective(w, lex, model5);
    }
    if (name === "Adj|Gerund" || name === "Noun|Gerund") {
      let inf = toInfinitive_default(w, tmpModel2, "Gerund");
      if (!lex[inf]) {
        words[inf] = "Infinitive";
      }
    }
    if (name === "Noun|Gerund" || name === "Adj|Noun" || name === "Person|Noun") {
      expandNoun(w, lex, model5);
    }
    if (name === "Adj|Past") {
      let inf = toInfinitive_default(w, tmpModel2, "PastTense");
      if (!lex[inf]) {
        words[inf] = "Infinitive";
      }
    }
  });
  model5 = expandLexicon(words, model5);
  return model5;
};
var expand4 = function(model5) {
  model5 = expandLexicon(model5.one.lexicon, model5);
  model5 = addUncountables(model5.one.lexicon, model5);
  model5 = expandVariable(model5.two.switches, model5);
  model5 = irregulars_default(model5);
  return model5;
};
var expand_default3 = expand4;

// node_modules/compromise/src/2-two/preTagger/model/index.js
var model4 = {
  one: {
    _multiCache: {},
    lexicon: lexicon3,
    frozenLex: frozenLex_default
  },
  two: {
    irregularPlurals: plurals_default,
    models: models_default,
    suffixPatterns: suffixes_default2,
    prefixPatterns: prefixes_default2,
    endsWith: endsWith_default,
    neighbours: neighbours_default,
    regexNormal: regex_normal_default,
    regexText: regex_text_default,
    regexNumbers: regex_numbers_default,
    switches,
    clues: clues_default,
    uncountable: {},
    orgWords: orgWords_default,
    placeWords: placeWords_default
  }
};
model4 = expand_default3(model4);
var model_default3 = model4;

// node_modules/compromise/src/2-two/preTagger/compute/tagger/1st-pass/01-colons.js
var byPunctuation = function(terms, i3, model5, world2) {
  const setTag2 = world2.methods.one.setTag;
  if (i3 === 0 && terms.length >= 3) {
    const hasColon = /:/;
    let post = terms[0].post;
    if (post.match(hasColon)) {
      let nextTerm = terms[1];
      if (nextTerm.tags.has("Value") || nextTerm.tags.has("Email") || nextTerm.tags.has("PhoneNumber")) {
        return;
      }
      setTag2([terms[0]], "Expression", world2, null, `2-punct-colon''`);
    }
  }
};
var colons_default = byPunctuation;

// node_modules/compromise/src/2-two/preTagger/compute/tagger/1st-pass/02-hyphens.js
var byHyphen = function(terms, i3, model5, world2) {
  const setTag2 = world2.methods.one.setTag;
  if (terms[i3].post === "-" && terms[i3 + 1]) {
    setTag2([terms[i3], terms[i3 + 1]], "Hyphenated", world2, null, `1-punct-hyphen''`);
  }
};
var hyphens_default = byHyphen;

// node_modules/compromise/src/2-two/preTagger/compute/tagger/2nd-pass/00-tagSwitch.js
var prefix3 = /^(under|over|mis|re|un|dis|semi)-?/;
var tagSwitch = function(terms, i3, model5) {
  const switches2 = model5.two.switches;
  let term = terms[i3];
  if (switches2.hasOwnProperty(term.normal)) {
    term.switch = switches2[term.normal];
    return;
  }
  if (prefix3.test(term.normal)) {
    let stem = term.normal.replace(prefix3, "");
    if (stem.length > 3 && switches2.hasOwnProperty(stem)) {
      term.switch = switches2[stem];
    }
  }
};
var tagSwitch_default = tagSwitch;

// node_modules/compromise/src/2-two/preTagger/compute/tagger/_fastTag.js
var log2 = (term, tag2, reason = "") => {
  const yellow = (str) => "\x1B[33m\x1B[3m" + str + "\x1B[0m";
  const i3 = (str) => "\x1B[3m" + str + "\x1B[0m";
  let word = term.text || "[" + term.implicit + "]";
  if (typeof tag2 !== "string" && tag2.length > 2) {
    tag2 = tag2.slice(0, 2).join(", #") + " +";
  }
  tag2 = typeof tag2 !== "string" ? tag2.join(", #") : tag2;
  console.log(` ${yellow(word).padEnd(24)} \x1B[32m\u2192\x1B[0m #${tag2.padEnd(22)}  ${i3(reason)}`);
};
var fastTag = function(term, tag2, reason) {
  if (!tag2 || tag2.length === 0) {
    return;
  }
  if (term.frozen === true) {
    return;
  }
  const env2 = typeof process === "undefined" || !process.env ? self.env || {} : process.env;
  if (env2 && env2.DEBUG_TAGS) {
    log2(term, tag2, reason);
  }
  term.tags = term.tags || /* @__PURE__ */ new Set();
  if (typeof tag2 === "string") {
    term.tags.add(tag2);
  } else {
    tag2.forEach((tg) => term.tags.add(tg));
  }
};
var fastTag_default = fastTag;

// node_modules/compromise/src/2-two/preTagger/compute/tagger/3rd-pass/_fillTags.js
var uncountable = [
  "Acronym",
  "Abbreviation",
  "ProperNoun",
  "Uncountable",
  "Possessive",
  "Pronoun",
  "Activity",
  "Honorific",
  "Month"
];
var setPluralSingular = function(term) {
  if (!term.tags.has("Noun") || term.tags.has("Plural") || term.tags.has("Singular")) {
    return;
  }
  if (uncountable.find((tag2) => term.tags.has(tag2))) {
    return;
  }
  if (looksPlural_default(term.normal)) {
    fastTag_default(term, "Plural", "3-plural-guess");
  } else {
    fastTag_default(term, "Singular", "3-singular-guess");
  }
};
var setTense = function(term) {
  let tags = term.tags;
  if (tags.has("Verb") && tags.size === 1) {
    let guess = getTense_default(term.normal);
    if (guess) {
      fastTag_default(term, guess, "3-verb-tense-guess");
    }
  }
};
var fillTags = function(terms, i3, model5) {
  let term = terms[i3];
  let tags = Array.from(term.tags);
  for (let k2 = 0; k2 < tags.length; k2 += 1) {
    if (model5.one.tagSet[tags[k2]]) {
      let toAdd = model5.one.tagSet[tags[k2]].parents;
      fastTag_default(term, toAdd, ` -inferred by #${tags[k2]}`);
    }
  }
  setPluralSingular(term);
  setTense(term, model5);
};
var fillTags_default = fillTags;

// node_modules/compromise/src/2-two/preTagger/compute/tagger/2nd-pass/01-case.js
var titleCase2 = /^\p{Lu}[\p{Ll}']/u;
var hasNumber = /[0-9]/;
var notProper = ["Date", "Month", "WeekDay", "Unit", "Expression"];
var hasIVX = /[IVX]/;
var romanNumeral = /^[IVXLCDM]{2,}$/;
var romanNumValid = /^M{0,4}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})$/;
var nope = {
  li: true,
  dc: true,
  md: true,
  dm: true,
  ml: true
};
var checkCase = function(terms, i3, model5) {
  let term = terms[i3];
  term.index = term.index || [0, 0];
  let index4 = term.index[1];
  let str = term.text || "";
  if (index4 !== 0 && titleCase2.test(str) === true && hasNumber.test(str) === false) {
    if (notProper.find((tag2) => term.tags.has(tag2))) {
      return null;
    }
    if (term.pre.match(/["']$/)) {
      return null;
    }
    if (term.normal === "the") {
      return null;
    }
    fillTags_default(terms, i3, model5);
    if (!term.tags.has("Noun") && !term.frozen) {
      term.tags.clear();
    }
    fastTag_default(term, "ProperNoun", "2-titlecase");
    return true;
  }
  if (str.length >= 2 && romanNumeral.test(str) && hasIVX.test(str) && romanNumValid.test(str) && !nope[term.normal]) {
    fastTag_default(term, "RomanNumeral", "2-xvii");
    return true;
  }
  return null;
};
var case_default2 = checkCase;

// node_modules/compromise/src/2-two/preTagger/compute/tagger/2nd-pass/02-suffix.js
var suffixLoop2 = function(str = "", suffixes5 = []) {
  const len = str.length;
  let max3 = 7;
  if (len <= max3) {
    max3 = len - 1;
  }
  for (let i3 = max3; i3 > 1; i3 -= 1) {
    let suffix = str.substring(len - i3, len);
    if (suffixes5[suffix.length].hasOwnProperty(suffix) === true) {
      let tag2 = suffixes5[suffix.length][suffix];
      return tag2;
    }
  }
  return null;
};
var tagBySuffix = function(terms, i3, model5) {
  let term = terms[i3];
  if (term.tags.size === 0) {
    let tag2 = suffixLoop2(term.normal, model5.two.suffixPatterns);
    if (tag2 !== null) {
      fastTag_default(term, tag2, "2-suffix");
      term.confidence = 0.7;
      return true;
    }
    if (term.implicit) {
      tag2 = suffixLoop2(term.implicit, model5.two.suffixPatterns);
      if (tag2 !== null) {
        fastTag_default(term, tag2, "2-implicit-suffix");
        term.confidence = 0.7;
        return true;
      }
    }
  }
  return null;
};
var suffix_default = tagBySuffix;

// node_modules/compromise/src/2-two/preTagger/compute/tagger/2nd-pass/03-regex.js
var hasApostrophe = /['`]/;
var doRegs = function(str, regs) {
  for (let i3 = 0; i3 < regs.length; i3 += 1) {
    if (regs[i3][0].test(str) === true) {
      return regs[i3];
    }
  }
  return null;
};
var doEndsWith = function(str = "", byEnd3) {
  let char = str[str.length - 1];
  if (byEnd3.hasOwnProperty(char) === true) {
    let regs = byEnd3[char] || [];
    for (let r2 = 0; r2 < regs.length; r2 += 1) {
      if (regs[r2][0].test(str) === true) {
        return regs[r2];
      }
    }
  }
  return null;
};
var checkRegex = function(terms, i3, model5, world2) {
  const setTag2 = world2.methods.one.setTag;
  let { regexText, regexNormal, regexNumbers, endsWith } = model5.two;
  let term = terms[i3];
  let normal2 = term.machine || term.normal;
  let text2 = term.text;
  if (hasApostrophe.test(term.post) && !hasApostrophe.test(term.pre)) {
    text2 += term.post.trim();
  }
  let arr = doRegs(text2, regexText) || doRegs(normal2, regexNormal);
  if (!arr && /[0-9]/.test(normal2)) {
    arr = doRegs(normal2, regexNumbers);
  }
  if (!arr && term.tags.size === 0) {
    arr = doEndsWith(normal2, endsWith);
  }
  if (arr) {
    setTag2([term], arr[1], world2, null, `2-regex-'${arr[2] || arr[0]}'`);
    term.confidence = 0.6;
    return true;
  }
  return null;
};
var regex_default = checkRegex;

// node_modules/compromise/src/2-two/preTagger/compute/tagger/2nd-pass/04-prefix.js
var prefixLoop = function(str = "", prefixes2 = []) {
  const len = str.length;
  let max3 = 7;
  if (max3 > len - 3) {
    max3 = len - 3;
  }
  for (let i3 = max3; i3 > 2; i3 -= 1) {
    let prefix5 = str.substring(0, i3);
    if (prefixes2[prefix5.length].hasOwnProperty(prefix5) === true) {
      let tag2 = prefixes2[prefix5.length][prefix5];
      return tag2;
    }
  }
  return null;
};
var checkPrefix = function(terms, i3, model5) {
  let term = terms[i3];
  if (term.tags.size === 0) {
    let tag2 = prefixLoop(term.normal, model5.two.prefixPatterns);
    if (tag2 !== null) {
      fastTag_default(term, tag2, "2-prefix");
      term.confidence = 0.5;
      return true;
    }
  }
  return null;
};
var prefix_default = checkPrefix;

// node_modules/compromise/src/2-two/preTagger/compute/tagger/2nd-pass/05-year.js
var min = 1400;
var max2 = 2100;
var dateWords = /* @__PURE__ */ new Set([
  "in",
  "on",
  "by",
  "until",
  "for",
  "to",
  "during",
  "throughout",
  "through",
  "within",
  "before",
  "after",
  "of",
  "this",
  "next",
  "last",
  "circa",
  "around",
  "post",
  "pre",
  "budget",
  "classic",
  "plan",
  "may"
]);
var seemsGood = function(term) {
  if (!term) {
    return false;
  }
  let str = term.normal || term.implicit;
  if (dateWords.has(str)) {
    return true;
  }
  if (term.tags.has("Date") || term.tags.has("Month") || term.tags.has("WeekDay") || term.tags.has("Year")) {
    return true;
  }
  if (term.tags.has("ProperNoun")) {
    return true;
  }
  return false;
};
var seemsOkay = function(term) {
  if (!term) {
    return false;
  }
  if (term.tags.has("Ordinal")) {
    return true;
  }
  if (term.tags.has("Cardinal") && term.normal.length < 3) {
    return true;
  }
  if (term.normal === "is" || term.normal === "was") {
    return true;
  }
  return false;
};
var seemsFine = function(term) {
  return term && (term.tags.has("Date") || term.tags.has("Month") || term.tags.has("WeekDay") || term.tags.has("Year"));
};
var tagYear = function(terms, i3) {
  const term = terms[i3];
  if (term.tags.has("NumericValue") && term.tags.has("Cardinal") && term.normal.length === 4) {
    let num = Number(term.normal);
    if (num && !isNaN(num)) {
      if (num > min && num < max2) {
        let lastTerm = terms[i3 - 1];
        let nextTerm = terms[i3 + 1];
        if (seemsGood(lastTerm) || seemsGood(nextTerm)) {
          return fastTag_default(term, "Year", "2-tagYear");
        }
        if (num >= 1920 && num < 2025) {
          if (seemsOkay(lastTerm) || seemsOkay(nextTerm)) {
            return fastTag_default(term, "Year", "2-tagYear-close");
          }
          if (seemsFine(terms[i3 - 2]) || seemsFine(terms[i3 + 2])) {
            return fastTag_default(term, "Year", "2-tagYear-far");
          }
          if (lastTerm && (lastTerm.tags.has("Determiner") || lastTerm.tags.has("Possessive"))) {
            if (nextTerm && nextTerm.tags.has("Noun") && !nextTerm.tags.has("Plural")) {
              return fastTag_default(term, "Year", "2-tagYear-noun");
            }
          }
        }
      }
    }
  }
  return null;
};
var year_default = tagYear;

// node_modules/compromise/src/2-two/preTagger/compute/tagger/3rd-pass/07-verb-type.js
var verbType = function(terms, i3, model5, world2) {
  const setTag2 = world2.methods.one.setTag;
  const term = terms[i3];
  const types = ["PastTense", "PresentTense", "Auxiliary", "Modal", "Particle"];
  if (term.tags.has("Verb")) {
    let type = types.find((typ) => term.tags.has(typ));
    if (!type) {
      setTag2([term], "Infinitive", world2, null, `2-verb-type''`);
    }
  }
};
var verb_type_default = verbType;

// node_modules/compromise/src/2-two/preTagger/compute/tagger/3rd-pass/01-acronym.js
var oneLetterAcronym2 = /^[A-Z]('s|,)?$/;
var isUpperCase = /^[A-Z-]+$/;
var upperThenS = /^[A-Z]+s$/;
var periodAcronym2 = /([A-Z]\.)+[A-Z]?,?$/;
var noPeriodAcronym2 = /[A-Z]{2,}('s|,)?$/;
var lowerCaseAcronym2 = /([a-z]\.)+[a-z]\.?$/;
var oneLetterWord = {
  I: true,
  A: true
};
var places = {
  la: true,
  ny: true,
  us: true,
  dc: true,
  gb: true
};
var isNoPeriodAcronym = function(term, model5) {
  let str = term.text;
  if (isUpperCase.test(str) === false) {
    if (str.length > 3 && upperThenS.test(str) === true) {
      str = str.replace(/s$/, "");
    } else {
      return false;
    }
  }
  if (str.length > 5) {
    return false;
  }
  if (oneLetterWord.hasOwnProperty(str)) {
    return false;
  }
  if (model5.one.lexicon.hasOwnProperty(term.normal)) {
    return false;
  }
  if (periodAcronym2.test(str) === true) {
    return true;
  }
  if (lowerCaseAcronym2.test(str) === true) {
    return true;
  }
  if (oneLetterAcronym2.test(str) === true) {
    return true;
  }
  if (noPeriodAcronym2.test(str) === true) {
    return true;
  }
  return false;
};
var isAcronym3 = function(terms, i3, model5) {
  let term = terms[i3];
  if (term.tags.has("RomanNumeral") || term.tags.has("Acronym") || term.frozen) {
    return null;
  }
  if (isNoPeriodAcronym(term, model5)) {
    term.tags.clear();
    fastTag_default(term, ["Acronym", "Noun"], "3-no-period-acronym");
    if (places[term.normal] === true) {
      fastTag_default(term, "Place", "3-place-acronym");
    }
    if (upperThenS.test(term.text) === true) {
      fastTag_default(term, "Plural", "3-plural-acronym");
    }
    return true;
  }
  if (!oneLetterWord.hasOwnProperty(term.text) && oneLetterAcronym2.test(term.text)) {
    term.tags.clear();
    fastTag_default(term, ["Acronym", "Noun"], "3-one-letter-acronym");
    return true;
  }
  if (term.tags.has("Organization") && term.text.length <= 3) {
    fastTag_default(term, "Acronym", "3-org-acronym");
    return true;
  }
  if (term.tags.has("Organization") && isUpperCase.test(term.text) && term.text.length <= 6) {
    fastTag_default(term, "Acronym", "3-titlecase-acronym");
    return true;
  }
  return null;
};
var acronym_default = isAcronym3;

// node_modules/compromise/src/2-two/preTagger/compute/tagger/3rd-pass/02-neighbours.js
var lookAtWord = function(term, words) {
  if (!term) {
    return null;
  }
  let found = words.find((a2) => term.normal === a2[0]);
  if (found) {
    return found[1];
  }
  return null;
};
var lookAtTag = function(term, tags) {
  if (!term) {
    return null;
  }
  let found = tags.find((a2) => term.tags.has(a2[0]));
  if (found) {
    return found[1];
  }
  return null;
};
var neighbours = function(terms, i3, model5) {
  const { leftTags, leftWords, rightWords, rightTags } = model5.two.neighbours;
  let term = terms[i3];
  if (term.tags.size === 0) {
    let tag2 = null;
    tag2 = tag2 || lookAtWord(terms[i3 - 1], leftWords);
    tag2 = tag2 || lookAtWord(terms[i3 + 1], rightWords);
    tag2 = tag2 || lookAtTag(terms[i3 - 1], leftTags);
    tag2 = tag2 || lookAtTag(terms[i3 + 1], rightTags);
    if (tag2) {
      fastTag_default(term, tag2, "3-[neighbour]");
      fillTags_default(terms, i3, model5);
      terms[i3].confidence = 0.2;
      return true;
    }
  }
  return null;
};
var neighbours_default2 = neighbours;

// node_modules/compromise/src/2-two/preTagger/compute/tagger/3rd-pass/03-orgWords.js
var isTitleCase3 = (str) => /^\p{Lu}[\p{Ll}']/u.test(str);
var isOrg = function(term, i3, yelling) {
  if (!term) {
    return false;
  }
  if (term.tags.has("FirstName") || term.tags.has("Place")) {
    return false;
  }
  if (term.tags.has("ProperNoun") || term.tags.has("Organization") || term.tags.has("Acronym")) {
    return true;
  }
  if (!yelling && isTitleCase3(term.text)) {
    if (i3 === 0) {
      return term.tags.has("Singular");
    }
    return true;
  }
  return false;
};
var tagOrgs = function(terms, i3, world2, yelling) {
  const orgWords = world2.model.two.orgWords;
  const setTag2 = world2.methods.one.setTag;
  let term = terms[i3];
  let str = term.machine || term.normal;
  if (orgWords[str] === true && isOrg(terms[i3 - 1], i3 - 1, yelling)) {
    setTag2([terms[i3]], "Organization", world2, null, "3-[org-word]");
    for (let t3 = i3; t3 >= 0; t3 -= 1) {
      if (isOrg(terms[t3], t3, yelling)) {
        setTag2([terms[t3]], "Organization", world2, null, "3-[org-word]");
      } else {
        break;
      }
    }
  }
  return null;
};
var orgWords_default2 = tagOrgs;

// node_modules/compromise/src/2-two/preTagger/compute/tagger/3rd-pass/04-placeWords.js
var isTitleCase4 = (str) => /^\p{Lu}[\p{Ll}']/u.test(str);
var isPossessive = /'s$/;
var placeCont = /* @__PURE__ */ new Set([
  "athletic",
  "city",
  "community",
  "eastern",
  "federal",
  "financial",
  "great",
  "historic",
  "historical",
  "local",
  "memorial",
  "municipal",
  "national",
  "northern",
  "provincial",
  "southern",
  "state",
  "western",
  "spring",
  "pine",
  "sunset",
  "view",
  "oak",
  "maple",
  "spruce",
  "cedar",
  "willow"
]);
var noBefore = /* @__PURE__ */ new Set(["center", "centre", "way", "range", "bar", "bridge", "field", "pit"]);
var isPlace = function(term, i3, yelling) {
  if (!term) {
    return false;
  }
  let tags = term.tags;
  if (tags.has("Organization") || tags.has("Possessive") || isPossessive.test(term.normal)) {
    return false;
  }
  if (tags.has("ProperNoun") || tags.has("Place")) {
    return true;
  }
  if (!yelling && isTitleCase4(term.text)) {
    if (i3 === 0) {
      return tags.has("Singular");
    }
    return true;
  }
  return false;
};
var tagOrgs2 = function(terms, i3, world2, yelling) {
  const placeWords = world2.model.two.placeWords;
  const setTag2 = world2.methods.one.setTag;
  let term = terms[i3];
  let str = term.machine || term.normal;
  if (placeWords[str] === true) {
    for (let n3 = i3 - 1; n3 >= 0; n3 -= 1) {
      if (placeCont.has(terms[n3].normal)) {
        continue;
      }
      if (isPlace(terms[n3], n3, yelling)) {
        setTag2(terms.slice(n3, i3 + 1), "Place", world2, null, "3-[place-of-foo]");
        continue;
      }
      break;
    }
    if (noBefore.has(str)) {
      return false;
    }
    for (let n3 = i3 + 1; n3 < terms.length; n3 += 1) {
      if (isPlace(terms[n3], n3, yelling)) {
        setTag2(terms.slice(i3, n3 + 1), "Place", world2, null, "3-[foo-place]");
        return true;
      }
      if (terms[n3].normal === "of" || placeCont.has(terms[n3].normal)) {
        continue;
      }
      break;
    }
  }
  return null;
};
var placeWords_default2 = tagOrgs2;

// node_modules/compromise/src/2-two/preTagger/compute/tagger/3rd-pass/05-fallback.js
var nounFallback = function(terms, i3, model5) {
  let isEmpty = false;
  let tags = terms[i3].tags;
  if (tags.size === 0) {
    isEmpty = true;
  } else if (tags.size === 1) {
    if (tags.has("Hyphenated") || tags.has("HashTag") || tags.has("Prefix") || tags.has("SlashedTerm")) {
      isEmpty = true;
    }
  }
  if (isEmpty) {
    fastTag_default(terms[i3], "Noun", "3-[fallback]");
    fillTags_default(terms, i3, model5);
    terms[i3].confidence = 0.1;
  }
};
var fallback_default = nounFallback;

// node_modules/compromise/src/2-two/preTagger/compute/tagger/3rd-pass/_adhoc.js
var isTitleCase5 = /^[A-Z][a-z]/;
var isCapital = (terms, i3) => {
  if (terms[i3].tags.has("ProperNoun") && isTitleCase5.test(terms[i3].text)) {
    return "Noun";
  }
  return null;
};
var isAlone = (terms, i3, tag2) => {
  if (i3 === 0 && !terms[1]) {
    return tag2;
  }
  return null;
};
var isEndNoun = function(terms, i3) {
  if (!terms[i3 + 1] && terms[i3 - 1] && terms[i3 - 1].tags.has("Determiner")) {
    return "Noun";
  }
  return null;
};
var isStart = function(terms, i3, tag2) {
  if (i3 === 0 && terms.length > 3) {
    return tag2;
  }
  return null;
};
var adhoc = {
  "Adj|Gerund": (terms, i3) => {
    return isCapital(terms, i3);
  },
  "Adj|Noun": (terms, i3) => {
    return isCapital(terms, i3) || isEndNoun(terms, i3);
  },
  "Actor|Verb": (terms, i3) => {
    return isCapital(terms, i3);
  },
  "Adj|Past": (terms, i3) => {
    return isCapital(terms, i3);
  },
  "Adj|Present": (terms, i3) => {
    return isCapital(terms, i3);
  },
  "Noun|Gerund": (terms, i3) => {
    return isCapital(terms, i3);
  },
  "Noun|Verb": (terms, i3) => {
    return i3 > 0 && isCapital(terms, i3) || isAlone(terms, i3, "Infinitive");
  },
  "Plural|Verb": (terms, i3) => {
    return isCapital(terms, i3) || isAlone(terms, i3, "PresentTense") || isStart(terms, i3, "Plural");
  },
  "Person|Noun": (terms, i3) => {
    return isCapital(terms, i3);
  },
  "Person|Verb": (terms, i3) => {
    if (i3 !== 0) {
      return isCapital(terms, i3);
    }
    return null;
  },
  "Person|Adj": (terms, i3) => {
    if (i3 === 0 && terms.length > 1) {
      return "Person";
    }
    return isCapital(terms, i3) ? "Person" : null;
  }
};
var adhoc_default = adhoc;

// node_modules/compromise/src/2-two/preTagger/compute/tagger/3rd-pass/06-switches.js
var env = typeof process === "undefined" || !process.env ? self.env || {} : process.env;
var prefix4 = /^(under|over|mis|re|un|dis|semi)-?/;
var checkWord = (term, obj) => {
  if (!term || !obj) {
    return null;
  }
  let str = term.normal || term.implicit;
  let found = null;
  if (obj.hasOwnProperty(str)) {
    found = obj[str];
  }
  if (found && env.DEBUG_TAGS) {
    console.log(`
  \x1B[2m\x1B[3m     \u2193 - '${str}' \x1B[0m`);
  }
  return found;
};
var checkTag = (term, obj = {}, tagSet) => {
  if (!term || !obj) {
    return null;
  }
  let tags = Array.from(term.tags).sort((a2, b) => {
    let numA = tagSet[a2] ? tagSet[a2].parents.length : 0;
    let numB = tagSet[b] ? tagSet[b].parents.length : 0;
    return numA > numB ? -1 : 1;
  });
  let found = tags.find((tag2) => obj[tag2]);
  if (found && env.DEBUG_TAGS) {
    console.log(`  \x1B[2m\x1B[3m      \u2193 - '${term.normal || term.implicit}' (#${found})  \x1B[0m`);
  }
  found = obj[found];
  return found;
};
var pickTag = function(terms, i3, clues5, model5) {
  var _a3;
  if (!clues5) {
    return null;
  }
  const beforeIndex = ((_a3 = terms[i3 - 1]) == null ? void 0 : _a3.text) !== "also" ? i3 - 1 : Math.max(0, i3 - 2);
  const tagSet = model5.one.tagSet;
  let tag2 = checkWord(terms[i3 + 1], clues5.afterWords);
  tag2 = tag2 || checkWord(terms[beforeIndex], clues5.beforeWords);
  tag2 = tag2 || checkTag(terms[beforeIndex], clues5.beforeTags, tagSet);
  tag2 = tag2 || checkTag(terms[i3 + 1], clues5.afterTags, tagSet);
  return tag2;
};
var doSwitches = function(terms, i3, world2) {
  const model5 = world2.model;
  const setTag2 = world2.methods.one.setTag;
  const { switches: switches2, clues: clues5 } = model5.two;
  const term = terms[i3];
  let str = term.normal || term.implicit || "";
  if (prefix4.test(str) && !switches2[str]) {
    str = str.replace(prefix4, "");
  }
  if (term.switch) {
    let form = term.switch;
    if (term.tags.has("Acronym") || term.tags.has("PhrasalVerb")) {
      return;
    }
    let tag2 = pickTag(terms, i3, clues5[form], model5);
    if (adhoc_default[form]) {
      tag2 = adhoc_default[form](terms, i3) || tag2;
    }
    if (tag2) {
      setTag2([term], tag2, world2, null, `3-[switch] (${form})`);
      fillTags_default(terms, i3, model5);
    } else if (env.DEBUG_TAGS) {
      console.log(`
 -> X  - '${str}'  : (${form})  `);
    }
  }
};
var switches_default = doSwitches;

// node_modules/compromise/src/2-two/preTagger/compute/tagger/3rd-pass/08-imperative.js
var beside = {
  there: true,
  //go there
  this: true,
  //try this
  it: true,
  //do it
  him: true,
  her: true,
  us: true
  //tell us
};
var imperative = function(terms, world2) {
  const setTag2 = world2.methods.one.setTag;
  const multiWords = world2.model.one._multiCache || {};
  let t3 = terms[0];
  let isRight = t3.switch === "Noun|Verb" || t3.tags.has("Infinitive");
  if (isRight && terms.length >= 2) {
    if (terms.length < 4 && !beside[terms[1].normal]) {
      return;
    }
    if (!t3.tags.has("PhrasalVerb") && multiWords.hasOwnProperty(t3.normal)) {
      return;
    }
    let nextNoun = terms[1].tags.has("Noun") || terms[1].tags.has("Determiner");
    if (nextNoun) {
      let soonVerb = terms.slice(1, 3).some((term) => term.tags.has("Verb"));
      if (!soonVerb || t3.tags.has("#PhrasalVerb")) {
        setTag2([t3], "Imperative", world2, null, "3-[imperative]");
      }
    }
  }
};
var imperative_default = imperative;

// node_modules/compromise/src/2-two/preTagger/compute/tagger/index.js
var ignoreCase = function(terms) {
  if (terms.filter((t3) => !t3.tags.has("ProperNoun")).length <= 3) {
    return false;
  }
  const lowerCase = /^[a-z]/;
  return terms.every((t3) => !lowerCase.test(t3.text));
};
var firstPass = function(docs, model5, world2) {
  docs.forEach((terms) => {
    colons_default(terms, 0, model5, world2);
  });
};
var secondPass = function(terms, model5, world2, isYelling) {
  for (let i3 = 0; i3 < terms.length; i3 += 1) {
    if (terms[i3].frozen === true) {
      continue;
    }
    tagSwitch_default(terms, i3, model5);
    if (isYelling === false) {
      case_default2(terms, i3, model5);
    }
    suffix_default(terms, i3, model5);
    regex_default(terms, i3, model5, world2);
    prefix_default(terms, i3, model5);
    year_default(terms, i3, model5);
  }
};
var thirdPass = function(terms, model5, world2, isYelling) {
  for (let i3 = 0; i3 < terms.length; i3 += 1) {
    let found = acronym_default(terms, i3, model5);
    fillTags_default(terms, i3, model5);
    found = found || neighbours_default2(terms, i3, model5);
    found = found || fallback_default(terms, i3, model5);
  }
  for (let i3 = 0; i3 < terms.length; i3 += 1) {
    if (terms[i3].frozen === true) {
      continue;
    }
    orgWords_default2(terms, i3, world2, isYelling);
    placeWords_default2(terms, i3, world2, isYelling);
    switches_default(terms, i3, world2);
    verb_type_default(terms, i3, model5, world2);
    hyphens_default(terms, i3, model5, world2);
  }
  imperative_default(terms, world2);
};
var preTagger = function(view) {
  const { methods: methods17, model: model5, world: world2 } = view;
  let docs = view.docs;
  firstPass(docs, model5, world2);
  let document2 = methods17.two.quickSplit(docs);
  for (let n3 = 0; n3 < document2.length; n3 += 1) {
    let terms = document2[n3];
    const isYelling = ignoreCase(terms);
    secondPass(terms, model5, world2, isYelling);
    thirdPass(terms, model5, world2, isYelling);
  }
  return document2;
};
var tagger_default2 = preTagger;

// node_modules/compromise/src/2-two/preTagger/compute/root.js
var toRoot = {
  // 'spencer's' -> 'spencer'
  "Possessive": (term) => {
    let str = term.machine || term.normal || term.text;
    str = str.replace(/'s$/, "");
    return str;
  },
  // 'drinks' -> 'drink'
  "Plural": (term, world2) => {
    let str = term.machine || term.normal || term.text;
    return world2.methods.two.transform.noun.toSingular(str, world2.model);
  },
  // ''
  "Copula": () => {
    return "is";
  },
  // 'walked' -> 'walk'
  "PastTense": (term, world2) => {
    let str = term.machine || term.normal || term.text;
    return world2.methods.two.transform.verb.toInfinitive(str, world2.model, "PastTense");
  },
  // 'walking' -> 'walk'
  "Gerund": (term, world2) => {
    let str = term.machine || term.normal || term.text;
    return world2.methods.two.transform.verb.toInfinitive(str, world2.model, "Gerund");
  },
  // 'walks' -> 'walk'
  "PresentTense": (term, world2) => {
    let str = term.machine || term.normal || term.text;
    if (term.tags.has("Infinitive")) {
      return str;
    }
    return world2.methods.two.transform.verb.toInfinitive(str, world2.model, "PresentTense");
  },
  // 'quieter' -> 'quiet'
  "Comparative": (term, world2) => {
    let str = term.machine || term.normal || term.text;
    return world2.methods.two.transform.adjective.fromComparative(str, world2.model);
  },
  // 'quietest' -> 'quiet'
  "Superlative": (term, world2) => {
    let str = term.machine || term.normal || term.text;
    return world2.methods.two.transform.adjective.fromSuperlative(str, world2.model);
  },
  // 'suddenly' -> 'sudden'
  "Adverb": (term, world2) => {
    const { fromAdverb } = world2.methods.two.transform.adjective;
    let str = term.machine || term.normal || term.text;
    return fromAdverb(str);
  }
};
var getRoot = function(view) {
  const world2 = view.world;
  const keys = Object.keys(toRoot);
  view.docs.forEach((terms) => {
    for (let i3 = 0; i3 < terms.length; i3 += 1) {
      const term = terms[i3];
      for (let k2 = 0; k2 < keys.length; k2 += 1) {
        if (term.tags.has(keys[k2])) {
          const fn = toRoot[keys[k2]];
          let root6 = fn(term, world2);
          if (term.normal !== root6) {
            term.root = root6;
          }
          break;
        }
      }
    }
  });
};
var root_default = getRoot;

// node_modules/compromise/src/2-two/preTagger/compute/penn.js
var mapping = {
  // adverbs
  // 'Comparative': 'RBR',
  // 'Superlative': 'RBS',
  Adverb: "RB",
  // adjectives
  Comparative: "JJR",
  Superlative: "JJS",
  Adjective: "JJ",
  TO: "Conjunction",
  // verbs
  Modal: "MD",
  Auxiliary: "MD",
  Gerund: "VBG",
  //throwing
  PastTense: "VBD",
  //threw
  Participle: "VBN",
  //thrown
  PresentTense: "VBZ",
  //throws
  Infinitive: "VB",
  //throw
  Particle: "RP",
  //phrasal particle
  Verb: "VB",
  // throw
  // pronouns
  Pronoun: "PRP",
  // misc
  Cardinal: "CD",
  Conjunction: "CC",
  Determiner: "DT",
  Preposition: "IN",
  // 'Determiner': 'WDT',
  // 'Expression': 'FW',
  QuestionWord: "WP",
  Expression: "UH",
  //nouns
  Possessive: "POS",
  ProperNoun: "NNP",
  Person: "NNP",
  Place: "NNP",
  Organization: "NNP",
  Singular: "NN",
  Plural: "NNS",
  Noun: "NN",
  There: "EX"
  //'there'
  // 'Adverb':'WRB',
  // 'Noun':'PDT', //predeterminer
  // 'Noun':'SYM', //symbol
  // 'Noun':'NFP', //
  //  WDT 	Wh-determiner
  // 	WP 	Wh-pronoun
  // 	WP$ 	Possessive wh-pronoun
  // 	WRB 	Wh-adverb
};
var toPenn = function(term) {
  if (term.tags.has("ProperNoun") && term.tags.has("Plural")) {
    return "NNPS";
  }
  if (term.tags.has("Possessive") && term.tags.has("Pronoun")) {
    return "PRP$";
  }
  if (term.normal === "there") {
    return "EX";
  }
  if (term.normal === "to") {
    return "TO";
  }
  let arr = term.tagRank || [];
  for (let i3 = 0; i3 < arr.length; i3 += 1) {
    if (mapping.hasOwnProperty(arr[i3])) {
      return mapping[arr[i3]];
    }
  }
  return null;
};
var pennTag = function(view) {
  view.compute("tagRank");
  view.docs.forEach((terms) => {
    terms.forEach((term) => {
      term.penn = toPenn(term);
    });
  });
};
var penn_default = pennTag;

// node_modules/compromise/src/2-two/preTagger/compute/index.js
var compute_default9 = { preTagger: tagger_default2, root: root_default, penn: penn_default };

// node_modules/compromise/src/2-two/preTagger/tagSet/nouns.js
var entity = ["Person", "Place", "Organization"];
var nouns_default3 = {
  Noun: {
    not: ["Verb", "Adjective", "Adverb", "Value", "Determiner"]
  },
  Singular: {
    is: "Noun",
    not: ["Plural", "Uncountable"]
  },
  // 'Canada'
  ProperNoun: {
    is: "Noun"
  },
  Person: {
    is: "Singular",
    also: ["ProperNoun"],
    not: ["Place", "Organization", "Date"]
  },
  FirstName: {
    is: "Person"
  },
  MaleName: {
    is: "FirstName",
    not: ["FemaleName", "LastName"]
  },
  FemaleName: {
    is: "FirstName",
    not: ["MaleName", "LastName"]
  },
  LastName: {
    is: "Person",
    not: ["FirstName"]
  },
  // 'dr.'
  Honorific: {
    is: "Person",
    not: ["FirstName", "LastName", "Value"]
  },
  Place: {
    is: "Singular",
    not: ["Person", "Organization"]
  },
  Country: {
    is: "Place",
    also: ["ProperNoun"],
    not: ["City"]
  },
  City: {
    is: "Place",
    also: ["ProperNoun"],
    not: ["Country"]
  },
  // 'california'
  Region: {
    is: "Place",
    also: ["ProperNoun"]
  },
  Address: {
    // is: 'Place',
  },
  Organization: {
    is: "ProperNoun",
    not: ["Person", "Place"]
  },
  SportsTeam: {
    is: "Organization"
  },
  School: {
    is: "Organization"
  },
  Company: {
    is: "Organization"
  },
  Plural: {
    is: "Noun",
    not: ["Singular", "Uncountable"]
  },
  // 'gravity'
  Uncountable: {
    is: "Noun"
  },
  // 'it'
  Pronoun: {
    is: "Noun",
    not: entity
  },
  // 'swimmer'
  Actor: {
    is: "Noun",
    not: ["Place", "Organization"]
  },
  // walking
  Activity: {
    is: "Noun",
    not: ["Person", "Place"]
  },
  // kilometres
  Unit: {
    is: "Noun",
    not: entity
  },
  // canadian
  Demonym: {
    is: "Noun",
    also: ["ProperNoun"],
    not: entity
  },
  // [spencer's] hat
  Possessive: {
    is: "Noun"
  },
  // 'yourself'
  Reflexive: {
    is: "Pronoun"
  }
};

// node_modules/compromise/src/2-two/preTagger/tagSet/verbs.js
var verbs_default2 = {
  Verb: {
    not: ["Noun", "Adjective", "Adverb", "Value", "Expression"]
  },
  // 'he [walks]'
  PresentTense: {
    is: "Verb",
    not: ["PastTense", "FutureTense"]
  },
  // 'will [walk]'
  Infinitive: {
    is: "PresentTense",
    not: ["Gerund"]
  },
  // '[walk] now!'
  Imperative: {
    is: "Verb",
    not: ["PastTense", "Gerund", "Copula"]
  },
  // walking
  Gerund: {
    is: "PresentTense",
    not: ["Copula"]
  },
  // walked
  PastTense: {
    is: "Verb",
    not: ["PresentTense", "Gerund", "FutureTense"]
  },
  // will walk
  FutureTense: {
    is: "Verb",
    not: ["PresentTense", "PastTense"]
  },
  // is/was
  Copula: {
    is: "Verb"
  },
  // '[could] walk'
  Modal: {
    is: "Verb",
    not: ["Infinitive"]
  },
  // 'awaken'
  Participle: {
    is: "PastTense"
  },
  // '[will have had] walked'
  Auxiliary: {
    is: "Verb",
    not: ["PastTense", "PresentTense", "Gerund", "Conjunction"]
  },
  // 'walk out'
  PhrasalVerb: {
    is: "Verb"
  },
  // 'walk [out]'
  Particle: {
    is: "PhrasalVerb",
    not: ["PastTense", "PresentTense", "Copula", "Gerund"]
  },
  // 'walked by'
  Passive: {
    is: "Verb"
  }
};

// node_modules/compromise/src/2-two/preTagger/tagSet/values.js
var values_default = {
  Value: {
    not: ["Verb", "Adjective", "Adverb"]
  },
  Ordinal: {
    is: "Value",
    not: ["Cardinal"]
  },
  Cardinal: {
    is: "Value",
    not: ["Ordinal"]
  },
  Fraction: {
    is: "Value",
    not: ["Noun"]
  },
  Multiple: {
    is: "TextValue"
  },
  RomanNumeral: {
    is: "Cardinal",
    not: ["TextValue"]
  },
  TextValue: {
    is: "Value",
    not: ["NumericValue"]
  },
  NumericValue: {
    is: "Value",
    not: ["TextValue"]
  },
  Money: {
    is: "Cardinal"
  },
  Percent: {
    is: "Value"
  }
};

// node_modules/compromise/src/2-two/preTagger/tagSet/dates.js
var dates_default = {
  Date: {
    not: ["Verb", "Adverb", "Adjective"]
  },
  Month: {
    is: "Date",
    also: ["Noun"],
    not: ["Year", "WeekDay", "Time"]
  },
  WeekDay: {
    is: "Date",
    also: ["Noun"]
  },
  Year: {
    is: "Date",
    not: ["RomanNumeral"]
  },
  FinancialQuarter: {
    is: "Date",
    not: "Fraction"
  },
  // 'easter'
  Holiday: {
    is: "Date",
    also: ["Noun"]
  },
  // 'summer'
  Season: {
    is: "Date"
  },
  Timezone: {
    is: "Date",
    also: ["Noun"],
    not: ["ProperNoun"]
  },
  Time: {
    is: "Date",
    not: ["AtMention"]
  },
  // 'months'
  Duration: {
    is: "Date",
    also: ["Noun"]
  }
};

// node_modules/compromise/src/2-two/preTagger/tagSet/misc.js
var anything = ["Noun", "Verb", "Adjective", "Adverb", "Value", "QuestionWord"];
var misc_default3 = {
  Adjective: {
    not: ["Noun", "Verb", "Adverb", "Value"]
  },
  Comparable: {
    is: "Adjective"
  },
  Comparative: {
    is: "Adjective"
  },
  Superlative: {
    is: "Adjective",
    not: ["Comparative"]
  },
  NumberRange: {},
  Adverb: {
    not: ["Noun", "Verb", "Adjective", "Value"]
  },
  Determiner: {
    not: ["Noun", "Verb", "Adjective", "Adverb", "QuestionWord", "Conjunction"]
    //allow 'a' to be a Determiner/Value
  },
  Conjunction: {
    not: anything
  },
  Preposition: {
    not: ["Noun", "Verb", "Adjective", "Adverb", "QuestionWord", "Determiner"]
  },
  QuestionWord: {
    not: ["Determiner"]
  },
  Currency: {
    is: "Noun"
  },
  Expression: {
    not: ["Noun", "Adjective", "Verb", "Adverb"]
  },
  Abbreviation: {},
  Url: {
    not: ["HashTag", "PhoneNumber", "Verb", "Adjective", "Value", "AtMention", "Email", "SlashedTerm"]
  },
  PhoneNumber: {
    not: ["HashTag", "Verb", "Adjective", "Value", "AtMention", "Email"]
  },
  HashTag: {},
  AtMention: {
    is: "Noun",
    not: ["HashTag", "Email"]
  },
  Emoji: {
    not: ["HashTag", "Verb", "Adjective", "Value", "AtMention"]
  },
  Emoticon: {
    not: ["HashTag", "Verb", "Adjective", "Value", "AtMention", "SlashedTerm"]
  },
  SlashedTerm: {
    not: ["Emoticon", "Url", "Value"]
  },
  Email: {
    not: ["HashTag", "Verb", "Adjective", "Value", "AtMention"]
  },
  Acronym: {
    not: ["Plural", "RomanNumeral", "Pronoun", "Date"]
  },
  Negative: {
    not: ["Noun", "Adjective", "Value", "Expression"]
  },
  Condition: {
    not: ["Verb", "Adjective", "Noun", "Value"]
  },
  // existential 'there'
  There: {
    not: ["Verb", "Adjective", "Noun", "Value", "Conjunction", "Preposition"]
  },
  // 'co-wrote'
  Prefix: {
    not: ["Abbreviation", "Acronym", "ProperNoun"]
  },
  // hard-nosed, bone-headed
  Hyphenated: {}
};

// node_modules/compromise/src/2-two/preTagger/tagSet/index.js
var allTags = Object.assign({}, nouns_default3, verbs_default2, values_default, dates_default, misc_default3);
var tagSet_default = allTags;

// node_modules/compromise/src/2-two/preTagger/plugin.js
var plugin_default14 = {
  compute: compute_default9,
  methods: methods_default9,
  model: model_default3,
  tags: tagSet_default,
  hooks: ["preTagger"]
};

// node_modules/compromise/src/2-two/contraction-two/api/contract.js
var postPunct = /[,)"';:\-.]/;
var setContraction = function(m3, suffix) {
  if (!m3.found) {
    return;
  }
  let terms = m3.termList();
  for (let i3 = 0; i3 < terms.length - 1; i3++) {
    const t3 = terms[i3];
    if (postPunct.test(t3.post)) {
      return;
    }
  }
  terms[0].implicit = terms[0].normal;
  terms[0].text += suffix;
  terms[0].normal += suffix;
  terms.slice(1).forEach((t3) => {
    t3.implicit = t3.normal;
    t3.text = "";
    t3.normal = "";
  });
  for (let i3 = 0; i3 < terms.length - 1; i3++) {
    terms[i3].post = terms[i3].post.replace(/ /, "");
  }
};
var contract = function() {
  let doc = this.not("@hasContraction");
  let m3 = doc.match("(we|they|you) are");
  setContraction(m3, `'re`);
  m3 = doc.match("(he|she|they|it|we|you) will");
  setContraction(m3, `'ll`);
  m3 = doc.match("(he|she|they|it|we) is");
  setContraction(m3, `'s`);
  m3 = doc.match("#Person is");
  setContraction(m3, `'s`);
  m3 = doc.match("#Person would");
  setContraction(m3, `'d`);
  m3 = doc.match("(is|was|had|would|should|could|do|does|have|has|can) not");
  setContraction(m3, `n't`);
  m3 = doc.match("(i|we|they) have");
  setContraction(m3, `'ve`);
  m3 = doc.match("(would|should|could) have");
  setContraction(m3, `'ve`);
  m3 = doc.match("i am");
  setContraction(m3, `'m`);
  m3 = doc.match("going to");
  return this;
};
var contract_default = contract;

// node_modules/compromise/src/2-two/contraction-two/api/index.js
var titleCase3 = /^\p{Lu}[\p{Ll}']/u;
var toTitleCase3 = function(str = "") {
  str = str.replace(/^ *[a-z\u00C0-\u00FF]/, (x) => x.toUpperCase());
  return str;
};
var api3 = function(View2) {
  class Contractions extends View2 {
    constructor(document2, pointer, groups) {
      super(document2, pointer, groups);
      this.viewType = "Contraction";
    }
    /** i've -> 'i have' */
    expand() {
      this.docs.forEach((terms) => {
        let isTitleCase6 = titleCase3.test(terms[0].text);
        terms.forEach((t3, i3) => {
          t3.text = t3.implicit || "";
          delete t3.implicit;
          if (i3 < terms.length - 1 && t3.post === "") {
            t3.post += " ";
          }
          t3.dirty = true;
        });
        if (isTitleCase6) {
          terms[0].text = toTitleCase3(terms[0].text);
        }
      });
      this.compute("normal");
      return this;
    }
  }
  View2.prototype.contractions = function() {
    let m3 = this.match("@hasContraction+");
    return new Contractions(this.document, m3.pointer);
  };
  View2.prototype.contract = contract_default;
};
var api_default10 = api3;

// node_modules/compromise/src/2-two/contraction-two/compute/_splice.js
var insertContraction2 = function(document2, point, words) {
  let [n3, w] = point;
  if (!words || words.length === 0) {
    return;
  }
  words = words.map((word, i3) => {
    word.implicit = word.text;
    word.machine = word.text;
    word.pre = "";
    word.post = "";
    word.text = "";
    word.normal = "";
    word.index = [n3, w + i3];
    return word;
  });
  if (words[0]) {
    words[0].pre = document2[n3][w].pre;
    words[words.length - 1].post = document2[n3][w].post;
    words[0].text = document2[n3][w].text;
    words[0].normal = document2[n3][w].normal;
  }
  document2[n3].splice(w, 1, ...words);
};
var splice_default2 = insertContraction2;

// node_modules/compromise/src/2-two/contraction-two/compute/apostrophe-s.js
var hasContraction3 = /'/;
var hasWords = /* @__PURE__ */ new Set([
  "been",
  //the meeting's been ..
  "become"
  //my son's become
]);
var isWords = /* @__PURE__ */ new Set([
  "what",
  //it's what
  "how",
  //it's how
  "when",
  "if",
  //it's if
  "too"
]);
var adjLike = /* @__PURE__ */ new Set(["too", "also", "enough"]);
var isOrHas = (terms, i3) => {
  for (let o2 = i3 + 1; o2 < terms.length; o2 += 1) {
    let t3 = terms[o2];
    if (hasWords.has(t3.normal)) {
      return "has";
    }
    if (isWords.has(t3.normal)) {
      return "is";
    }
    if (t3.tags.has("Gerund")) {
      return "is";
    }
    if (t3.tags.has("Determiner")) {
      return "is";
    }
    if (t3.tags.has("Adjective")) {
      return "is";
    }
    if (t3.switch === "Adj|Past") {
      if (terms[o2 + 1]) {
        if (adjLike.has(terms[o2 + 1].normal)) {
          return "is";
        }
        if (terms[o2 + 1].tags.has("Preposition")) {
          return "is";
        }
      }
    }
    if (t3.tags.has("PastTense")) {
      if (terms[o2 + 1] && terms[o2 + 1].normal === "for") {
        return "is";
      }
      return "has";
    }
  }
  return "is";
};
var apostropheS = function(terms, i3) {
  let before2 = terms[i3].normal.split(hasContraction3)[0];
  if (before2 === "let") {
    return [before2, "us"];
  }
  if (before2 === "there") {
    let t3 = terms[i3 + 1];
    if (t3 && t3.tags.has("Plural")) {
      return [before2, "are"];
    }
  }
  if (isOrHas(terms, i3) === "has") {
    return [before2, "has"];
  }
  return [before2, "is"];
};
var apostrophe_s_default = apostropheS;

// node_modules/compromise/src/2-two/contraction-two/compute/apostrophe-d.js
var hasContraction4 = /'/;
var hadWords = /* @__PURE__ */ new Set([
  "better",
  //had better
  "done",
  //had done
  "before",
  // he'd _ before
  "it",
  // he'd _ it
  "had"
  //she'd had -> she would have..
]);
var wouldWords = /* @__PURE__ */ new Set([
  "have",
  // 'i'd have' -> i would have..
  "be"
  //' she'd be'
]);
var hadOrWould = (terms, i3) => {
  for (let o2 = i3 + 1; o2 < terms.length; o2 += 1) {
    let t3 = terms[o2];
    if (hadWords.has(t3.normal)) {
      return "had";
    }
    if (wouldWords.has(t3.normal)) {
      return "would";
    }
    if (t3.tags.has("PastTense") || t3.switch === "Adj|Past") {
      return "had";
    }
    if (t3.tags.has("PresentTense") || t3.tags.has("Infinitive")) {
      return "would";
    }
    if (t3.tags.has("#Determiner")) {
      return "had";
    }
    if (t3.tags.has("Adjective")) {
      return "would";
    }
  }
  return false;
};
var _apostropheD2 = function(terms, i3) {
  let before2 = terms[i3].normal.split(hasContraction4)[0];
  if (before2 === "how" || before2 === "what") {
    return [before2, "did"];
  }
  if (hadOrWould(terms, i3) === "had") {
    return [before2, "had"];
  }
  return [before2, "would"];
};
var apostrophe_d_default2 = _apostropheD2;

// node_modules/compromise/src/2-two/contraction-two/compute/apostrophe-t.js
var lastNoun = function(terms, i3) {
  for (let n3 = i3 - 1; n3 >= 0; n3 -= 1) {
    if (terms[n3].tags.has("Noun") || terms[n3].tags.has("Pronoun") || terms[n3].tags.has("Plural") || terms[n3].tags.has("Singular")) {
      return terms[n3];
    }
  }
  return null;
};
var apostropheT2 = function(terms, i3) {
  if (terms[i3].normal === "ain't" || terms[i3].normal === "aint") {
    if (terms[i3 + 1] && terms[i3 + 1].normal === "never") {
      return ["have"];
    }
    let noun = lastNoun(terms, i3);
    if (noun) {
      if (noun.normal === "we" || noun.normal === "they") {
        return ["are", "not"];
      }
      if (noun.normal === "i") {
        return ["am", "not"];
      }
      if (noun.tags && noun.tags.has("Plural")) {
        return ["are", "not"];
      }
    }
    return ["is", "not"];
  }
  let before2 = terms[i3].normal.replace(/n't/, "");
  return [before2, "not"];
};
var apostrophe_t_default2 = apostropheT2;

// node_modules/compromise/src/2-two/contraction-two/compute/isPossessive.js
var banList = {
  that: true,
  there: true,
  let: true,
  here: true,
  everywhere: true
};
var beforePossessive = {
  in: true,
  //in sunday's
  by: true,
  //by sunday's
  for: true
  //for sunday's
};
var adjLike2 = /* @__PURE__ */ new Set(["too", "also", "enough", "about"]);
var nounLike = /* @__PURE__ */ new Set(["is", "are", "did", "were", "could", "should", "must", "had", "have"]);
var isPossessive2 = (terms, i3) => {
  let term = terms[i3];
  if (banList.hasOwnProperty(term.machine || term.normal)) {
    return false;
  }
  if (term.tags.has("Possessive")) {
    return true;
  }
  if (term.tags.has("QuestionWord")) {
    return false;
  }
  if (term.normal === `he's` || term.normal === `she's`) {
    return false;
  }
  let nextTerm = terms[i3 + 1];
  if (!nextTerm) {
    return true;
  }
  if (term.normal === `it's`) {
    if (nextTerm.tags.has("#Noun")) {
      return true;
    }
    return false;
  }
  if (nextTerm.switch == "Noun|Gerund") {
    let next2 = terms[i3 + 2];
    if (!next2) {
      if (term.tags.has("Actor") || term.tags.has("ProperNoun")) {
        return true;
      }
      return false;
    }
    if (next2.tags.has("Copula")) {
      return true;
    }
    if (next2.normal === "on" || next2.normal === "in") {
      return false;
    }
    return false;
  }
  if (nextTerm.tags.has("Verb")) {
    if (nextTerm.tags.has("Infinitive")) {
      return true;
    }
    if (nextTerm.tags.has("Gerund")) {
      return false;
    }
    if (nextTerm.tags.has("PresentTense")) {
      return true;
    }
    return false;
  }
  if (nextTerm.switch === "Adj|Noun") {
    let twoTerm = terms[i3 + 2];
    if (!twoTerm) {
      return false;
    }
    if (nounLike.has(twoTerm.normal)) {
      return true;
    }
    if (adjLike2.has(twoTerm.normal)) {
      return false;
    }
  }
  if (nextTerm.tags.has("Noun")) {
    let nextStr = nextTerm.machine || nextTerm.normal;
    if (nextStr === "here" || nextStr === "there" || nextStr === "everywhere") {
      return false;
    }
    if (nextTerm.tags.has("Possessive")) {
      return false;
    }
    if (nextTerm.tags.has("ProperNoun") && !term.tags.has("ProperNoun")) {
      return false;
    }
    return true;
  }
  if (terms[i3 - 1] && beforePossessive[terms[i3 - 1].normal] === true) {
    return true;
  }
  if (nextTerm.tags.has("Adjective")) {
    let twoTerm = terms[i3 + 2];
    if (!twoTerm) {
      return false;
    }
    if (twoTerm.tags.has("Noun") && !twoTerm.tags.has("Pronoun")) {
      let str = nextTerm.normal;
      if (str === "above" || str === "below" || str === "behind") {
        return false;
      }
      return true;
    }
    if (twoTerm.switch === "Noun|Verb") {
      return true;
    }
    return false;
  }
  if (nextTerm.tags.has("Value")) {
    return true;
  }
  return false;
};
var isPossessive_default = isPossessive2;

// node_modules/compromise/src/2-two/contraction-two/compute/index.js
var byApostrophe2 = /'/;
var reIndex = function(terms) {
  terms.forEach((t3, i3) => {
    if (t3.index) {
      t3.index[1] = i3;
    }
  });
};
var reTag2 = function(terms, view, start2, len) {
  let tmp = view.update();
  tmp.document = [terms];
  let end2 = start2 + len;
  if (start2 > 0) {
    start2 -= 1;
  }
  if (terms[end2]) {
    end2 += 1;
  }
  tmp.ptrs = [[0, start2, end2]];
  tmp.compute(["freeze", "lexicon", "preTagger", "unfreeze"]);
  reIndex(terms);
};
var byEnd2 = {
  // how'd
  d: (terms, i3) => apostrophe_d_default2(terms, i3),
  // we ain't
  t: (terms, i3) => apostrophe_t_default2(terms, i3),
  // bob's
  s: (terms, i3, world2) => {
    if (isPossessive_default(terms, i3)) {
      return world2.methods.one.setTag([terms[i3]], "Possessive", world2, null, "2-contraction");
    }
    return apostrophe_s_default(terms, i3);
  }
};
var toDocs2 = function(words, view) {
  let doc = view.fromText(words.join(" "));
  doc.compute("id");
  return doc.docs[0];
};
var contractionTwo = (view) => {
  let { world: world2, document: document2 } = view;
  document2.forEach((terms, n3) => {
    for (let i3 = terms.length - 1; i3 >= 0; i3 -= 1) {
      if (terms[i3].implicit) {
        continue;
      }
      let after2 = null;
      if (byApostrophe2.test(terms[i3].normal) === true) {
        after2 = terms[i3].normal.split(byApostrophe2)[1];
      }
      let words = null;
      if (byEnd2.hasOwnProperty(after2)) {
        words = byEnd2[after2](terms, i3, world2);
      }
      if (words) {
        words = toDocs2(words, view);
        splice_default2(document2, [n3, i3], words);
        reTag2(document2[n3], view, i3, words.length);
        continue;
      }
    }
  });
};
var compute_default10 = { contractionTwo };

// node_modules/compromise/src/2-two/contraction-two/plugin.js
var plugin_default15 = {
  compute: compute_default10,
  api: api_default10,
  hooks: ["contractionTwo"]
};

// node_modules/compromise/src/2-two/postTagger/model/adjective/adjective.js
var adjective_default = [
  // all fell apart
  { match: "[(all|both)] #Determiner #Noun", group: 0, tag: "Noun", reason: "all-noun" },
  //sometimes not-adverbs
  { match: "#Copula [(just|alone)]$", group: 0, tag: "Adjective", reason: "not-adverb" },
  //jack is guarded
  { match: "#Singular is #Adverb? [#PastTense$]", group: 0, tag: "Adjective", reason: "is-filled" },
  // smoked poutine is
  { match: "[#PastTense] #Singular is", group: 0, tag: "Adjective", reason: "smoked-poutine" },
  // baked onions are
  { match: "[#PastTense] #Plural are", group: 0, tag: "Adjective", reason: "baked-onions" },
  // well made
  { match: "well [#PastTense]", group: 0, tag: "Adjective", reason: "well-made" },
  // is f*ed up
  { match: "#Copula [fucked up?]", group: 0, tag: "Adjective", reason: "swears-adjective" },
  //jack seems guarded
  { match: "#Singular (seems|appears) #Adverb? [#PastTense$]", group: 0, tag: "Adjective", reason: "seems-filled" },
  // jury is out - preposition  adjective
  { match: "#Copula #Adjective? [(out|in|through)]$", group: 0, tag: "Adjective", reason: "still-out" },
  // shut the door
  { match: "^[#Adjective] (the|your) #Noun", group: 0, notIf: "(all|even)", tag: "Infinitive", reason: "shut-the" },
  // the said card
  { match: "the [said] #Noun", group: 0, tag: "Adjective", reason: "the-said-card" },
  // faith-based, much-appreciated, soft-boiled
  { match: "[#Hyphenated (#Hyphenated && #PastTense)] (#Noun|#Conjunction)", group: 0, tag: "Adjective", notIf: "#Adverb", reason: "faith-based" },
  //self-driving
  { match: "[#Hyphenated (#Hyphenated && #Gerund)] (#Noun|#Conjunction)", group: 0, tag: "Adjective", notIf: "#Adverb", reason: "self-driving" },
  //dammed-up
  { match: "[#PastTense (#Hyphenated && #PhrasalVerb)] (#Noun|#Conjunction)", group: 0, tag: "Adjective", reason: "dammed-up" },
  //two-fold
  { match: "(#Hyphenated && #Value) fold", tag: "Adjective", reason: "two-fold" },
  //must-win
  { match: "must (#Hyphenated && #Infinitive)", tag: "Adjective", reason: "must-win" },
  // vacuum-sealed
  { match: `(#Hyphenated && #Infinitive) #Hyphenated`, tag: "Adjective", notIf: "#PhrasalVerb", reason: "vacuum-sealed" },
  { match: "too much", tag: "Adverb Adjective", reason: "bit-4" },
  { match: "a bit much", tag: "Determiner Adverb Adjective", reason: "bit-3" },
  // adjective-prefixes - 'un skilled'
  { match: "[(un|contra|extra|inter|intra|macro|micro|mid|mis|mono|multi|pre|sub|tri|ex)] #Adjective", group: 0, tag: ["Adjective", "Prefix"], reason: "un-skilled" }
];

// node_modules/compromise/src/2-two/postTagger/model/adjective/adj-adverb.js
var adverbAdj = `(dark|bright|flat|light|soft|pale|dead|dim|faux|little|wee|sheer|most|near|good|extra|all)`;
var noLy = "(hard|fast|late|early|high|right|deep|close|direct)";
var adj_adverb_default = [
  // kinda sparkly
  { match: `#Adverb [#Adverb] (and|or|then)`, group: 0, tag: "Adjective", reason: "kinda-sparkly-and" },
  // dark green
  { match: `[${adverbAdj}] #Adjective`, group: 0, tag: "Adverb", reason: "dark-green" },
  // far too
  { match: `#Copula [far too] #Adjective`, group: 0, tag: "Adverb", reason: "far-too" },
  // was still in
  { match: `#Copula [still] (in|#Gerund|#Adjective)`, group: 0, tag: "Adverb", reason: "was-still-walking" },
  // studies hard
  { match: `#Plural ${noLy}`, tag: "#PresentTense #Adverb", reason: "studies-hard" },
  // shops direct
  {
    match: `#Verb [${noLy}] !#Noun?`,
    group: 0,
    notIf: "(#Copula|get|got|getting|become|became|becoming|feel|feels|feeling|#Determiner|#Preposition)",
    tag: "Adverb",
    reason: "shops-direct"
  },
  // studies a lot
  { match: `[#Plural] a lot`, tag: "PresentTense", reason: "studies-a-lot" }
];

// node_modules/compromise/src/2-two/postTagger/model/adjective/adj-gerund.js
var adj_gerund_default2 = [
  //a staggering cost
  // { match: '(a|an) [#Gerund]', group: 0, tag: 'Adjective', reason: 'a|an' },
  //as amusing as
  { match: "as [#Gerund] as", group: 0, tag: "Adjective", reason: "as-gerund-as" },
  // more amusing than
  { match: "more [#Gerund] than", group: 0, tag: "Adjective", reason: "more-gerund-than" },
  // very amusing
  { match: "(so|very|extremely) [#Gerund]", group: 0, tag: "Adjective", reason: "so-gerund" },
  // found it amusing
  { match: "(found|found) it #Adverb? [#Gerund]", group: 0, tag: "Adjective", reason: "found-it-gerund" },
  // a bit amusing
  { match: "a (little|bit|wee) bit? [#Gerund]", group: 0, tag: "Adjective", reason: "a-bit-gerund" },
  // looking annoying
  {
    match: "#Gerund [#Gerund]",
    group: 0,
    tag: "Adjective",
    notIf: "(impersonating|practicing|considering|assuming)",
    reason: "looking-annoying"
  },
  // looked amazing
  {
    match: "(looked|look|looks) #Adverb? [%Adj|Gerund%]",
    group: 0,
    tag: "Adjective",
    notIf: "(impersonating|practicing|considering|assuming)",
    reason: "looked-amazing"
  },
  // were really amazing
  // { match: '(looked|look|looks) #Adverb [%Adj|Gerund%]', group: 0, tag: 'Adjective', notIf: '(impersonating|practicing|considering|assuming)', reason: 'looked-amazing' },
  // developing a
  { match: "[%Adj|Gerund%] #Determiner", group: 0, tag: "Gerund", reason: "developing-a" },
  // world's leading manufacturer
  { match: "#Possessive [%Adj|Gerund%] #Noun", group: 0, tag: "Adjective", reason: "leading-manufacturer" },
  // meaning alluring
  { match: "%Noun|Gerund% %Adj|Gerund%", tag: "Gerund #Adjective", reason: "meaning-alluring" },
  // face shocking revelations
  {
    match: "(face|embrace|reveal|stop|start|resume) %Adj|Gerund%",
    tag: "#PresentTense #Adjective",
    reason: "face-shocking"
  },
  // are enduring symbols
  { match: "(are|were) [%Adj|Gerund%] #Plural", group: 0, tag: "Adjective", reason: "are-enduring-symbols" }
];

// node_modules/compromise/src/2-two/postTagger/model/adjective/adj-noun.js
var adj_noun_default2 = [
  //the above is clear
  { match: "#Determiner [#Adjective] #Copula", group: 0, tag: "Noun", reason: "the-adj-is" },
  //real evil is
  { match: "#Adjective [#Adjective] #Copula", group: 0, tag: "Noun", reason: "adj-adj-is" },
  //his fine
  { match: "(his|its) [%Adj|Noun%]", group: 0, tag: "Noun", notIf: "#Hyphenated", reason: "his-fine" },
  //is all
  { match: "#Copula #Adverb? [all]", group: 0, tag: "Noun", reason: "is-all" },
  // have fun
  { match: `(have|had) [#Adjective] #Preposition .`, group: 0, tag: "Noun", reason: "have-fun" },
  // brewing giant
  { match: `#Gerund (giant|capital|center|zone|application)`, tag: "Noun", reason: "brewing-giant" },
  // in an instant
  { match: `#Preposition (a|an) [#Adjective]$`, group: 0, tag: "Noun", reason: "an-instant" },
  // no golden would
  { match: `no [#Adjective] #Modal`, group: 0, tag: "Noun", reason: "no-golden" },
  // brand new
  { match: `[brand #Gerund?] new`, group: 0, tag: "Adverb", reason: "brand-new" },
  // some kind
  { match: `(#Determiner|#Comparative|new|different) [kind]`, group: 0, tag: "Noun", reason: "some-kind" },
  // her favourite sport
  { match: `#Possessive [%Adj|Noun%] #Noun`, group: 0, tag: "Adjective", reason: "her-favourite" },
  // must-win
  { match: `must && #Hyphenated .`, tag: "Adjective", reason: "must-win" },
  // the present
  {
    match: `#Determiner [#Adjective]$`,
    tag: "Noun",
    notIf: "(this|that|#Comparative|#Superlative)",
    reason: "the-south"
  },
  //are that crazy.
  // company-wide
  {
    match: `(#Noun && #Hyphenated) (#Adjective && #Hyphenated)`,
    tag: "Adjective",
    notIf: "(this|that|#Comparative|#Superlative)",
    reason: "company-wide"
  },
  // the poor were
  {
    match: `#Determiner [#Adjective] (#Copula|#Determiner)`,
    notIf: "(#Comparative|#Superlative)",
    group: 0,
    tag: "Noun",
    reason: "the-poor"
  },
  // professional bodybuilder
  {
    match: `[%Adj|Noun%] #Noun`,
    notIf: "(#Pronoun|#ProperNoun)",
    group: 0,
    tag: "Adjective",
    reason: "stable-foundations"
  }
];

// node_modules/compromise/src/2-two/postTagger/model/adjective/adj-verb.js
var adj_verb_default = [
  // amusing his aunt
  // { match: '[#Adjective] #Possessive #Noun', group: 0, tag: 'Verb', reason: 'gerund-his-noun' },
  // loving you
  // { match: '[#Adjective] (us|you)', group: 0, tag: 'Gerund', reason: 'loving-you' },
  // slowly stunning
  { match: "(slowly|quickly) [#Adjective]", group: 0, tag: "Verb", reason: "slowly-adj" },
  // does mean
  { match: "does (#Adverb|not)? [#Adjective]", group: 0, tag: "PresentTense", reason: "does-mean" },
  // okay by me
  { match: "[(fine|okay|cool|ok)] by me", group: 0, tag: "Adjective", reason: "okay-by-me" },
  // i mean
  { match: "i (#Adverb|do)? not? [mean]", group: 0, tag: "PresentTense", reason: "i-mean" },
  //will secure our
  { match: "will #Adjective", tag: "Auxiliary Infinitive", reason: "will-adj" },
  //he disguised the thing
  { match: "#Pronoun [#Adjective] #Determiner #Adjective? #Noun", group: 0, tag: "Verb", reason: "he-adj-the" },
  //is eager to go
  { match: "#Copula [%Adj|Present%] to #Verb", group: 0, tag: "Verb", reason: "adj-to" },
  //is done well
  { match: "#Copula [#Adjective] (well|badly|quickly|slowly)", group: 0, tag: "Verb", reason: "done-well" },
  // rude and insulting
  { match: "#Adjective and [#Gerund] !#Preposition?", group: 0, tag: "Adjective", reason: "rude-and-x" },
  // were over cooked
  { match: "#Copula #Adverb? (over|under) [#PastTense]", group: 0, tag: "Adjective", reason: "over-cooked" },
  // was bland and overcooked
  { match: "#Copula #Adjective+ (and|or) [#PastTense]$", group: 0, tag: "Adjective", reason: "bland-and-overcooked" },
  // got tired of
  { match: "got #Adverb? [#PastTense] of", group: 0, tag: "Adjective", reason: "got-tired-of" },
  //felt loved
  {
    match: "(seem|seems|seemed|appear|appeared|appears|feel|feels|felt|sound|sounds|sounded) (#Adverb|#Adjective)? [#PastTense]",
    group: 0,
    tag: "Adjective",
    reason: "felt-loved"
  },
  // seem confused
  { match: "(seem|feel|seemed|felt) [#PastTense #Particle?]", group: 0, tag: "Adjective", reason: "seem-confused" },
  // a bit confused
  { match: "a (bit|little|tad) [#PastTense #Particle?]", group: 0, tag: "Adjective", reason: "a-bit-confused" },
  // do not be embarrassed
  { match: "not be [%Adj|Past% #Particle?]", group: 0, tag: "Adjective", reason: "do-not-be-confused" },
  // is just right
  { match: "#Copula just [%Adj|Past% #Particle?]", group: 0, tag: "Adjective", reason: "is-just-right" },
  // as pale as
  { match: "as [#Infinitive] as", group: 0, tag: "Adjective", reason: "as-pale-as" },
  //failed and oppressive
  { match: "[%Adj|Past%] and #Adjective", group: 0, tag: "Adjective", reason: "faled-and-oppressive" },
  // or heightened emotion
  {
    match: "or [#PastTense] #Noun",
    group: 0,
    tag: "Adjective",
    notIf: "(#Copula|#Pronoun)",
    reason: "or-heightened-emotion"
  },
  // became involved
  { match: "(become|became|becoming|becomes) [#Verb]", group: 0, tag: "Adjective", reason: "become-verb" },
  // their declared intentions
  { match: "#Possessive [#PastTense] #Noun", group: 0, tag: "Adjective", reason: "declared-intentions" },
  // is he cool
  { match: "#Copula #Pronoun [%Adj|Present%]", group: 0, tag: "Adjective", reason: "is-he-cool" },
  // is crowded with
  {
    match: "#Copula [%Adj|Past%] with",
    group: 0,
    tag: "Adjective",
    notIf: "(associated|worn|baked|aged|armed|bound|fried|loaded|mixed|packed|pumped|filled|sealed)",
    reason: "is-crowded-with"
  },
  // is empty$
  { match: "#Copula #Adverb? [%Adj|Present%]$", group: 0, tag: "Adjective", reason: "was-empty$" }
];

// node_modules/compromise/src/2-two/postTagger/model/adverb.js
var adverb_default = [
  //still good
  { match: "[still] #Adjective", group: 0, tag: "Adverb", reason: "still-advb" },
  //still make
  { match: "[still] #Verb", group: 0, tag: "Adverb", reason: "still-verb" },
  // so hot
  { match: "[so] #Adjective", group: 0, tag: "Adverb", reason: "so-adv" },
  // way hotter
  { match: "[way] #Comparative", group: 0, tag: "Adverb", reason: "way-adj" },
  // way too hot
  { match: "[way] #Adverb #Adjective", group: 0, tag: "Adverb", reason: "way-too-adj" },
  // all singing
  { match: "[all] #Verb", group: 0, tag: "Adverb", reason: "all-verb" },
  // sing like an angel
  { match: "#Verb  [like]", group: 0, notIf: "(#Modal|#PhrasalVerb)", tag: "Adverb", reason: "verb-like" },
  //barely even walk
  { match: "(barely|hardly) even", tag: "Adverb", reason: "barely-even" },
  //even held
  { match: "[even] #Verb", group: 0, tag: "Adverb", reason: "even-walk" },
  //even worse
  { match: "[even] #Comparative", group: 0, tag: "Adverb", reason: "even-worse" },
  // even the greatest
  { match: "[even] (#Determiner|#Possessive)", group: 0, tag: "#Adverb", reason: "even-the" },
  // even left
  { match: "even left", tag: "#Adverb #Verb", reason: "even-left" },
  // way over
  { match: "[way] #Adjective", group: 0, tag: "#Adverb", reason: "way-over" },
  //cheering hard - dropped -ly's
  {
    match: "#PresentTense [(hard|quick|bright|slow|fast|backwards|forwards)]",
    notIf: "#Copula",
    group: 0,
    tag: "Adverb",
    reason: "lazy-ly"
  },
  // much appreciated
  { match: "[much] #Adjective", group: 0, tag: "Adverb", reason: "bit-1" },
  // is well
  { match: "#Copula [#Adverb]$", group: 0, tag: "Adjective", reason: "is-well" },
  // a bit cold
  { match: "a [(little|bit|wee) bit?] #Adjective", group: 0, tag: "Adverb", reason: "a-bit-cold" },
  // super strong
  { match: `[(super|pretty)] #Adjective`, group: 0, tag: "Adverb", reason: "super-strong" },
  // become overly weakened
  { match: "(become|fall|grow) #Adverb? [#PastTense]", group: 0, tag: "Adjective", reason: "overly-weakened" },
  // a completely beaten man
  { match: "(a|an) #Adverb [#Participle] #Noun", group: 0, tag: "Adjective", reason: "completely-beaten" },
  //a close
  { match: "#Determiner #Adverb? [close]", group: 0, tag: "Adjective", reason: "a-close" },
  //walking close
  { match: "#Gerund #Adverb? [close]", group: 0, tag: "Adverb", notIf: "(getting|becoming|feeling)", reason: "being-close" },
  // a blown motor
  { match: "(the|those|these|a|an) [#Participle] #Noun", group: 0, tag: "Adjective", reason: "blown-motor" },
  // charged back
  { match: "(#PresentTense|#PastTense) [back]", group: 0, tag: "Adverb", notIf: "(#PhrasalVerb|#Copula)", reason: "charge-back" },
  // send around
  { match: "#Verb [around]", group: 0, tag: "Adverb", notIf: "#PhrasalVerb", reason: "send-around" },
  // later say
  { match: "[later] #PresentTense", group: 0, tag: "Adverb", reason: "later-say" },
  // the well
  { match: "#Determiner [well] !#PastTense?", group: 0, tag: "Noun", reason: "the-well" },
  // high enough
  { match: "#Adjective [enough]", group: 0, tag: "Adverb", reason: "high-enough" }
];

// node_modules/compromise/src/2-two/postTagger/model/dates/date-phrase.js
var date_phrase_default = [
  // ==== Holiday ====
  { match: "#Holiday (day|eve)", tag: "Holiday", reason: "holiday-day" },
  //5th of March
  { match: "#Value of #Month", tag: "Date", reason: "value-of-month" },
  //5 March
  { match: "#Cardinal #Month", tag: "Date", reason: "cardinal-month" },
  //march 5 to 7
  { match: "#Month #Value to #Value", tag: "Date", reason: "value-to-value" },
  //march the 12th
  { match: "#Month the #Value", tag: "Date", reason: "month-the-value" },
  //june 7
  { match: "(#WeekDay|#Month) #Value", tag: "Date", reason: "date-value" },
  //7 june
  { match: "#Value (#WeekDay|#Month)", tag: "Date", reason: "value-date" },
  //may twenty five
  { match: "(#TextValue && #Date) #TextValue", tag: "Date", reason: "textvalue-date" },
  // 'aug 20-21'
  { match: `#Month #NumberRange`, tag: "Date", reason: "aug 20-21" },
  // wed march 5th
  { match: `#WeekDay #Month #Ordinal`, tag: "Date", reason: "week mm-dd" },
  // aug 5th 2021
  { match: `#Month #Ordinal #Cardinal`, tag: "Date", reason: "mm-dd-yyy" },
  // === timezones ===
  // china standard time
  { match: `(#Place|#Demonmym|#Time) (standard|daylight|central|mountain)? time`, tag: "Timezone", reason: "std-time" },
  // eastern time
  {
    match: `(eastern|mountain|pacific|central|atlantic) (standard|daylight|summer)? time`,
    tag: "Timezone",
    reason: "eastern-time"
  },
  // 5pm central
  { match: `#Time [(eastern|mountain|pacific|central|est|pst|gmt)]`, group: 0, tag: "Timezone", reason: "5pm-central" },
  // central european time
  { match: `(central|western|eastern) european time`, tag: "Timezone", reason: "cet" }
];

// node_modules/compromise/src/2-two/postTagger/model/dates/date.js
var date_default = [
  // ==== WeekDay ====
  // sun the 5th
  { match: "[sun] the #Ordinal", tag: "WeekDay", reason: "sun-the-5th" },
  //sun feb 2
  { match: "[sun] #Date", group: 0, tag: "WeekDay", reason: "sun-feb" },
  //1pm next sun
  { match: "#Date (on|this|next|last|during)? [sun]", group: 0, tag: "WeekDay", reason: "1pm-sun" },
  //this sat
  { match: `(in|by|before|during|on|until|after|of|within|all) [sat]`, group: 0, tag: "WeekDay", reason: "sat" },
  { match: `(in|by|before|during|on|until|after|of|within|all) [wed]`, group: 0, tag: "WeekDay", reason: "wed" },
  { match: `(in|by|before|during|on|until|after|of|within|all) [march]`, group: 0, tag: "Month", reason: "march" },
  //sat november
  { match: "[sat] #Date", group: 0, tag: "WeekDay", reason: "sat-feb" },
  // ==== Month ====
  //all march
  { match: `#Preposition [(march|may)]`, group: 0, tag: "Month", reason: "in-month" },
  //this march
  { match: `(this|next|last) (march|may) !#Infinitive?`, tag: "#Date #Month", reason: "this-month" },
  // march 5th
  { match: `(march|may) the? #Value`, tag: "#Month #Date #Date", reason: "march-5th" },
  // 5th of march
  { match: `#Value of? (march|may)`, tag: "#Date #Date #Month", reason: "5th-of-march" },
  // march and feb
  { match: `[(march|may)] .? #Date`, group: 0, tag: "Month", reason: "march-and-feb" },
  // feb to march
  { match: `#Date .? [(march|may)]`, group: 0, tag: "Month", reason: "feb-and-march" },
  //quickly march
  { match: `#Adverb [(march|may)]`, group: 0, tag: "Verb", reason: "quickly-march" },
  //march quickly
  { match: `[(march|may)] #Adverb`, group: 0, tag: "Verb", reason: "march-quickly" },
  //12 am
  { match: `#Value (am|pm)`, tag: "Time", reason: "2-am" }
];

// node_modules/compromise/src/2-two/postTagger/model/nouns/nouns.js
var infNouns = "(feel|sense|process|rush|side|bomb|bully|challenge|cover|crush|dump|exchange|flow|function|issue|lecture|limit|march|process)";
var nouns_default4 = [
  //'more' is not always an adverb
  // any more
  { match: "(the|any) [more]", group: 0, tag: "Singular", reason: "more-noun" },
  // more players
  { match: "[more] #Noun", group: 0, tag: "Adjective", reason: "more-noun" },
  // rights of man
  { match: "(right|rights) of .", tag: "Noun", reason: "right-of" },
  // a bit
  { match: "a [bit]", group: 0, tag: "Singular", reason: "bit-2" },
  // a must
  { match: "a [must]", group: 0, tag: "Singular", reason: "must-2" },
  // we all
  { match: "(we|us) [all]", group: 0, tag: "Noun", reason: "we all" },
  // due to weather
  { match: "due to [#Verb]", group: 0, tag: "Noun", reason: "due-to" },
  //some pressing issues
  { match: "some [#Verb] #Plural", group: 0, tag: "Noun", reason: "determiner6" },
  // my first thought
  { match: "#Possessive #Ordinal [#PastTense]", group: 0, tag: "Noun", reason: "first-thought" },
  //the nice swim
  {
    match: "(the|this|those|these) #Adjective [%Verb|Noun%]",
    group: 0,
    tag: "Noun",
    notIf: "#Copula",
    reason: "the-adj-verb"
  },
  // the truly nice swim
  { match: "(the|this|those|these) #Adverb #Adjective [#Verb]", group: 0, tag: "Noun", reason: "determiner4" },
  //the wait to vote
  { match: "the [#Verb] #Preposition .", group: 0, tag: "Noun", reason: "determiner1" },
  //a sense of
  { match: "(a|an|the) [#Verb] of", group: 0, tag: "Noun", reason: "the-verb-of" },
  //the threat of force
  { match: "#Determiner #Noun of [#Verb]", group: 0, tag: "Noun", notIf: "#Gerund", reason: "noun-of-noun" },
  // ended in ruins
  {
    match: "#PastTense #Preposition [#PresentTense]",
    group: 0,
    notIf: "#Gerund",
    tag: "Noun",
    reason: "ended-in-ruins"
  },
  //'u' as pronoun
  { match: "#Conjunction [u]", group: 0, tag: "Pronoun", reason: "u-pronoun-2" },
  { match: "[u] #Verb", group: 0, tag: "Pronoun", reason: "u-pronoun-1" },
  //the western line
  {
    match: "#Determiner [(western|eastern|northern|southern|central)] #Noun",
    group: 0,
    tag: "Noun",
    reason: "western-line"
  },
  //air-flow
  { match: "(#Singular && @hasHyphen) #PresentTense", tag: "Noun", reason: "hyphen-verb" },
  //is no walk
  { match: "is no [#Verb]", group: 0, tag: "Noun", reason: "is-no-verb" },
  //do so
  { match: "do [so]", group: 0, tag: "Noun", reason: "so-noun" },
  // what the hell
  { match: "#Determiner [(shit|damn|hell)]", group: 0, tag: "Noun", reason: "swears-noun" },
  // go to shit
  { match: "to [(shit|hell)]", group: 0, tag: "Noun", reason: "to-swears" },
  // the staff were
  { match: "(the|these) [#Singular] (were|are)", group: 0, tag: "Plural", reason: "singular-were" },
  // a comdominium, or simply condo
  { match: `a #Noun+ or #Adverb+? [#Verb]`, group: 0, tag: "Noun", reason: "noun-or-noun" },
  // walk the walk
  {
    match: "(the|those|these|a|an) #Adjective? [#PresentTense #Particle?]",
    group: 0,
    tag: "Noun",
    notIf: "(seem|appear|include|#Gerund|#Copula)",
    reason: "det-inf"
  },
  // { match: '(the|those|these|a|an) #Adjective? [#PresentTense #Particle?]', group: 0, tag: 'Noun', notIf: '(#Gerund|#Copula)', reason: 'det-pres' },
  // ==== Actor ====
  //Aircraft designer
  { match: "#Noun #Actor", tag: "Actor", notIf: "(#Person|#Pronoun)", reason: "thing-doer" },
  //lighting designer
  { match: "#Gerund #Actor", tag: "Actor", reason: "gerund-doer" },
  // captain sanders
  // { match: '[#Actor+] #ProperNoun', group: 0, tag: 'Honorific', reason: 'sgt-kelly' },
  // co-founder
  { match: `co #Singular`, tag: "Actor", reason: "co-noun" },
  // co-founder
  {
    match: `[#Noun+] #Actor`,
    group: 0,
    tag: "Actor",
    notIf: "(#Honorific|#Pronoun|#Possessive)",
    reason: "air-traffic-controller"
  },
  // fine-artist
  {
    match: `(urban|cardiac|cardiovascular|respiratory|medical|clinical|visual|graphic|creative|dental|exotic|fine|certified|registered|technical|virtual|professional|amateur|junior|senior|special|pharmaceutical|theoretical)+ #Noun? #Actor`,
    tag: "Actor",
    reason: "fine-artist"
  },
  // dance coach
  {
    match: `#Noun+ (coach|chef|king|engineer|fellow|personality|boy|girl|man|woman|master)`,
    tag: "Actor",
    reason: "dance-coach"
  },
  // chief design officer
  { match: `chief . officer`, tag: "Actor", reason: "chief-x-officer" },
  // chief of police
  { match: `chief of #Noun+`, tag: "Actor", reason: "chief-of-police" },
  // president of marketing
  { match: `senior? vice? president of #Noun+`, tag: "Actor", reason: "president-of" },
  // ==== Singular ====
  //the sun
  { match: "#Determiner [sun]", group: 0, tag: "Singular", reason: "the-sun" },
  //did a 900, paid a 20
  { match: "#Verb (a|an) [#Value]$", group: 0, tag: "Singular", reason: "did-a-value" },
  //'the can'
  { match: "the [(can|will|may)]", group: 0, tag: "Singular", reason: "the can" },
  // ==== Possessive ====
  //spencer kelly's
  { match: "#FirstName #Acronym? (#Possessive && #LastName)", tag: "Possessive", reason: "name-poss" },
  //Super Corp's fundraiser
  { match: "#Organization+ #Possessive", tag: "Possessive", reason: "org-possessive" },
  //Los Angeles's fundraiser
  { match: "#Place+ #Possessive", tag: "Possessive", reason: "place-possessive" },
  // Ptolemy's experiments
  { match: "#Possessive #PresentTense #Particle?", notIf: "(#Gerund|her)", tag: "Noun", reason: "possessive-verb" },
  // anna's eating vs anna's eating lunch
  // my presidents house
  { match: "(my|our|their|her|his|its) [(#Plural && #Actor)] #Noun", tag: "Possessive", reason: "my-dads" },
  // 10th of a second
  { match: "#Value of a [second]", group: 0, unTag: "Value", tag: "Singular", reason: "10th-of-a-second" },
  // 10 seconds
  { match: "#Value [seconds]", group: 0, unTag: "Value", tag: "Plural", reason: "10-seconds" },
  // in time
  { match: "in [#Infinitive]", group: 0, tag: "Singular", reason: "in-age" },
  // a minor in
  { match: "a [#Adjective] #Preposition", group: 0, tag: "Noun", reason: "a-minor-in" },
  //the repairer said
  { match: "#Determiner [#Singular] said", group: 0, tag: "Actor", reason: "the-actor-said" },
  //the euro sense
  {
    match: `#Determiner #Noun [${infNouns}] !(#Preposition|to|#Adverb)?`,
    group: 0,
    tag: "Noun",
    reason: "the-noun-sense"
  },
  // photographs of a computer are
  { match: "[#PresentTense] (of|by|for) (a|an|the) #Noun #Copula", group: 0, tag: "Plural", reason: "photographs-of" },
  // fight and win
  { match: "#Infinitive and [%Noun|Verb%]", group: 0, tag: "Infinitive", reason: "fight and win" },
  // peace and flowers and love
  { match: "#Noun and [#Verb] and #Noun", group: 0, tag: "Noun", reason: "peace-and-flowers" },
  // the 1992 classic
  { match: "the #Cardinal [%Adj|Noun%]", group: 0, tag: "Noun", reason: "the-1992-classic" },
  // the premier university
  { match: "#Copula the [%Adj|Noun%] #Noun", group: 0, tag: "Adjective", reason: "the-premier-university" },
  // scottish - i ate me sandwich
  { match: "i #Verb [me] #Noun", group: 0, tag: "Possessive", reason: "scottish-me" },
  // dance music
  {
    match: "[#PresentTense] (music|class|lesson|night|party|festival|league|ceremony)",
    group: 0,
    tag: "Noun",
    reason: "dance-music"
  },
  // wit it
  { match: "[wit] (me|it)", group: 0, tag: "Presposition", reason: "wit-me" },
  //left-her-boots, shoved her hand
  { match: "#PastTense #Possessive [#Verb]", group: 0, tag: "Noun", notIf: "(saw|made)", reason: "left-her-boots" },
  //35 signs
  { match: "#Value [%Plural|Verb%]", group: 0, tag: "Plural", notIf: "(one|1|a|an)", reason: "35-signs" },
  //had time
  { match: "had [#PresentTense]", group: 0, tag: "Noun", notIf: "(#Gerund|come|become)", reason: "had-time" },
  //instant access
  { match: "%Adj|Noun% %Noun|Verb%", tag: "#Adjective #Noun", notIf: "#ProperNoun #Noun", reason: "instant-access" },
  // a representative to
  { match: "#Determiner [%Adj|Noun%] #Conjunction", group: 0, tag: "Noun", reason: "a-rep-to" },
  // near death experiences, ambitious sales targets
  {
    match: "#Adjective #Noun [%Plural|Verb%]$",
    group: 0,
    tag: "Plural",
    notIf: "#Pronoun",
    reason: "near-death-experiences"
  },
  // your guild colors
  { match: "#Possessive #Noun [%Plural|Verb%]$", group: 0, tag: "Plural", reason: "your-guild-colors" }
];

// node_modules/compromise/src/2-two/postTagger/model/verbs/noun-gerund.js
var noun_gerund_default2 = [
  // the planning processes
  { match: "(this|that|the|a|an) [#Gerund #Infinitive]", group: 0, tag: "Singular", reason: "the-planning-process" },
  // the paving stones
  { match: "(that|the) [#Gerund #PresentTense]", group: 0, ifNo: "#Copula", tag: "Plural", reason: "the-paving-stones" },
  // this swimming
  // { match: '(this|that|the) [#Gerund]', group: 0, tag: 'Noun', reason: 'this-gerund' },
  // the remaining claims
  { match: "#Determiner [#Gerund] #Noun", group: 0, tag: "Adjective", reason: "the-gerund-noun" },
  // i think tipping sucks
  { match: `#Pronoun #Infinitive [#Gerund] #PresentTense`, group: 0, tag: "Noun", reason: "tipping-sucks" },
  // early warning
  { match: "#Adjective [#Gerund]", group: 0, tag: "Noun", notIf: "(still|even|just)", reason: "early-warning" },
  //walking is cool
  { match: "[#Gerund] #Adverb? not? #Copula", group: 0, tag: "Activity", reason: "gerund-copula" },
  //are doing is
  { match: "#Copula [(#Gerund|#Activity)] #Copula", group: 0, tag: "Gerund", reason: "are-doing-is" },
  //walking should be fun
  { match: "[#Gerund] #Modal", group: 0, tag: "Activity", reason: "gerund-modal" },
  // finish listening
  // { match: '#Infinitive [#Gerund]', group: 0, tag: 'Activity', reason: 'finish-listening' },
  // the ruling party
  // responsibility for setting
  { match: "#Singular for [%Noun|Gerund%]", group: 0, tag: "Gerund", reason: "noun-for-gerund" },
  // better for training
  { match: "#Comparative (for|at) [%Noun|Gerund%]", group: 0, tag: "Gerund", reason: "better-for-gerund" },
  // keep the touching
  { match: "#PresentTense the [#Gerund]", group: 0, tag: "Noun", reason: "keep-the-touching" }
];

// node_modules/compromise/src/2-two/postTagger/model/verbs/verb-noun.js
var verb_noun_default = [
  // do the dance
  { match: "#Infinitive (this|that|the) [#Infinitive]", group: 0, tag: "Noun", reason: "do-this-dance" },
  //running-a-show
  { match: "#Gerund #Determiner [#Infinitive]", group: 0, tag: "Noun", reason: "running-a-show" },
  //the-only-reason
  { match: "#Determiner (only|further|just|more|backward) [#Infinitive]", group: 0, tag: "Noun", reason: "the-only-reason" },
  // a stream runs
  { match: "(the|this|a|an) [#Infinitive] #Adverb? #Verb", group: 0, tag: "Noun", reason: "determiner5" },
  //a nice deal
  { match: "#Determiner #Adjective #Adjective? [#Infinitive]", group: 0, tag: "Noun", reason: "a-nice-inf" },
  // the mexican train
  { match: "#Determiner #Demonym [#PresentTense]", group: 0, tag: "Noun", reason: "mexican-train" },
  //next career move
  { match: "#Adjective #Noun+ [#Infinitive] #Copula", group: 0, tag: "Noun", reason: "career-move" },
  // at some point
  { match: "at some [#Infinitive]", group: 0, tag: "Noun", reason: "at-some-inf" },
  // goes to sleep
  { match: "(go|goes|went) to [#Infinitive]", group: 0, tag: "Noun", reason: "goes-to-verb" },
  //a close watch on
  { match: "(a|an) #Adjective? #Noun [#Infinitive] (#Preposition|#Noun)", group: 0, notIf: "from", tag: "Noun", reason: "a-noun-inf" },
  //a tv show
  { match: "(a|an) #Noun [#Infinitive]$", group: 0, tag: "Noun", reason: "a-noun-inf2" },
  //is mark hughes
  // { match: '#Copula [#Infinitive] #Noun', group: 0, tag: 'Noun', reason: 'is-pres-noun' },
  // good wait staff
  // { match: '#Adjective [#Infinitive] #Noun', group: 0, tag: 'Noun', reason: 'good-wait-staff' },
  // running for congress
  { match: "#Gerund #Adjective? for [#Infinitive]", group: 0, tag: "Noun", reason: "running-for" },
  // running to work
  // { match: '#Gerund #Adjective to [#Infinitive]', group: 0, tag: 'Noun', reason: 'running-to' },
  // about love
  { match: "about [#Infinitive]", group: 0, tag: "Singular", reason: "about-love" },
  // singers on stage
  { match: "#Plural on [#Infinitive]", group: 0, tag: "Noun", reason: "on-stage" },
  // any charge
  { match: "any [#Infinitive]", group: 0, tag: "Noun", reason: "any-charge" },
  // no doubt
  { match: "no [#Infinitive]", group: 0, tag: "Noun", reason: "no-doubt" },
  // number of seats
  { match: "number of [#PresentTense]", group: 0, tag: "Noun", reason: "number-of-x" },
  // teaches/taught
  { match: "(taught|teaches|learns|learned) [#PresentTense]", group: 0, tag: "Noun", reason: "teaches-x" },
  // use reverse
  { match: "(try|use|attempt|build|make) [#Verb #Particle?]", notIf: "(#Copula|#Noun|sure|fun|up)", group: 0, tag: "Noun", reason: "do-verb" },
  //make sure of
  // checkmate is
  { match: "^[#Infinitive] (is|was)", group: 0, tag: "Noun", reason: "checkmate-is" },
  // get much sleep
  { match: "#Infinitive much [#Infinitive]", group: 0, tag: "Noun", reason: "get-much" },
  // cause i gotta
  { match: "[cause] #Pronoun #Verb", group: 0, tag: "Conjunction", reason: "cause-cuz" },
  // the cardio dance party
  { match: "the #Singular [#Infinitive] #Noun", group: 0, tag: "Noun", notIf: "#Pronoun", reason: "cardio-dance" },
  // that should smoke
  { match: "#Determiner #Modal [#Noun]", group: 0, tag: "PresentTense", reason: "should-smoke" },
  //this rocks
  { match: "this [#Plural]", group: 0, tag: "PresentTense", notIf: "(#Preposition|#Date)", reason: "this-verbs" },
  //voice that rocks
  { match: "#Noun that [#Plural]", group: 0, tag: "PresentTense", notIf: "(#Preposition|#Pronoun|way)", reason: "voice-that-rocks" },
  //that leads to
  { match: "that [#Plural] to", group: 0, tag: "PresentTense", notIf: "#Preposition", reason: "that-leads-to" },
  //let him glue
  {
    match: "(let|make|made) (him|her|it|#Person|#Place|#Organization)+ [#Singular] (a|an|the|it)",
    group: 0,
    tag: "Infinitive",
    reason: "let-him-glue"
  },
  // assign all tasks
  { match: "#Verb (all|every|each|most|some|no) [#PresentTense]", notIf: "#Modal", group: 0, tag: "Noun", reason: "all-presentTense" },
  // PresentTense/Noun ambiguities
  // big dreams, critical thinking
  // have big dreams
  { match: "(had|have|#PastTense) #Adjective [#PresentTense]", group: 0, tag: "Noun", notIf: "better", reason: "adj-presentTense" },
  // excellent answer spencer
  // { match: '^#Adjective [#PresentTense]', group: 0, tag: 'Noun', reason: 'start adj-presentTense' },
  // one big reason
  { match: "#Value #Adjective [#PresentTense]", group: 0, tag: "Noun", notIf: "#Copula", reason: "one-big-reason" },
  // won widespread support
  { match: "#PastTense #Adjective+ [#PresentTense]", group: 0, tag: "Noun", notIf: "(#Copula|better)", reason: "won-wide-support" },
  // many poses
  { match: "(many|few|several|couple) [#PresentTense]", group: 0, tag: "Noun", notIf: "#Copula", reason: "many-poses" },
  // very big dreams
  { match: "#Determiner #Adverb #Adjective [%Noun|Verb%]", group: 0, tag: "Noun", notIf: "#Copula", reason: "very-big-dream" },
  // from start to finish
  { match: "from #Noun to [%Noun|Verb%]", group: 0, tag: "Noun", reason: "start-to-finish" },
  // for comparison or contrast
  { match: "(for|with|of) #Noun (and|or|not) [%Noun|Verb%]", group: 0, tag: "Noun", notIf: "#Pronoun", reason: "for-food-and-gas" },
  // adorable little store
  { match: "#Adjective #Adjective [#PresentTense]", group: 0, tag: "Noun", notIf: "#Copula", reason: "adorable-little-store" },
  // of basic training
  // { match: '#Preposition #Adjective [#PresentTense]', group: 0, tag: 'Noun', reason: 'of-basic-training' },
  // justifiying higher costs
  { match: "#Gerund #Adverb? #Comparative [#PresentTense]", group: 0, tag: "Noun", notIf: "#Copula", reason: "higher-costs" },
  { match: "(#Noun && @hasComma) #Noun (and|or) [#PresentTense]", group: 0, tag: "Noun", notIf: "#Copula", reason: "noun-list" },
  // any questions for
  { match: "(many|any|some|several) [#PresentTense] for", group: 0, tag: "Noun", reason: "any-verbs-for" },
  // to facilitate gas exchange with
  { match: `to #PresentTense #Noun [#PresentTense] #Preposition`, group: 0, tag: "Noun", reason: "gas-exchange" },
  // waited until release
  { match: `#PastTense (until|as|through|without) [#PresentTense]`, group: 0, tag: "Noun", reason: "waited-until-release" },
  // selling like hot cakes
  { match: `#Gerund like #Adjective? [#PresentTense]`, group: 0, tag: "Plural", reason: "like-hot-cakes" },
  // some valid reason
  { match: `some #Adjective [#PresentTense]`, group: 0, tag: "Noun", reason: "some-reason" },
  // for some reason
  { match: `for some [#PresentTense]`, group: 0, tag: "Noun", reason: "for-some-reason" },
  // same kind of shouts
  { match: `(same|some|the|that|a) kind of [#PresentTense]`, group: 0, tag: "Noun", reason: "some-kind-of" },
  // a type of shout
  { match: `(same|some|the|that|a) type of [#PresentTense]`, group: 0, tag: "Noun", reason: "some-type-of" },
  // doing better for fights
  { match: `#Gerund #Adjective #Preposition [#PresentTense]`, group: 0, tag: "Noun", reason: "doing-better-for-x" },
  // get better aim
  { match: `(get|got|have) #Comparative [#PresentTense]`, group: 0, tag: "Noun", reason: "got-better-aim" },
  // whose name was
  { match: "whose [#PresentTense] #Copula", group: 0, tag: "Noun", reason: "whos-name-was" },
  // give up on reason
  { match: `#PhrasalVerb #Particle #Preposition [#PresentTense]`, group: 0, tag: "Noun", reason: "given-up-on-x" },
  //there are reasons
  { match: "there (are|were) #Adjective? [#PresentTense]", group: 0, tag: "Plural", reason: "there-are" },
  // 30 trains
  { match: "#Value [#PresentTense] of", group: 0, notIf: "(one|1|#Copula|#Infinitive)", tag: "Plural", reason: "2-trains" },
  // compromises are possible
  { match: "[#PresentTense] (are|were) #Adjective", group: 0, tag: "Plural", reason: "compromises-are-possible" },
  // hope i helped
  { match: "^[(hope|guess|thought|think)] #Pronoun #Verb", group: 0, tag: "Infinitive", reason: "suppose-i" },
  //pursue its dreams
  // { match: '#PresentTense #Possessive [#PresentTense]', notIf: '#Gerund', group: 0, tag: 'Plural', reason: 'pursue-its-dreams' },
  // our unyielding support
  { match: "#Possessive #Adjective [#Verb]", group: 0, tag: "Noun", notIf: "#Copula", reason: "our-full-support" },
  // tastes good
  { match: "[(tastes|smells)] #Adverb? #Adjective", group: 0, tag: "PresentTense", reason: "tastes-good" },
  // are you playing golf
  // { match: '^are #Pronoun [#Noun]', group: 0, notIf: '(here|there)', tag: 'Verb', reason: 'are-you-x' },
  // ignoring commute
  { match: "#Copula #Gerund [#PresentTense] !by?", group: 0, tag: "Noun", notIf: "going", reason: "ignoring-commute" },
  // noun-pastTense variables
  { match: "#Determiner #Adjective? [(shed|thought|rose|bid|saw|spelt)]", group: 0, tag: "Noun", reason: "noun-past" },
  // 'verb-to'
  // how to watch
  { match: "how to [%Noun|Verb%]", group: 0, tag: "Infinitive", reason: "how-to-noun" },
  // which boost it
  { match: "which [%Noun|Verb%] #Noun", group: 0, tag: "Infinitive", reason: "which-boost-it" },
  // asking questions
  { match: "#Gerund [%Plural|Verb%]", group: 0, tag: "Plural", reason: "asking-questions" },
  // ready to stream
  { match: "(ready|available|difficult|hard|easy|made|attempt|try) to [%Noun|Verb%]", group: 0, tag: "Infinitive", reason: "ready-to-noun" },
  // bring to market
  { match: "(bring|went|go|drive|run|bike) to [%Noun|Verb%]", group: 0, tag: "Noun", reason: "bring-to-noun" },
  // can i sleep, would you look
  { match: "#Modal #Noun [%Noun|Verb%]", group: 0, tag: "Infinitive", reason: "would-you-look" },
  // is just spam
  { match: "#Copula just [#Infinitive]", group: 0, tag: "Noun", reason: "is-just-spam" },
  // request copies
  { match: "^%Noun|Verb% %Plural|Verb%", tag: "Imperative #Plural", reason: "request-copies" },
  // homemade pickles and drinks
  { match: "#Adjective #Plural and [%Plural|Verb%]", group: 0, tag: "#Plural", reason: "pickles-and-drinks" },
  // the 1968 film
  { match: "#Determiner #Year [#Verb]", group: 0, tag: "Noun", reason: "the-1968-film" },
  // the break up
  { match: "#Determiner [#PhrasalVerb #Particle]", group: 0, tag: "Noun", reason: "the-break-up" },
  // the individual goals
  { match: "#Determiner [%Adj|Noun%] #Noun", group: 0, tag: "Adjective", notIf: "(#Pronoun|#Possessive|#ProperNoun)", reason: "the-individual-goals" },
  // work or prepare
  { match: "[%Noun|Verb%] or #Infinitive", group: 0, tag: "Infinitive", reason: "work-or-prepare" },
  // to give thanks
  { match: "to #Infinitive [#PresentTense]", group: 0, tag: "Noun", notIf: "(#Gerund|#Copula|help)", reason: "to-give-thanks" },
  // kills me
  { match: "[#Noun] me", group: 0, tag: "Verb", reason: "kills-me" },
  // removes wrinkles
  { match: "%Plural|Verb% %Plural|Verb%", tag: "#PresentTense #Plural", reason: "removes-wrinkles" }
];

// node_modules/compromise/src/2-two/postTagger/model/numbers/money.js
var money_default = [
  { match: "#Money and #Money #Currency?", tag: "Money", reason: "money-and-money" },
  // 6 dollars and 5 cents
  { match: "#Value #Currency [and] #Value (cents|ore|centavos|sens)", group: 0, tag: "money", reason: "and-5-cents" },
  // maybe currencies
  { match: "#Value (mark|rand|won|rub|ore)", tag: "#Money #Currency", reason: "4-mark" },
  // 3 pounds
  { match: "a pound", tag: "#Money #Unit", reason: "a-pound" },
  { match: "#Value (pound|pounds)", tag: "#Money #Unit", reason: "4-pounds" }
];

// node_modules/compromise/src/2-two/postTagger/model/numbers/fractions.js
var fractions_default = [
  // half a penny
  { match: "[(half|quarter)] of? (a|an)", group: 0, tag: "Fraction", reason: "millionth" },
  // nearly half
  { match: "#Adverb [half]", group: 0, tag: "Fraction", reason: "nearly-half" },
  // half the
  { match: "[half] the", group: 0, tag: "Fraction", reason: "half-the" },
  // and a half
  { match: "#Cardinal and a half", tag: "Fraction", reason: "and-a-half" },
  // two-halves
  { match: "#Value (halves|halfs|quarters)", tag: "Fraction", reason: "two-halves" },
  // ---ordinals as fractions---
  // a fifth
  { match: "a #Ordinal", tag: "Fraction", reason: "a-quarter" },
  // seven fifths
  { match: "[#Cardinal+] (#Fraction && /s$/)", tag: "Fraction", reason: "seven-fifths" },
  // doc.match('(#Fraction && /s$/)').lookBefore('#Cardinal+$').tag('Fraction')
  // one third of ..
  { match: "[#Cardinal+ #Ordinal] of .", group: 0, tag: "Fraction", reason: "ordinal-of" },
  // 100th of
  { match: "[(#NumericValue && #Ordinal)] of .", group: 0, tag: "Fraction", reason: "num-ordinal-of" },
  // a twenty fifth
  { match: "(a|one) #Cardinal?+ #Ordinal", tag: "Fraction", reason: "a-ordinal" },
  // //  '3 out of 5'
  { match: "#Cardinal+ out? of every? #Cardinal", tag: "Fraction", reason: "out-of" }
];

// node_modules/compromise/src/2-two/postTagger/model/numbers/numbers.js
var numbers_default = [
  // ==== Ambiguous numbers ====
  // 'second'
  { match: `#Cardinal [second]`, tag: "Unit", reason: "one-second" },
  //'a/an' can mean 1 - "a hour"
  {
    match: "!once? [(a|an)] (#Duration|hundred|thousand|million|billion|trillion)",
    group: 0,
    tag: "Value",
    reason: "a-is-one"
  },
  // ==== PhoneNumber ====
  //1 800 ...
  { match: "1 #Value #PhoneNumber", tag: "PhoneNumber", reason: "1-800-Value" },
  //(454) 232-9873
  { match: "#NumericValue #PhoneNumber", tag: "PhoneNumber", reason: "(800) PhoneNumber" },
  // ==== Currency ====
  // chinese yuan
  { match: "#Demonym #Currency", tag: "Currency", reason: "demonym-currency" },
  // ten bucks
  { match: "#Value [(buck|bucks|grand)]", group: 0, tag: "Currency", reason: "value-bucks" },
  // ==== Money ====
  { match: "[#Value+] #Currency", group: 0, tag: "Money", reason: "15 usd" },
  // ==== Ordinal ====
  { match: "[second] #Noun", group: 0, tag: "Ordinal", reason: "second-noun" },
  // ==== Units ====
  //5 yan
  { match: "#Value+ [#Currency]", group: 0, tag: "Unit", reason: "5-yan" },
  { match: "#Value [(foot|feet)]", group: 0, tag: "Unit", reason: "foot-unit" },
  //5 kg.
  { match: "#Value [#Abbreviation]", group: 0, tag: "Unit", reason: "value-abbr" },
  { match: "#Value [k]", group: 0, tag: "Unit", reason: "value-k" },
  { match: "#Unit an hour", tag: "Unit", reason: "unit-an-hour" },
  // ==== Magnitudes ====
  //minus 7
  { match: "(minus|negative) #Value", tag: "Value", reason: "minus-value" },
  //seven point five
  { match: "#Value (point|decimal) #Value", tag: "Value", reason: "value-point-value" },
  //quarter million
  { match: "#Determiner [(half|quarter)] #Ordinal", group: 0, tag: "Value", reason: "half-ordinal" },
  // thousand and two
  { match: `#Multiple+ and #Value`, tag: "Value", reason: "magnitude-and-value" },
  // ambiguous units like 'gb'
  // { match: '#Value square? [(kb|mb|gb|tb|ml|pt|qt|tbl|tbsp|km|cm|mm|mi|ft|yd|kg|hg|mg|oz|lb|mph|pa|miles|yard|yards|pound|pounds)]', group: 0, tag: 'Unit', reason: '12-gb' },
  // 5 miles per hour
  { match: "#Value #Unit [(per|an) (hr|hour|sec|second|min|minute)]", group: 0, tag: "Unit", reason: "12-miles-per-second" },
  // 5 square miles
  { match: "#Value [(square|cubic)] #Unit", group: 0, tag: "Unit", reason: "square-miles" }
  // 5) The expenses
  // { match: '^[#Value] (#Determiner|#Gerund)', group: 0, tag: 'Expression', unTag: 'Value', reason: 'numbered-list' },
];

// node_modules/compromise/src/2-two/postTagger/model/person/person-phrase.js
var person_phrase_default = [
  // ==== FirstNames ====
  //is foo Smith
  { match: "#Copula [(#Noun|#PresentTense)] #LastName", group: 0, tag: "FirstName", reason: "copula-noun-lastname" },
  //pope francis
  {
    match: "(sister|pope|brother|father|aunt|uncle|grandpa|grandfather|grandma) #ProperNoun",
    tag: "Person",
    reason: "lady-titlecase",
    safe: true
  },
  // ==== Nickname ====
  // Dwayne 'the rock' Johnson
  { match: "#FirstName [#Determiner #Noun] #LastName", group: 0, tag: "Person", reason: "first-noun-last" },
  {
    match: "#ProperNoun (b|c|d|e|f|g|h|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z) #ProperNoun",
    tag: "Person",
    reason: "titlecase-acronym-titlecase",
    safe: true
  },
  { match: "#Acronym #LastName", tag: "Person", reason: "acronym-lastname", safe: true },
  { match: "#Person (jr|sr|md)", tag: "Person", reason: "person-honorific" },
  //remove single 'mr'
  { match: "#Honorific #Acronym", tag: "Person", reason: "Honorific-TitleCase" },
  { match: "#Person #Person the? #RomanNumeral", tag: "Person", reason: "roman-numeral" },
  { match: "#FirstName [/^[^aiurck]$/]", group: 0, tag: ["Acronym", "Person"], reason: "john-e" },
  //j.k Rowling
  { match: "#Noun van der? #Noun", tag: "Person", reason: "van der noun", safe: true },
  //king of spain
  { match: "(king|queen|prince|saint|lady) of #Noun", tag: "Person", reason: "king-of-noun", safe: true },
  //lady Florence
  { match: "(prince|lady) #Place", tag: "Person", reason: "lady-place" },
  //saint Foo
  { match: "(king|queen|prince|saint) #ProperNoun", tag: "Person", notIf: "#Place", reason: "saint-foo" },
  // al sharpton
  { match: "al (#Person|#ProperNoun)", tag: "Person", reason: "al-borlen", safe: true },
  //ferdinand de almar
  { match: "#FirstName de #Noun", tag: "Person", reason: "bill-de-noun" },
  //Osama bin Laden
  { match: "#FirstName (bin|al) #Noun", tag: "Person", reason: "bill-al-noun" },
  //John L. Foo
  { match: "#FirstName #Acronym #ProperNoun", tag: "Person", reason: "bill-acronym-title" },
  //Andrew Lloyd Webber
  { match: "#FirstName #FirstName #ProperNoun", tag: "Person", reason: "bill-firstname-title" },
  //Mr Foo
  { match: "#Honorific #FirstName? #ProperNoun", tag: "Person", reason: "dr-john-Title" },
  //peter the great
  { match: "#FirstName the #Adjective", tag: "Person", reason: "name-the-great" },
  // dick van dyke
  { match: "#ProperNoun (van|al|bin) #ProperNoun", tag: "Person", reason: "title-van-title", safe: true },
  //jose de Sucre
  { match: "#ProperNoun (de|du) la? #ProperNoun", tag: "Person", notIf: "#Place", reason: "title-de-title" },
  //Jani K. Smith
  { match: "#Singular #Acronym #LastName", tag: "#FirstName #Person .", reason: "title-acro-noun", safe: true },
  //Foo Ford
  { match: "[#ProperNoun] #Person", group: 0, tag: "Person", reason: "proper-person", safe: true },
  // john keith jones
  {
    match: "#Person [#ProperNoun #ProperNoun]",
    group: 0,
    tag: "Person",
    notIf: "#Possessive",
    reason: "three-name-person",
    safe: true
  },
  //John Foo
  {
    match: "#FirstName #Acronym? [#ProperNoun]",
    group: 0,
    tag: "LastName",
    notIf: "#Possessive",
    reason: "firstname-titlecase"
  },
  // john stewart
  { match: "#FirstName [#FirstName]", group: 0, tag: "LastName", reason: "firstname-firstname" },
  //Joe K. Sombrero
  { match: "#FirstName #Acronym #Noun", tag: "Person", reason: "n-acro-noun", safe: true },
  //Anthony de Marco
  { match: "#FirstName [(de|di|du|van|von)] #Person", group: 0, tag: "LastName", reason: "de-firstname" },
  // baker jenna smith
  // { match: '[#Actor+] #Person', group: 0, tag: 'Person', reason: 'baker-sam-smith' },
  // sergeant major Harold
  {
    match: "[(lieutenant|corporal|sergeant|captain|qeen|king|admiral|major|colonel|marshal|president|queen|king)+] #ProperNoun",
    group: 0,
    tag: "Honorific",
    reason: "seargeant-john"
  },
  // ==== Honorics ====
  {
    match: "[(private|general|major|rear|prime|field|count|miss)] #Honorific? #Person",
    group: 0,
    tag: ["Honorific", "Person"],
    reason: "ambg-honorifics"
  },
  // dr john foobar
  {
    match: "#Honorific #FirstName [#Singular]",
    group: 0,
    tag: "LastName",
    notIf: "#Possessive",
    reason: "dr-john-foo",
    safe: true
  },
  //his-excellency
  {
    match: "[(his|her) (majesty|honour|worship|excellency|honorable)] #Person",
    group: 0,
    tag: "Honorific",
    reason: "his-excellency"
  },
  // Lieutenant colonel
  { match: "#Honorific #Actor", tag: "Honorific", reason: "Lieutenant colonel" },
  // first lady, second admiral
  { match: "(first|second|third|1st|2nd|3rd) #Actor", tag: "Honorific", reason: "first lady" },
  // Louis IV
  { match: "#Person #RomanNumeral", tag: "Person", reason: "louis-IV" }
];

// node_modules/compromise/src/2-two/postTagger/model/person/ambig-name.js
var ambig_name_default = [
  // ebenezer scrooge
  {
    match: "#FirstName #Noun$",
    tag: ". #LastName",
    notIf: "(#Possessive|#Organization|#Place|#Pronoun|@hasTitleCase)",
    reason: "firstname-noun"
  },
  // ===person-date===
  { match: "%Person|Date% #Acronym? #ProperNoun", tag: "Person", reason: "jan-thierson" },
  // ===person-noun===
  //Cliff Clavin
  { match: "%Person|Noun% #Acronym? #ProperNoun", tag: "Person", reason: "switch-person", safe: true },
  // olive garden
  { match: "%Person|Noun% #Organization", tag: "Organization", reason: "olive-garden" },
  // ===person-verb===
  // ollie faroo
  { match: "%Person|Verb% #Acronym? #ProperNoun", tag: "Person", reason: "verb-propernoun", ifNo: "#Actor" },
  // chuck will ...
  {
    match: `[%Person|Verb%] (will|had|has|said|says|told|did|learned|wants|wanted)`,
    group: 0,
    tag: "Person",
    reason: "person-said"
  },
  // ===person-place===
  //sydney harbour
  {
    match: `[%Person|Place%] (harbor|harbour|pier|town|city|place|dump|landfill)`,
    group: 0,
    tag: "Place",
    reason: "sydney-harbour"
  },
  // east sydney
  { match: `(west|east|north|south) [%Person|Place%]`, group: 0, tag: "Place", reason: "east-sydney" },
  // ===person-adjective===
  // rusty smith
  // { match: `${personAdj} #Person`, tag: 'Person', reason: 'randy-smith' },
  // rusty a. smith
  // { match: `${personAdj} #Acronym? #ProperNoun`, tag: 'Person', reason: 'rusty-smith' },
  // very rusty
  // { match: `#Adverb [${personAdj}]`, group: 0, tag: 'Adjective', reason: 'really-rich' },
  // ===person-verb===
  // would wade
  { match: `#Modal [%Person|Verb%]`, group: 0, tag: "Verb", reason: "would-mark" },
  // really wade
  { match: `#Adverb [%Person|Verb%]`, group: 0, tag: "Verb", reason: "really-mark" },
  // drew closer
  { match: `[%Person|Verb%] (#Adverb|#Comparative)`, group: 0, tag: "Verb", reason: "drew-closer" },
  // wade smith
  { match: `%Person|Verb% #Person`, tag: "Person", reason: "rob-smith" },
  // wade m. Cooper
  { match: `%Person|Verb% #Acronym #ProperNoun`, tag: "Person", reason: "rob-a-smith" },
  // will go
  { match: "[will] #Verb", group: 0, tag: "Modal", reason: "will-verb" },
  // will Pharell
  { match: "(will && @isTitleCase) #ProperNoun", tag: "Person", reason: "will-name" },
  // jack layton won
  {
    match: "(#FirstName && !#Possessive) [#Singular] #Verb",
    group: 0,
    safe: true,
    tag: "LastName",
    reason: "jack-layton"
  },
  // sherwood anderson told
  { match: "^[#Singular] #Person #Verb", group: 0, safe: true, tag: "Person", reason: "sherwood-anderson" },
  // bought a warhol
  { match: "(a|an) [#Person]$", group: 0, unTag: "Person", reason: "a-warhol" }
];

// node_modules/compromise/src/2-two/postTagger/model/verbs/verbs.js
var verbs_default3 = [
  //sometimes adverbs - 'pretty good','well above'
  {
    match: "#Copula (pretty|dead|full|well|sure) (#Adjective|#Noun)",
    tag: "#Copula #Adverb #Adjective",
    reason: "sometimes-adverb"
  },
  //i better ..
  { match: "(#Pronoun|#Person) (had|#Adverb)? [better] #PresentTense", group: 0, tag: "Modal", reason: "i-better" },
  // adj -> gerund
  // like
  { match: "(#Modal|i|they|we|do) not? [like]", group: 0, tag: "PresentTense", reason: "modal-like" },
  // ==== Tense ====
  //he left
  { match: "#Noun #Adverb? [left]", group: 0, tag: "PastTense", reason: "left-verb" },
  // ==== Copula ====
  //will be running (not copula)
  { match: "will #Adverb? not? #Adverb? [be] #Gerund", group: 0, tag: "Copula", reason: "will-be-copula" },
  //for more complex forms, just tag 'be'
  { match: "will #Adverb? not? #Adverb? [be] #Adjective", group: 0, tag: "Copula", reason: "be-copula" },
  // ==== Infinitive ====
  //march to
  { match: "[march] (up|down|back|toward)", notIf: "#Date", group: 0, tag: "Infinitive", reason: "march-to" },
  //must march
  { match: "#Modal [march]", group: 0, tag: "Infinitive", reason: "must-march" },
  // may be
  { match: `[may] be`, group: 0, tag: "Verb", reason: "may-be" },
  // subject to
  { match: `[(subject|subjects|subjected)] to`, group: 0, tag: "Verb", reason: "subject to" },
  // subject to
  { match: `[home] to`, group: 0, tag: "PresentTense", reason: "home to" },
  // === misc==
  // side with
  // { match: '[(side|fool|monkey)] with', group: 0, tag: 'Infinitive', reason: 'fool-with' },
  // open the door
  { match: "[open] #Determiner", group: 0, tag: "Infinitive", reason: "open-the" },
  //were being run
  { match: `(were|was) being [#PresentTense]`, group: 0, tag: "PastTense", reason: "was-being" },
  //had been broken
  { match: `(had|has|have) [been /en$/]`, group: 0, tag: "Auxiliary Participle", reason: "had-been-broken" },
  //had been smoked
  { match: `(had|has|have) [been /ed$/]`, group: 0, tag: "Auxiliary PastTense", reason: "had-been-smoked" },
  //were being run
  { match: `(had|has) #Adverb? [been] #Adverb? #PastTense`, group: 0, tag: "Auxiliary", reason: "had-been-adj" },
  //had to walk
  { match: `(had|has) to [#Noun] (#Determiner|#Possessive)`, group: 0, tag: "Infinitive", reason: "had-to-noun" },
  // have read
  { match: `have [#PresentTense]`, group: 0, tag: "PastTense", notIf: "(come|gotten)", reason: "have-read" },
  // does that work
  { match: `(does|will|#Modal) that [work]`, group: 0, tag: "PastTense", reason: "does-that-work" },
  // sounds fun
  { match: `[(sound|sounds)] #Adjective`, group: 0, tag: "PresentTense", reason: "sounds-fun" },
  // look good
  { match: `[(look|looks)] #Adjective`, group: 0, tag: "PresentTense", reason: "looks-good" },
  // stops thinking
  { match: `[(start|starts|stop|stops|begin|begins)] #Gerund`, group: 0, tag: "Verb", reason: "starts-thinking" },
  // have read
  { match: `(have|had) read`, tag: "Modal #PastTense", reason: "read-read" },
  //were under cooked
  {
    match: `(is|was|were) [(under|over) #PastTense]`,
    group: 0,
    tag: "Adverb Adjective",
    reason: "was-under-cooked"
  },
  // damn them
  { match: "[shit] (#Determiner|#Possessive|them)", group: 0, tag: "Verb", reason: "swear1-verb" },
  { match: "[damn] (#Determiner|#Possessive|them)", group: 0, tag: "Verb", reason: "swear2-verb" },
  { match: "[fuck] (#Determiner|#Possessive|them)", group: 0, tag: "Verb", reason: "swear3-verb" },
  // jobs that fit
  { match: "#Plural that %Noun|Verb%", tag: ". #Preposition #Infinitive", reason: "jobs-that-work" },
  // works for me
  { match: "[works] for me", group: 0, tag: "PresentTense", reason: "works-for-me" },
  // as we please
  { match: "as #Pronoun [please]", group: 0, tag: "Infinitive", reason: "as-we-please" },
  // verb-prefixes - 'co write'
  { match: "[(co|mis|de|inter|intra|pre|re|un|out|under|over|counter)] #Verb", group: 0, tag: ["Verb", "Prefix"], notIf: "(#Copula|#PhrasalVerb)", reason: "co-write" },
  // dressed and left
  { match: "#PastTense and [%Adj|Past%]", group: 0, tag: "PastTense", reason: "dressed-and-left" },
  // melted and fallen
  { match: "[%Adj|Past%] and #PastTense", group: 0, tag: "PastTense", reason: "dressed-and-left" },
  // is he stoked
  { match: "#Copula #Pronoun [%Adj|Past%]", group: 0, tag: "Adjective", reason: "is-he-stoked" },
  // to dream of
  { match: "to [%Noun|Verb%] #Preposition", group: 0, tag: "Infinitive", reason: "to-dream-of" }
];

// node_modules/compromise/src/2-two/postTagger/model/verbs/auxiliary.js
var auxiliary_default = [
  // ==== Auxiliary ====
  // have been
  { match: `will (#Adverb|not)+? [have] (#Adverb|not)+? #Verb`, group: 0, tag: "Auxiliary", reason: "will-have-vb" },
  //was walking
  { match: `[#Copula] (#Adverb|not)+? (#Gerund|#PastTense)`, group: 0, tag: "Auxiliary", reason: "copula-walking" },
  //would walk
  { match: `[(#Modal|did)+] (#Adverb|not)+? #Verb`, group: 0, tag: "Auxiliary", reason: "modal-verb" },
  //would have had
  { match: `#Modal (#Adverb|not)+? [have] (#Adverb|not)+? [had] (#Adverb|not)+? #Verb`, group: 0, tag: "Auxiliary", reason: "would-have" },
  //support a splattering of auxillaries before a verb
  { match: `[(has|had)] (#Adverb|not)+? #PastTense`, group: 0, tag: "Auxiliary", reason: "had-walked" },
  // will walk
  { match: "[(do|does|did|will|have|had|has|got)] (not|#Adverb)+? #Verb", group: 0, tag: "Auxiliary", reason: "have-had" },
  // about to go
  { match: "[about to] #Adverb? #Verb", group: 0, tag: ["Auxiliary", "Verb"], reason: "about-to" },
  //would be walking
  { match: `#Modal (#Adverb|not)+? [be] (#Adverb|not)+? #Verb`, group: 0, tag: "Auxiliary", reason: "would-be" },
  //had been walking
  { match: `[(#Modal|had|has)] (#Adverb|not)+? [been] (#Adverb|not)+? #Verb`, group: 0, tag: "Auxiliary", reason: "had-been" },
  // was being driven
  { match: "[(be|being|been)] #Participle", group: 0, tag: "Auxiliary", reason: "being-driven" },
  // may want
  { match: "[may] #Adverb? #Infinitive", group: 0, tag: "Auxiliary", reason: "may-want" },
  // was being walked
  { match: "#Copula (#Adverb|not)+? [(be|being|been)] #Adverb+? #PastTense", group: 0, tag: "Auxiliary", reason: "being-walked" },
  // will be walked
  { match: "will [be] #PastTense", group: 0, tag: "Auxiliary", reason: "will-be-x" },
  // been walking
  { match: "[(be|been)] (#Adverb|not)+? #Gerund", group: 0, tag: "Auxiliary", reason: "been-walking" },
  // used to walk
  { match: "[used to] #PresentTense", group: 0, tag: "Auxiliary", reason: "used-to-walk" },
  // was going to walk
  { match: "#Copula (#Adverb|not)+? [going to] #Adverb+? #PresentTense", group: 0, tag: "Auxiliary", reason: "going-to-walk" },
  // tell me
  { match: "#Imperative [(me|him|her)]", group: 0, tag: "Reflexive", reason: "tell-him" },
  // there is no x
  { match: "(is|was) #Adverb? [no]", group: 0, tag: "Negative", reason: "is-no" },
  // been told
  { match: "[(been|had|became|came)] #PastTense", group: 0, notIf: "#PhrasalVerb", tag: "Auxiliary", reason: "been-told" },
  // being born
  { match: "[(being|having|getting)] #Verb", group: 0, tag: "Auxiliary", reason: "being-born" },
  // be walking
  { match: "[be] #Gerund", group: 0, tag: "Auxiliary", reason: "be-walking" },
  // better go
  { match: "[better] #PresentTense", group: 0, tag: "Modal", notIf: "(#Copula|#Gerund)", reason: "better-go" },
  // even better
  { match: "even better", tag: "Adverb #Comparative", reason: "even-better" }
];

// node_modules/compromise/src/2-two/postTagger/model/verbs/phrasal.js
var phrasal_default = [
  // ==== Phrasal ====
  //'foo-up'
  { match: "(#Verb && @hasHyphen) up", tag: "PhrasalVerb", reason: "foo-up" },
  { match: "(#Verb && @hasHyphen) off", tag: "PhrasalVerb", reason: "foo-off" },
  { match: "(#Verb && @hasHyphen) over", tag: "PhrasalVerb", reason: "foo-over" },
  { match: "(#Verb && @hasHyphen) out", tag: "PhrasalVerb", reason: "foo-out" },
  // walk in on
  {
    match: "[#Verb (in|out|up|down|off|back)] (on|in)",
    notIf: "#Copula",
    tag: "PhrasalVerb Particle",
    reason: "walk-in-on"
  },
  // went on for
  { match: "(lived|went|crept|go) [on] for", group: 0, tag: "PhrasalVerb", reason: "went-on" },
  // the curtains come down
  { match: "#Verb (up|down|in|on|for)$", tag: "PhrasalVerb #Particle", notIf: "#PhrasalVerb", reason: "come-down$" },
  // got me thinking
  // { match: '(got|had) me [#Noun]', group: 0, tag: 'Verb', reason: 'got-me-gerund' },
  // help stop
  { match: "help [(stop|end|make|start)]", group: 0, tag: "Infinitive", reason: "help-stop" },
  // work in the office
  { match: "#PhrasalVerb (in && #Particle) #Determiner", tag: "#Verb #Preposition #Determiner", unTag: "PhrasalVerb", reason: "work-in-the" },
  // start listening
  { match: "[(stop|start|finish|help)] #Gerund", group: 0, tag: "Infinitive", reason: "start-listening" },
  // mis-fired
  // { match: '[(mis)] #Verb', group: 0, tag: 'Verb', reason: 'mis-firedsa' },
  //back it up
  {
    match: "#Verb (him|her|it|us|himself|herself|itself|everything|something) [(up|down)]",
    group: 0,
    tag: "Adverb",
    reason: "phrasal-pronoun-advb"
  }
];

// node_modules/compromise/src/2-two/postTagger/model/verbs/imperative.js
var notIf2 = "(i|we|they)";
var imperative_default2 = [
  // do not go
  { match: "^do not? [#Infinitive #Particle?]", notIf: notIf2, group: 0, tag: "Imperative", reason: "do-eat" },
  // please go
  { match: "^please do? not? [#Infinitive #Particle?]", group: 0, tag: "Imperative", reason: "please-go" },
  // just go
  { match: "^just do? not? [#Infinitive #Particle?]", group: 0, tag: "Imperative", reason: "just-go" },
  // do it better
  { match: "^[#Infinitive] it #Comparative", notIf: notIf2, group: 0, tag: "Imperative", reason: "do-it-better" },
  // do it again
  { match: "^[#Infinitive] it (please|now|again|plz)", notIf: notIf2, group: 0, tag: "Imperative", reason: "do-it-please" },
  // go quickly.
  { match: "^[#Infinitive] (#Adjective|#Adverb)$", group: 0, tag: "Imperative", notIf: "(so|such|rather|enough)", reason: "go-quickly" },
  // turn down the noise
  { match: "^[#Infinitive] (up|down|over) #Determiner", group: 0, tag: "Imperative", reason: "turn-down" },
  // eat my shorts
  { match: "^[#Infinitive] (your|my|the|a|an|any|each|every|some|more|with|on)", group: 0, notIf: "like", tag: "Imperative", reason: "eat-my-shorts" },
  // tell him the story
  { match: "^[#Infinitive] (him|her|it|us|me|there)", group: 0, tag: "Imperative", reason: "tell-him" },
  // avoid loud noises
  { match: "^[#Infinitive] #Adjective #Noun$", group: 0, tag: "Imperative", reason: "avoid-loud-noises" },
  // call and reserve
  { match: "^[#Infinitive] (#Adjective|#Adverb)? and #Infinitive", group: 0, tag: "Imperative", reason: "call-and-reserve" },
  // one-word imperatives
  { match: "^(go|stop|wait|hurry) please?$", tag: "Imperative", reason: "go" },
  // somebody call
  { match: "^(somebody|everybody) [#Infinitive]", group: 0, tag: "Imperative", reason: "somebody-call" },
  // let's leave
  { match: "^let (us|me) [#Infinitive]", group: 0, tag: "Imperative", reason: "lets-leave" },
  // shut the door
  { match: "^[(shut|close|open|start|stop|end|keep)] #Determiner #Noun", group: 0, tag: "Imperative", reason: "shut-the-door" },
  // turn off the light
  { match: "^[#PhrasalVerb #Particle] #Determiner #Noun", group: 0, tag: "Imperative", reason: "turn-off-the-light" },
  // go to toronto
  { match: "^[go] to .", group: 0, tag: "Imperative", reason: "go-to-toronto" },
  // would you recommend
  { match: "^#Modal you [#Infinitive]", group: 0, tag: "Imperative", reason: "would-you-" },
  // never say
  { match: "^never [#Infinitive]", group: 0, tag: "Imperative", reason: "never-stop" },
  // come have a drink
  { match: "^come #Infinitive", tag: "Imperative", notIf: "on", reason: "come-have" },
  // come and have a drink
  { match: "^come and? #Infinitive", tag: "Imperative . Imperative", notIf: "#PhrasalVerb", reason: "come-and-have" },
  // stay away
  { match: "^stay (out|away|back)", tag: "Imperative", reason: "stay-away" },
  // stay cool
  { match: "^[(stay|be|keep)] #Adjective", group: 0, tag: "Imperative", reason: "stay-cool" },
  // keep it silent
  { match: "^[keep it] #Adjective", group: 0, tag: "Imperative", reason: "keep-it-cool" },
  // don't be late
  { match: "^do not [#Infinitive]", group: 0, tag: "Imperative", reason: "do-not-be" },
  // allow yourself
  { match: "[#Infinitive] (yourself|yourselves)", group: 0, tag: "Imperative", reason: "allow-yourself" },
  // look what
  { match: "[#Infinitive] what .", group: 0, tag: "Imperative", reason: "look-what" },
  // continue playing
  { match: "^[#Infinitive] #Gerund", group: 0, tag: "Imperative", reason: "keep-playing" },
  // go to it
  { match: "^[#Infinitive] (to|for|into|toward|here|there)", group: 0, tag: "Imperative", reason: "go-to" },
  // relax and unwind
  { match: "^[#Infinitive] (and|or) #Infinitive", group: 0, tag: "Imperative", reason: "inf-and-inf" },
  // commit to
  { match: "^[%Noun|Verb%] to", group: 0, tag: "Imperative", reason: "commit-to" },
  // maintain eye contact
  { match: "^[#Infinitive] #Adjective? #Singular #Singular", group: 0, tag: "Imperative", reason: "maintain-eye-contact" },
  // don't forget to clean
  { match: "do not (forget|omit|neglect) to [#Infinitive]", group: 0, tag: "Imperative", reason: "do-not-forget" },
  // pay attention
  { match: "^[(ask|wear|pay|look|help|show|watch|act|fix|kill|stop|start|turn|try|win)] #Noun", group: 0, tag: "Imperative", reason: "pay-attention" }
];

// node_modules/compromise/src/2-two/postTagger/model/verbs/adj-gerund.js
var adj_gerund_default3 = [
  // that were growing
  { match: "(that|which) were [%Adj|Gerund%]", group: 0, tag: "Gerund", reason: "that-were-growing" },
  // was dissapointing
  // { match: '#Copula [%Adj|Gerund%]$', group: 0, tag: 'Adjective', reason: 'was-disappointing$' },
  // repairing crubling roads
  { match: "#Gerund [#Gerund] #Plural", group: 0, tag: "Adjective", reason: "hard-working-fam" }
  // { match: '(that|which) were [%Adj|Gerund%]', group: 0, tag: 'Gerund', reason: 'that-were-growing' },
];

// node_modules/compromise/src/2-two/postTagger/model/verbs/passive.js
var passive_default = [
  // got walked, was walked, were walked
  { match: "(got|were|was|is|are|am) (#PastTense|#Participle)", tag: "Passive", reason: "got-walked" },
  // was being walked
  { match: "(was|were|is|are|am) being (#PastTense|#Participle)", tag: "Passive", reason: "was-being" },
  // had been walked, have been eaten
  { match: "(had|have|has) been (#PastTense|#Participle)", tag: "Passive", reason: "had-been" },
  // will be cleaned
  { match: "will be being? (#PastTense|#Participle)", tag: "Passive", reason: "will-be-cleaned" },
  // suffered by the country
  { match: "#Noun [(#PastTense|#Participle)] by (the|a) #Noun", group: 0, tag: "Passive", reason: "suffered-by" }
];

// node_modules/compromise/src/2-two/postTagger/model/_misc.js
var matches = [
  // u r cool
  { match: "u r", tag: "#Pronoun #Copula", reason: "u r" },
  { match: "#Noun [(who|whom)]", group: 0, tag: "Determiner", reason: "captain-who" },
  // ==== Conditions ====
  // had he survived,
  { match: "[had] #Noun+ #PastTense", group: 0, tag: "Condition", reason: "had-he" },
  // were he to survive
  { match: "[were] #Noun+ to #Infinitive", group: 0, tag: "Condition", reason: "were-he" },
  // some sort of
  { match: "some sort of", tag: "Adjective Noun Conjunction", reason: "some-sort-of" },
  // some of
  // { match: 'some of', tag: 'Noun Conjunction', reason: 'some-of' },
  // of some sort
  { match: "of some sort", tag: "Conjunction Adjective Noun", reason: "of-some-sort" },
  // such skill
  { match: "[such] (a|an|is)? #Noun", group: 0, tag: "Determiner", reason: "such-skill" },
  // another one
  // { match: '[another] (#Noun|#Value)', group: 0, tag: 'Adjective', reason: 'another-one' },
  // right after
  { match: "[right] (before|after|in|into|to|toward)", group: 0, tag: "#Adverb", reason: "right-into" },
  // at about
  { match: "#Preposition [about]", group: 0, tag: "Adjective", reason: "at-about" },
  // are ya
  { match: "(are|#Modal|see|do|for) [ya]", group: 0, tag: "Pronoun", reason: "are-ya" },
  // long live
  { match: "[long live] .", group: 0, tag: "#Adjective #Infinitive", reason: "long-live" },
  // plenty of
  { match: "[plenty] of", group: 0, tag: "#Uncountable", reason: "plenty-of" },
  // 'there' as adjective
  { match: "(always|nearly|barely|practically) [there]", group: 0, tag: "Adjective", reason: "always-there" },
  // existential 'there'
  // there she is
  { match: "[there] (#Adverb|#Pronoun)? #Copula", group: 0, tag: "There", reason: "there-is" },
  // is there food
  { match: "#Copula [there] .", group: 0, tag: "There", reason: "is-there" },
  // should there
  { match: "#Modal #Adverb? [there]", group: 0, tag: "There", reason: "should-there" },
  // do you
  { match: "^[do] (you|we|they)", group: 0, tag: "QuestionWord", reason: "do-you" },
  // does he
  { match: "^[does] (he|she|it|#ProperNoun)", group: 0, tag: "QuestionWord", reason: "does-he" },
  // the person who
  { match: "#Determiner #Noun+ [who] #Verb", group: 0, tag: "Preposition", reason: "the-x-who" },
  // the person which
  { match: "#Determiner #Noun+ [which] #Verb", group: 0, tag: "Preposition", reason: "the-x-which" },
  // a while
  { match: "a [while]", group: 0, tag: "Noun", reason: "a-while" },
  // guess who
  { match: "guess who", tag: "#Infinitive #QuestionWord", reason: "guess-who" },
  // swear words
  { match: "[fucking] !#Verb", group: 0, tag: "#Gerund", reason: "f-as-gerund" }
];
var misc_default4 = matches;

// node_modules/compromise/src/2-two/postTagger/model/nouns/organizations.js
var organizations_default2 = [
  // Foo University
  // { match: `#Noun ${orgMap}`, tag: 'Organization', safe: true, reason: 'foo-university' },
  // // University of Toronto
  // { match: `${orgMap} of #Place`, tag: 'Organization', safe: true, reason: 'university-of-foo' },
  // // foo regional health authority
  // { match: `${orgMap} (health|local|regional)+ authority`, tag: 'Organization', reason: 'regional-health' },
  // // foo stock exchange
  // { match: `${orgMap} (stock|mergantile)+ exchange`, tag: 'Organization', reason: 'stock-exchange' },
  // // foo news service
  // { match: `${orgMap} (daily|evening|local)+ news service?`, tag: 'Organization', reason: 'foo-news' },
  //University of Foo
  { match: "university of #Place", tag: "Organization", reason: "university-of-Foo" },
  //John & Joe's
  { match: "#Noun (&|n) #Noun", tag: "Organization", reason: "Noun-&-Noun" },
  // teachers union of Ontario
  { match: "#Organization of the? #ProperNoun", tag: "Organization", reason: "org-of-place", safe: true },
  //walmart USA
  { match: "#Organization #Country", tag: "Organization", reason: "org-country" },
  //organization
  { match: "#ProperNoun #Organization", tag: "Organization", notIf: "#FirstName", reason: "titlecase-org" },
  //FitBit Inc
  { match: "#ProperNoun (ltd|co|inc|dept|assn|bros)", tag: "Organization", reason: "org-abbrv" },
  // the OCED
  { match: "the [#Acronym]", group: 0, tag: "Organization", reason: "the-acronym", safe: true },
  // government of india
  { match: "government of the? [#Place+]", tag: "Organization", reason: "government-of-x" },
  // school board
  { match: "(health|school|commerce) board", tag: "Organization", reason: "school-board" },
  // special comittee
  {
    match: "(nominating|special|conference|executive|steering|central|congressional) committee",
    tag: "Organization",
    reason: "special-comittee"
  },
  // global trade union
  {
    match: "(world|global|international|national|#Demonym) #Organization",
    tag: "Organization",
    reason: "global-org"
  },
  // schools
  { match: "#Noun+ (public|private) school", tag: "School", reason: "noun-public-school" },
  // new york yankees
  { match: "#Place+ #SportsTeam", tag: "SportsTeam", reason: "place-sportsteam" },
  // 'manchester united'
  {
    match: "(dc|atlanta|minnesota|manchester|newcastle|sheffield) united",
    tag: "SportsTeam",
    reason: "united-sportsteam"
  },
  // 'toronto fc'
  { match: "#Place+ fc", tag: "SportsTeam", reason: "fc-sportsteam" },
  // baltimore quilting club
  {
    match: "#Place+ #Noun{0,2} (club|society|group|team|committee|commission|association|guild|crew)",
    tag: "Organization",
    reason: "place-noun-society"
  }
];

// node_modules/compromise/src/2-two/postTagger/model/nouns/places.js
var places_default2 = [
  // ==== Region ====
  // West Norforlk
  { match: "(west|north|south|east|western|northern|southern|eastern)+ #Place", tag: "Region", reason: "west-norfolk" },
  //some us-state acronyms (exlude: al, in, la, mo, hi, me, md, ok..)
  {
    match: "#City [(al|ak|az|ar|ca|ct|dc|fl|ga|id|il|nv|nh|nj|ny|oh|pa|sc|tn|tx|ut|vt|pr)]",
    group: 0,
    tag: "Region",
    reason: "us-state"
  },
  // portland oregon
  { match: "portland [or]", group: 0, tag: "Region", reason: "portland-or" },
  //words removed from preTagger/placeWords
  {
    match: "#ProperNoun+ (cliff|place|range|pit|place|point|room|grounds|ruins)",
    tag: "Place",
    reason: "foo-point"
  },
  // in Foo California
  { match: "in [#ProperNoun] #Place", group: 0, tag: "Place", reason: "propernoun-place" },
  // Address
  {
    match: "#Value #Noun (st|street|rd|road|crescent|cr|way|tr|terrace|avenue|ave)",
    tag: "Address",
    reason: "address-st"
  },
  // port dover
  { match: "(port|mount|mt) #ProperName", tag: "Place", reason: "port-name" }
  // generic 'oak ridge' names
  // { match: '(oak|maple|spruce|pine|cedar|willow|green|sunset|sunrise) #Place', tag: 'Place', reason: 'tree-name' },
  // generic 'sunset view' names
  // { match: '() #Place', tag: 'Place', reason: 'tree-name' },
  // Sports Arenas and Complexs
  // {
  //   match:
  //     '(#Place+|#Place|#ProperNoun) (memorial|athletic|community|financial)? (sportsplex|stadium|sports centre|sports field|soccer complex|soccer centre|sports complex|civic centre|centre|arena|gardens|complex|coliseum|auditorium|place|building)',
  //   tag: 'Place',
  //   reason: 'sport-complex',
  // },
];

// node_modules/compromise/src/2-two/postTagger/model/conjunctions.js
var conjunctions_default = [
  // ==== Conjunctions ====
  { match: "[so] #Noun", group: 0, tag: "Conjunction", reason: "so-conj" },
  //how he is driving
  {
    match: "[(who|what|where|why|how|when)] #Noun #Copula #Adverb? (#Verb|#Adjective)",
    group: 0,
    tag: "Conjunction",
    reason: "how-he-is-x"
  },
  // when he
  { match: "#Copula [(who|what|where|why|how|when)] #Noun", group: 0, tag: "Conjunction", reason: "when-he" },
  // says that he..
  { match: "#Verb [that] #Pronoun", group: 0, tag: "Conjunction", reason: "said-that-he" },
  // things that are required
  { match: "#Noun [that] #Copula", group: 0, tag: "Conjunction", reason: "that-are" },
  // things that seem cool
  { match: "#Noun [that] #Verb #Adjective", group: 0, tag: "Conjunction", reason: "that-seem" },
  // wasn't that wide..
  { match: "#Noun #Copula not? [that] #Adjective", group: 0, tag: "Adverb", reason: "that-adj" },
  // ==== Prepositions ====
  //all students
  { match: "#Verb #Adverb? #Noun [(that|which)]", group: 0, tag: "Preposition", reason: "that-prep" },
  //work, which has been done.
  { match: "@hasComma [which] (#Pronoun|#Verb)", group: 0, tag: "Preposition", reason: "which-copula" },
  //folks like her
  { match: "#Noun [like] #Noun", group: 0, tag: "Preposition", reason: "noun-like" },
  //like the time
  { match: "^[like] #Determiner", group: 0, tag: "Preposition", reason: "like-the" },
  //a day like this
  { match: "a #Noun [like] (#Noun|#Determiner)", group: 0, tag: "Preposition", reason: "a-noun-like" },
  // really like
  { match: "#Adverb [like]", group: 0, tag: "Verb", reason: "really-like" },
  // nothing like
  { match: "(not|nothing|never) [like]", group: 0, tag: "Preposition", reason: "nothing-like" },
  // treat them like
  { match: "#Infinitive #Pronoun [like]", group: 0, tag: "Preposition", reason: "treat-them-like" },
  // ==== Questions ====
  // where
  // why
  // when
  // who
  // whom
  // whose
  // what
  // which
  //the word 'how many'
  // { match: '^(how|which)', tag: 'QuestionWord', reason: 'how-question' },
  // how-he, when the
  { match: "[#QuestionWord] (#Pronoun|#Determiner)", group: 0, tag: "Preposition", reason: "how-he" },
  // when stolen
  { match: "[#QuestionWord] #Participle", group: 0, tag: "Preposition", reason: "when-stolen" },
  // how is
  { match: "[how] (#Determiner|#Copula|#Modal|#PastTense)", group: 0, tag: "QuestionWord", reason: "how-is" },
  // children who dance
  { match: "#Plural [(who|which|when)] .", group: 0, tag: "Preposition", reason: "people-who" }
];

// node_modules/compromise/src/2-two/postTagger/model/expressions.js
var expressions_default = [
  //swear-words as non-expression POS
  { match: "holy (shit|fuck|hell)", tag: "Expression", reason: "swears-expression" },
  // well..
  { match: "^[(well|so|okay|now)] !#Adjective?", group: 0, tag: "Expression", reason: "well-" },
  // well..
  { match: "^come on", tag: "Expression", reason: "come-on" },
  // sorry
  { match: "(say|says|said) [sorry]", group: 0, tag: "Expression", reason: "say-sorry" },
  // ok,
  { match: "^(ok|alright|shoot|hell|anyways)", tag: "Expression", reason: "ok-" },
  // c'mon marge..
  // { match: '^[come on] #Noun', group: 0, tag: 'Expression', reason: 'come-on' },
  // say,
  { match: "^(say && @hasComma)", tag: "Expression", reason: "say-" },
  { match: "^(like && @hasComma)", tag: "Expression", reason: "like-" },
  // dude we should
  { match: "^[(dude|man|girl)] #Pronoun", group: 0, tag: "Expression", reason: "dude-i" }
];

// node_modules/compromise/src/2-two/postTagger/model/index.js
var matches2 = [].concat(
  // order matters top-matches can get overwritten
  passive_default,
  adjective_default,
  adj_adverb_default,
  adj_gerund_default2,
  adj_noun_default2,
  adverb_default,
  date_default,
  date_phrase_default,
  nouns_default4,
  noun_gerund_default2,
  verb_noun_default,
  money_default,
  fractions_default,
  numbers_default,
  person_phrase_default,
  ambig_name_default,
  verbs_default3,
  adj_verb_default,
  auxiliary_default,
  phrasal_default,
  imperative_default2,
  adj_gerund_default3,
  misc_default4,
  organizations_default2,
  places_default2,
  conjunctions_default,
  expressions_default
);
var model_default4 = {
  two: {
    matches: matches2
  }
};

// node_modules/compromise/src/2-two/postTagger/compute/index.js
var net = null;
var postTagger = function(view) {
  const { world: world2 } = view;
  const { model: model5, methods: methods17 } = world2;
  net = net || methods17.one.buildNet(model5.two.matches, world2);
  let document2 = methods17.two.quickSplit(view.document);
  let ptrs = document2.map((terms) => {
    let t3 = terms[0];
    return [t3.index[0], t3.index[1], t3.index[1] + terms.length];
  });
  let m3 = view.update(ptrs);
  m3.cache();
  m3.sweep(net);
  view.uncache();
  view.unfreeze();
  return view;
};
var tagger2 = (view) => view.compute(["freeze", "lexicon", "preTagger", "postTagger", "unfreeze"]);
var compute_default11 = { postTagger, tagger: tagger2 };

// node_modules/compromise/src/2-two/postTagger/api.js
var round = (n3) => Math.round(n3 * 100) / 100;
function api_default11(View2) {
  View2.prototype.confidence = function() {
    let sum = 0;
    let count = 0;
    this.docs.forEach((terms) => {
      terms.forEach((term) => {
        count += 1;
        sum += term.confidence || 1;
      });
    });
    if (count === 0) {
      return 1;
    }
    return round(sum / count);
  };
  View2.prototype.tagger = function() {
    return this.compute(["tagger"]);
  };
}

// node_modules/compromise/src/2-two/postTagger/plugin.js
var plugin2 = {
  api: api_default11,
  compute: compute_default11,
  model: model_default4,
  hooks: ["postTagger"]
};
var plugin_default16 = plugin2;

// node_modules/compromise/src/2-two/lazy/maybeMatch.js
var getWords = function(net3) {
  return Object.keys(net3.hooks).filter((w) => !w.startsWith("#") && !w.startsWith("%"));
};
var maybeMatch = function(doc, net3) {
  let words = getWords(net3);
  if (words.length === 0) {
    return doc;
  }
  if (!doc._cache) {
    doc.cache();
  }
  let cache2 = doc._cache;
  return doc.filter((_m, i3) => {
    return words.some((str) => cache2[i3].has(str));
  });
};
var maybeMatch_default = maybeMatch;

// node_modules/compromise/src/2-two/lazy/lazyParse.js
var lazyParse = function(input, reg) {
  let net3 = reg;
  if (typeof reg === "string") {
    net3 = this.buildNet([{ match: reg }]);
  }
  let doc = this.tokenize(input);
  let m3 = maybeMatch_default(doc, net3);
  if (m3.found) {
    m3.compute(["index", "tagger"]);
    return m3.match(reg);
  }
  return doc.none();
};
var lazyParse_default = lazyParse;

// node_modules/compromise/src/2-two/lazy/plugin.js
var plugin_default17 = {
  lib: {
    lazy: lazyParse_default
  }
};

// node_modules/compromise/src/2-two/swap/api/swap-verb.js
var matchVerb = function(m3, lemma) {
  const conjugate2 = m3.methods.two.transform.verb.conjugate;
  let all4 = conjugate2(lemma, m3.model);
  if (m3.has("#Gerund")) {
    return all4.Gerund;
  }
  if (m3.has("#PastTense")) {
    return all4.PastTense;
  }
  if (m3.has("#PresentTense")) {
    return all4.PresentTense;
  }
  if (m3.has("#Gerund")) {
    return all4.Gerund;
  }
  return lemma;
};
var swapVerb = function(vb3, lemma) {
  let str = lemma;
  vb3.forEach((m3) => {
    if (!m3.has("#Infinitive")) {
      str = matchVerb(m3, lemma);
    }
    m3.replaceWith(str);
  });
  return vb3;
};
var swap_verb_default = swapVerb;

// node_modules/compromise/src/2-two/swap/api/swap.js
var swapNoun = function(m3, lemma) {
  let str = lemma;
  if (m3.has("#Plural")) {
    const toPlural = m3.methods.two.transform.noun.toPlural;
    str = toPlural(lemma, m3.model);
  }
  m3.replaceWith(str, { possessives: true });
};
var swapAdverb = function(m3, lemma) {
  const { toAdverb: toAdverb2 } = m3.methods.two.transform.adjective;
  let str = lemma;
  let adv = toAdverb2(str);
  if (adv) {
    m3.replaceWith(adv);
  }
};
var swapAdjective = function(m3, lemma) {
  const { toComparative: toComparative3, toSuperlative: toSuperlative3 } = m3.methods.two.transform.adjective;
  let str = lemma;
  if (m3.has("#Comparative")) {
    str = toComparative3(str, m3.model);
  } else if (m3.has("#Superlative")) {
    str = toSuperlative3(str, m3.model);
  }
  if (str) {
    m3.replaceWith(str);
  }
};
var swap = function(from, to, tag2) {
  let reg = from.split(/ /g).map((str) => str.toLowerCase().trim());
  reg = reg.filter((str) => str);
  reg = reg.map((str) => `{${str}}`).join(" ");
  let m3 = this.match(reg);
  if (tag2) {
    m3 = m3.if(tag2);
  }
  if (m3.has("#Verb")) {
    return swap_verb_default(m3, to);
  }
  if (m3.has("#Noun")) {
    return swapNoun(m3, to);
  }
  if (m3.has("#Adverb")) {
    return swapAdverb(m3, to);
  }
  if (m3.has("#Adjective")) {
    return swapAdjective(m3, to);
  }
  return this;
};
var swap_default = swap;

// node_modules/compromise/src/2-two/swap/plugin.js
var api4 = function(View2) {
  View2.prototype.swap = swap_default;
};
var plugin_default18 = {
  api: api4
};

// node_modules/compromise/src/two.js
one_default.plugin(plugin_default14);
one_default.plugin(plugin_default15);
one_default.plugin(plugin_default16);
one_default.plugin(plugin_default17);
one_default.plugin(plugin_default18);
var two_default = one_default;

// node_modules/compromise/src/3-three/adjectives/plugin.js
var toRoot2 = function(adj) {
  const { fromComparative: fromComparative3, fromSuperlative: fromSuperlative3 } = adj.methods.two.transform.adjective;
  let str = adj.text("normal");
  if (adj.has("#Comparative")) {
    return fromComparative3(str, adj.model);
  }
  if (adj.has("#Superlative")) {
    return fromSuperlative3(str, adj.model);
  }
  return str;
};
var api5 = function(View2) {
  class Adjectives extends View2 {
    constructor(document2, pointer, groups) {
      super(document2, pointer, groups);
      this.viewType = "Adjectives";
    }
    json(opts2 = {}) {
      const { toAdverb: toAdverb2, toNoun: toNoun2, toSuperlative: toSuperlative3, toComparative: toComparative3 } = this.methods.two.transform.adjective;
      opts2.normal = true;
      return this.map((m3) => {
        let json = m3.toView().json(opts2)[0] || {};
        let str = toRoot2(m3);
        json.adjective = {
          adverb: toAdverb2(str, this.model),
          noun: toNoun2(str, this.model),
          superlative: toSuperlative3(str, this.model),
          comparative: toComparative3(str, this.model)
        };
        return json;
      }, []);
    }
    adverbs() {
      return this.before("#Adverb+$").concat(this.after("^#Adverb+"));
    }
    conjugate(n3) {
      const { toComparative: toComparative3, toSuperlative: toSuperlative3, toNoun: toNoun2, toAdverb: toAdverb2 } = this.methods.two.transform.adjective;
      return this.getNth(n3).map((adj) => {
        let root6 = toRoot2(adj);
        return {
          Adjective: root6,
          Comparative: toComparative3(root6, this.model),
          Superlative: toSuperlative3(root6, this.model),
          Noun: toNoun2(root6, this.model),
          Adverb: toAdverb2(root6, this.model)
        };
      }, []);
    }
    toComparative(n3) {
      const { toComparative: toComparative3 } = this.methods.two.transform.adjective;
      return this.getNth(n3).map((adj) => {
        let root6 = toRoot2(adj);
        let str = toComparative3(root6, this.model);
        return adj.replaceWith(str);
      });
    }
    toSuperlative(n3) {
      const { toSuperlative: toSuperlative3 } = this.methods.two.transform.adjective;
      return this.getNth(n3).map((adj) => {
        let root6 = toRoot2(adj);
        let str = toSuperlative3(root6, this.model);
        return adj.replaceWith(str);
      });
    }
    toAdverb(n3) {
      const { toAdverb: toAdverb2 } = this.methods.two.transform.adjective;
      return this.getNth(n3).map((adj) => {
        let root6 = toRoot2(adj);
        let str = toAdverb2(root6, this.model);
        return adj.replaceWith(str);
      });
    }
    toNoun(n3) {
      const { toNoun: toNoun2 } = this.methods.two.transform.adjective;
      return this.getNth(n3).map((adj) => {
        let root6 = toRoot2(adj);
        let str = toNoun2(root6, this.model);
        return adj.replaceWith(str);
      });
    }
  }
  View2.prototype.adjectives = function(n3) {
    let m3 = this.match("#Adjective");
    m3 = m3.getNth(n3);
    return new Adjectives(m3.document, m3.pointer);
  };
  View2.prototype.superlatives = function(n3) {
    let m3 = this.match("#Superlative");
    m3 = m3.getNth(n3);
    return new Adjectives(m3.document, m3.pointer);
  };
  View2.prototype.comparatives = function(n3) {
    let m3 = this.match("#Comparative");
    m3 = m3.getNth(n3);
    return new Adjectives(m3.document, m3.pointer);
  };
};
var plugin_default19 = { api: api5 };

// node_modules/compromise/src/3-three/adverbs/plugin.js
var toRoot3 = function(adj) {
  let str = adj.compute("root").text("root");
  return str;
};
var api6 = function(View2) {
  class Adverbs extends View2 {
    constructor(document2, pointer, groups) {
      super(document2, pointer, groups);
      this.viewType = "Adverbs";
    }
    conjugate(n3) {
      return this.getNth(n3).map((adv) => {
        let adj = toRoot3(adv);
        return {
          Adverb: adv.text("normal"),
          Adjective: adj
        };
      }, []);
    }
    json(opts2 = {}) {
      const fromAdverb = this.methods.two.transform.adjective.fromAdverb;
      opts2.normal = true;
      return this.map((m3) => {
        let json = m3.toView().json(opts2)[0] || {};
        json.adverb = {
          adjective: fromAdverb(json.normal)
        };
        return json;
      }, []);
    }
  }
  View2.prototype.adverbs = function(n3) {
    let m3 = this.match("#Adverb");
    m3 = m3.getNth(n3);
    return new Adverbs(m3.document, m3.pointer);
  };
};
var plugin_default20 = { api: api6 };

// node_modules/compromise/src/3-three/chunker/api/clauses.js
var byComma = function(doc) {
  let commas = doc.match("@hasComma");
  commas = commas.filter((m3) => {
    if (m3.growLeft(".").wordCount() === 1) {
      return false;
    }
    if (m3.growRight(". .").wordCount() === 1) {
      return false;
    }
    let more = m3.grow(".");
    more = more.ifNo("@hasComma @hasComma");
    more = more.ifNo("@hasComma (and|or) .");
    more = more.ifNo("(#City && @hasComma) #Country");
    more = more.ifNo("(#WeekDay && @hasComma) #Date");
    more = more.ifNo("(#Date+ && @hasComma) #Value");
    more = more.ifNo("(#Adjective && @hasComma) #Adjective");
    return more.found;
  });
  return doc.splitAfter(commas);
};
var splitParentheses = function(doc) {
  let matches3 = doc.parentheses();
  matches3 = matches3.filter((m3) => {
    return m3.wordCount() >= 3 && m3.has("#Verb") && m3.has("#Noun");
  });
  return doc.splitOn(matches3);
};
var splitQuotes = function(doc) {
  let matches3 = doc.quotations();
  matches3 = matches3.filter((m3) => {
    return m3.wordCount() >= 3 && m3.has("#Verb") && m3.has("#Noun");
  });
  return doc.splitOn(matches3);
};
var clauses = function(n3) {
  let found = this;
  found = splitParentheses(found);
  found = splitQuotes(found);
  found = byComma(found);
  found = found.splitAfter("(@hasEllipses|@hasSemicolon|@hasDash|@hasColon)");
  found = found.splitAfter("^#Pronoun (said|says)");
  found = found.splitBefore("(said|says) #ProperNoun$");
  found = found.splitBefore(". . if .{4}");
  found = found.splitBefore("and while");
  found = found.splitBefore("now that");
  found = found.splitBefore("ever since");
  found = found.splitBefore("(supposing|although)");
  found = found.splitBefore("even (while|if|though)");
  found = found.splitBefore("(whereas|whose)");
  found = found.splitBefore("as (though|if)");
  found = found.splitBefore("(til|until)");
  let m3 = found.match("#Verb .* [but] .* #Verb", 0);
  if (m3.found) {
    found = found.splitBefore(m3);
  }
  let condition = found.if("if .{2,9} then .").match("then");
  found = found.splitBefore(condition);
  if (typeof n3 === "number") {
    found = found.get(n3);
  }
  return found;
};
var clauses_default = clauses;

// node_modules/compromise/src/3-three/chunker/api/chunks.js
var chunks = function(doc) {
  let all4 = [];
  let lastOne = null;
  let m3 = doc.clauses();
  m3.docs.forEach((terms) => {
    terms.forEach((term) => {
      if (!term.chunk || term.chunk !== lastOne) {
        lastOne = term.chunk;
        all4.push([term.index[0], term.index[1], term.index[1] + 1]);
      } else {
        all4[all4.length - 1][2] = term.index[1] + 1;
      }
    });
    lastOne = null;
  });
  let parts = doc.update(all4);
  return parts;
};
var chunks_default2 = chunks;

// node_modules/compromise/src/3-three/chunker/api/api.js
var api7 = function(View2) {
  class Chunks extends View2 {
    constructor(document2, pointer, groups) {
      super(document2, pointer, groups);
      this.viewType = "Chunks";
    }
    isVerb() {
      return this.filter((c2) => c2.has("<Verb>"));
    }
    isNoun() {
      return this.filter((c2) => c2.has("<Noun>"));
    }
    isAdjective() {
      return this.filter((c2) => c2.has("<Adjective>"));
    }
    isPivot() {
      return this.filter((c2) => c2.has("<Pivot>"));
    }
    // chunk-friendly debug
    debug() {
      this.toView().debug("chunks");
      return this;
    }
    // overloaded - keep Sentences class
    update(pointer) {
      let m3 = new Chunks(this.document, pointer);
      m3._cache = this._cache;
      return m3;
    }
  }
  View2.prototype.chunks = function(n3) {
    let m3 = chunks_default2(this);
    m3 = m3.getNth(n3);
    return new Chunks(this.document, m3.pointer);
  };
  View2.prototype.clauses = clauses_default;
};
var api_default12 = api7;

// node_modules/compromise/src/3-three/chunker/compute/01-easy.js
var byWord2 = {
  this: "Noun",
  then: "Pivot"
};
var easyMode = function(document2) {
  for (let n3 = 0; n3 < document2.length; n3 += 1) {
    for (let t3 = 0; t3 < document2[n3].length; t3 += 1) {
      let term = document2[n3][t3];
      if (byWord2.hasOwnProperty(term.normal) === true) {
        term.chunk = byWord2[term.normal];
        continue;
      }
      if (term.tags.has("Verb")) {
        term.chunk = "Verb";
        continue;
      }
      if (term.tags.has("Noun") || term.tags.has("Determiner")) {
        term.chunk = "Noun";
        continue;
      }
      if (term.tags.has("Value")) {
        term.chunk = "Noun";
        continue;
      }
      if (term.tags.has("QuestionWord")) {
        term.chunk = "Pivot";
        continue;
      }
    }
  }
};
var easy_default = easyMode;

// node_modules/compromise/src/3-three/chunker/compute/02-neighbours.js
var byNeighbour = function(document2) {
  for (let n3 = 0; n3 < document2.length; n3 += 1) {
    for (let t3 = 0; t3 < document2[n3].length; t3 += 1) {
      let term = document2[n3][t3];
      if (term.chunk) {
        continue;
      }
      let onRight = document2[n3][t3 + 1];
      let onLeft = document2[n3][t3 - 1];
      if (term.tags.has("Adjective")) {
        if (onLeft && onLeft.tags.has("Copula")) {
          term.chunk = "Adjective";
          continue;
        }
        if (onLeft && onLeft.tags.has("Determiner")) {
          term.chunk = "Noun";
          continue;
        }
        if (onRight && onRight.tags.has("Noun")) {
          term.chunk = "Noun";
          continue;
        }
        continue;
      }
      if (term.tags.has("Adverb") || term.tags.has("Negative")) {
        if (onLeft && onLeft.tags.has("Adjective")) {
          term.chunk = "Adjective";
          continue;
        }
        if (onLeft && onLeft.tags.has("Verb")) {
          term.chunk = "Verb";
          continue;
        }
        if (onRight && onRight.tags.has("Adjective")) {
          term.chunk = "Adjective";
          continue;
        }
        if (onRight && onRight.tags.has("Verb")) {
          term.chunk = "Verb";
          continue;
        }
      }
    }
  }
};
var neighbours_default3 = byNeighbour;

// node_modules/compromise/src/3-three/chunker/compute/03-matcher.js
var rules = [
  // === Conjunction ===
  // that the houses
  { match: "[that] #Determiner #Noun", group: 0, chunk: "Pivot" },
  // estimated that
  { match: "#PastTense [that]", group: 0, chunk: "Pivot" },
  // so the
  { match: "[so] #Determiner", group: 0, chunk: "Pivot" },
  // === Adjective ===
  // was really nice
  { match: "#Copula #Adverb+? [#Adjective]", group: 0, chunk: "Adjective" },
  // was nice
  // { match: '#Copula [#Adjective]', group: 0, chunk: 'Adjective' },
  // nice and cool
  { match: "#Adjective and #Adjective", chunk: "Adjective" },
  // really nice
  // { match: '#Adverb+ #Adjective', chunk: 'Adjective' },
  // === Verb ===
  // quickly and suddenly run
  { match: "#Adverb+ and #Adverb #Verb", chunk: "Verb" },
  // sitting near
  { match: "#Gerund #Adjective$", chunk: "Verb" },
  // going to walk
  { match: "#Gerund to #Verb", chunk: "Verb" },
  // come and have a drink
  { match: "#PresentTense and #PresentTense", chunk: "Verb" },
  // really not
  { match: "#Adverb #Negative", chunk: "Verb" },
  // want to see
  { match: "(want|wants|wanted) to #Infinitive", chunk: "Verb" },
  // walk ourselves
  { match: "#Verb #Reflexive", chunk: "Verb" },
  // tell him the story
  // { match: '#PresentTense [#Pronoun] #Determiner', group: 0, chunk: 'Verb' },
  // tries to walk
  { match: "#Verb [to] #Adverb? #Infinitive", group: 0, chunk: "Verb" },
  // upon seeing
  { match: "[#Preposition] #Gerund", group: 0, chunk: "Verb" },
  // ensure that
  { match: "#Infinitive [that] <Noun>", group: 0, chunk: "Verb" },
  // === Noun ===
  // the brown fox
  // { match: '#Determiner #Adjective+ #Noun', chunk: 'Noun' },
  // the fox
  // { match: '(the|this) <Noun>', chunk: 'Noun' },
  // brown fox
  // { match: '#Adjective+ <Noun>', chunk: 'Noun' },
  // --- of ---
  // son of a gun
  { match: "#Noun of #Determiner? #Noun", chunk: "Noun" },
  // 3 beautiful women
  { match: "#Value+ #Adverb? #Adjective", chunk: "Noun" },
  // the last russian tsar
  { match: "the [#Adjective] #Noun", chunk: "Noun" },
  // breakfast in bed
  { match: "#Singular in #Determiner? #Singular", chunk: "Noun" },
  // Some citizens in this Canadian capital
  { match: "#Plural [in] #Determiner? #Noun", group: 0, chunk: "Pivot" },
  // indoor and outdoor seating
  { match: "#Noun and #Determiner? #Noun", notIf: "(#Possessive|#Pronoun)", chunk: "Noun" }
  //  boys and girls
  // { match: '#Plural and #Determiner? #Plural', chunk: 'Noun' },
  // tomatoes and cheese
  // { match: '#Noun and #Determiner? #Noun', notIf: '#Pronoun', chunk: 'Noun' },
  // that is why
  // { match: '[that] (is|was)', group: 0, chunk: 'Noun' },
];
var net2 = null;
var matcher = function(view, _2, world2) {
  const { methods: methods17 } = world2;
  net2 = net2 || methods17.one.buildNet(rules, world2);
  view.sweep(net2);
};
var matcher_default = matcher;

// node_modules/compromise/src/3-three/chunker/compute/04-fallback.js
var setChunk = function(term, chunk) {
  const env2 = typeof process === "undefined" || !process.env ? self.env || {} : process.env;
  if (env2.DEBUG_CHUNKS) {
    let str = (term.normal + "'").padEnd(8);
    console.log(`  | '${str}  \u2192  \x1B[34m${chunk.padEnd(12)}\x1B[0m \x1B[2m -fallback- \x1B[0m`);
  }
  term.chunk = chunk;
};
var fallback2 = function(document2) {
  for (let n3 = 0; n3 < document2.length; n3 += 1) {
    for (let t3 = 0; t3 < document2[n3].length; t3 += 1) {
      let term = document2[n3][t3];
      if (term.chunk === void 0) {
        if (term.tags.has("Conjunction")) {
          setChunk(term, "Pivot");
        } else if (term.tags.has("Preposition")) {
          setChunk(term, "Pivot");
        } else if (term.tags.has("Adverb")) {
          setChunk(term, "Verb");
        } else {
          term.chunk = "Noun";
        }
      }
    }
  }
};
var fallback_default2 = fallback2;

// node_modules/compromise/src/3-three/chunker/compute/05-fixUp.js
var fixUp = function(docs) {
  let byChunk = [];
  let current = null;
  docs.forEach((terms) => {
    for (let i3 = 0; i3 < terms.length; i3 += 1) {
      let term = terms[i3];
      if (current && term.chunk === current) {
        byChunk[byChunk.length - 1].terms.push(term);
      } else {
        byChunk.push({ chunk: term.chunk, terms: [term] });
        current = term.chunk;
      }
    }
  });
  byChunk.forEach((c2) => {
    if (c2.chunk === "Verb") {
      const hasVerb = c2.terms.find((t3) => t3.tags.has("Verb"));
      if (!hasVerb) {
        c2.terms.forEach((t3) => t3.chunk = null);
      }
    }
  });
};
var fixUp_default = fixUp;

// node_modules/compromise/src/3-three/chunker/compute/index.js
var findChunks = function(view) {
  const { document: document2, world: world2 } = view;
  easy_default(document2);
  neighbours_default3(document2);
  matcher_default(view, document2, world2);
  fallback_default2(document2, world2);
  fixUp_default(document2, world2);
};
var compute_default12 = { chunks: findChunks };

// node_modules/compromise/src/3-three/chunker/plugin.js
var plugin_default21 = {
  compute: compute_default12,
  api: api_default12,
  hooks: ["chunks"]
};

// node_modules/compromise/src/3-three/misc/acronyms/index.js
var hasPeriod2 = /\./g;
var api8 = function(View2) {
  class Acronyms extends View2 {
    constructor(document2, pointer, groups) {
      super(document2, pointer, groups);
      this.viewType = "Acronyms";
    }
    strip() {
      this.docs.forEach((terms) => {
        terms.forEach((term) => {
          term.text = term.text.replace(hasPeriod2, "");
          term.normal = term.normal.replace(hasPeriod2, "");
        });
      });
      return this;
    }
    addPeriods() {
      this.docs.forEach((terms) => {
        terms.forEach((term) => {
          term.text = term.text.replace(hasPeriod2, "");
          term.normal = term.normal.replace(hasPeriod2, "");
          term.text = term.text.split("").join(".") + ".";
          term.normal = term.normal.split("").join(".") + ".";
        });
      });
      return this;
    }
  }
  View2.prototype.acronyms = function(n3) {
    let m3 = this.match("#Acronym");
    m3 = m3.getNth(n3);
    return new Acronyms(m3.document, m3.pointer);
  };
};
var acronyms_default2 = api8;

// node_modules/compromise/src/3-three/misc/parentheses/fns.js
var hasOpen2 = /\(/;
var hasClosed2 = /\)/;
var findEnd = function(terms, i3) {
  for (; i3 < terms.length; i3 += 1) {
    if (terms[i3].post && hasClosed2.test(terms[i3].post)) {
      let [, index4] = terms[i3].index;
      index4 = index4 || 0;
      return index4;
    }
  }
  return null;
};
var find2 = function(doc) {
  let ptrs = [];
  doc.docs.forEach((terms) => {
    let isOpen = false;
    for (let i3 = 0; i3 < terms.length; i3 += 1) {
      let term = terms[i3];
      if (!isOpen && term.pre && hasOpen2.test(term.pre)) {
        let end2 = findEnd(terms, i3);
        if (end2 !== null) {
          let [n3, start2] = terms[i3].index;
          ptrs.push([n3, start2, end2 + 1, terms[i3].id]);
          i3 = end2;
        }
      }
    }
  });
  return doc.update(ptrs);
};
var strip = function(m3) {
  m3.docs.forEach((terms) => {
    terms[0].pre = terms[0].pre.replace(hasOpen2, "");
    let last = terms[terms.length - 1];
    last.post = last.post.replace(hasClosed2, "");
  });
  return m3;
};

// node_modules/compromise/src/3-three/misc/parentheses/index.js
var api9 = function(View2) {
  class Parentheses extends View2 {
    constructor(document2, pointer, groups) {
      super(document2, pointer, groups);
      this.viewType = "Possessives";
    }
    strip() {
      return strip(this);
    }
  }
  View2.prototype.parentheses = function(n3) {
    let m3 = find2(this);
    m3 = m3.getNth(n3);
    return new Parentheses(m3.document, m3.pointer);
  };
};
var parentheses_default = api9;

// node_modules/compromise/src/3-three/misc/possessives/index.js
var apostropheS2 = /'s$/;
var find3 = function(doc) {
  let m3 = doc.match("#Possessive+");
  if (m3.has("#Person")) {
    m3 = m3.growLeft("#Person+");
  }
  if (m3.has("#Place")) {
    m3 = m3.growLeft("#Place+");
  }
  if (m3.has("#Organization")) {
    m3 = m3.growLeft("#Organization+");
  }
  return m3;
};
var api10 = function(View2) {
  class Possessives extends View2 {
    constructor(document2, pointer, groups) {
      super(document2, pointer, groups);
      this.viewType = "Possessives";
    }
    strip() {
      this.docs.forEach((terms) => {
        terms.forEach((term) => {
          term.text = term.text.replace(apostropheS2, "");
          term.normal = term.normal.replace(apostropheS2, "");
        });
      });
      return this;
    }
  }
  View2.prototype.possessives = function(n3) {
    let m3 = find3(this);
    m3 = m3.getNth(n3);
    return new Possessives(m3.document, m3.pointer);
  };
};
var possessives_default = api10;

// node_modules/compromise/src/3-three/misc/quotations/fns.js
var pairs2 = {
  '"': '"',
  // 'StraightDoubleQuotes'
  "\uFF02": "\uFF02",
  // 'StraightDoubleQuotesWide'
  "'": "'",
  // 'StraightSingleQuotes'
  "\u201C": "\u201D",
  // 'CommaDoubleQuotes'
  "\u2018": "\u2019",
  // 'CommaSingleQuotes'
  "\u201F": "\u201D",
  // 'CurlyDoubleQuotesReversed'
  "\u201B": "\u2019",
  // 'CurlySingleQuotesReversed'
  "\u201E": "\u201D",
  // 'LowCurlyDoubleQuotes'
  "\u2E42": "\u201D",
  // 'LowCurlyDoubleQuotesReversed'
  "\u201A": "\u2019",
  // 'LowCurlySingleQuotes'
  "\xAB": "\xBB",
  // 'AngleDoubleQuotes' , 
  "\u2039": "\u203A",
  // 'AngleSingleQuotes'
  // Prime 'non quotation'
  "\u2035": "\u2032",
  // 'PrimeSingleQuotes'
  "\u2036": "\u2033",
  // 'PrimeDoubleQuotes'
  "\u2037": "\u2034",
  // 'PrimeTripleQuotes'
  // Prime 'quotation' variation
  "\u301D": "\u301E",
  // 'PrimeDoubleQuotes'
  "`": "\xB4",
  // 'PrimeSingleQuotes'
  "\u301F": "\u301E"
  // 'LowPrimeDoubleQuotesReversed'
};
var hasOpen3 = RegExp("[" + Object.keys(pairs2).join("") + "]");
var hasClosed3 = RegExp("[" + Object.values(pairs2).join("") + "]");
var findEnd2 = function(terms, i3) {
  const have = terms[i3].pre.match(hasOpen3)[0] || "";
  if (!have || !pairs2[have]) {
    return null;
  }
  const want = pairs2[have];
  for (; i3 < terms.length; i3 += 1) {
    if (terms[i3].post && terms[i3].post.match(want)) {
      return i3;
    }
  }
  return null;
};
var find4 = function(doc) {
  let ptrs = [];
  doc.docs.forEach((terms) => {
    let isOpen = false;
    for (let i3 = 0; i3 < terms.length; i3 += 1) {
      let term = terms[i3];
      if (!isOpen && term.pre && hasOpen3.test(term.pre)) {
        let end2 = findEnd2(terms, i3);
        if (end2 !== null) {
          let [n3, start2] = terms[i3].index;
          ptrs.push([n3, start2, end2 + 1, terms[i3].id]);
          i3 = end2;
        }
      }
    }
  });
  return doc.update(ptrs);
};
var strip2 = function(m3) {
  m3.docs.forEach((terms) => {
    terms[0].pre = terms[0].pre.replace(hasOpen3, "");
    let lastTerm = terms[terms.length - 1];
    lastTerm.post = lastTerm.post.replace(hasClosed3, "");
  });
};

// node_modules/compromise/src/3-three/misc/quotations/index.js
var api11 = function(View2) {
  class Quotations extends View2 {
    constructor(document2, pointer, groups) {
      super(document2, pointer, groups);
      this.viewType = "Possessives";
    }
    strip() {
      return strip2(this);
    }
  }
  View2.prototype.quotations = function(n3) {
    let m3 = find4(this);
    m3 = m3.getNth(n3);
    return new Quotations(m3.document, m3.pointer);
  };
};
var quotations_default = api11;

// node_modules/compromise/src/3-three/misc/selections/index.js
var phoneNumbers = function(n3) {
  let m3 = this.splitAfter("@hasComma");
  m3 = m3.match("#PhoneNumber+");
  m3 = m3.getNth(n3);
  return m3;
};
var selections = [
  ["hyphenated", "@hasHyphen ."],
  ["hashTags", "#HashTag"],
  ["emails", "#Email"],
  ["emoji", "#Emoji"],
  ["emoticons", "#Emoticon"],
  ["atMentions", "#AtMention"],
  ["urls", "#Url"],
  // ['pronouns', '#Pronoun'],
  ["conjunctions", "#Conjunction"],
  ["prepositions", "#Preposition"],
  ["abbreviations", "#Abbreviation"],
  ["honorifics", "#Honorific"]
];
var aliases2 = [
  ["emojis", "emoji"],
  ["atmentions", "atMentions"]
];
var addMethods = function(View2) {
  selections.forEach((a2) => {
    View2.prototype[a2[0]] = function(n3) {
      let m3 = this.match(a2[1]);
      return typeof n3 === "number" ? m3.get(n3) : m3;
    };
  });
  View2.prototype.phoneNumbers = phoneNumbers;
  aliases2.forEach((a2) => {
    View2.prototype[a2[0]] = View2.prototype[a2[1]];
  });
};
var selections_default = addMethods;

// node_modules/compromise/src/3-three/misc/slashes/index.js
var hasSlash2 = /\//;
var api12 = function(View2) {
  class Slashes extends View2 {
    constructor(document2, pointer, groups) {
      super(document2, pointer, groups);
      this.viewType = "Slashes";
    }
    split() {
      return this.map((m3) => {
        let str = m3.text();
        let arr = str.split(hasSlash2);
        m3 = m3.replaceWith(arr.join(" "));
        return m3.growRight("(" + arr.join("|") + ")+");
      });
    }
  }
  View2.prototype.slashes = function(n3) {
    let m3 = this.match("#SlashedTerm");
    m3 = m3.getNth(n3);
    return new Slashes(m3.document, m3.pointer);
  };
};
var slashes_default2 = api12;

// node_modules/compromise/src/3-three/misc/plugin.js
var plugin_default22 = {
  api: function(View2) {
    acronyms_default2(View2);
    parentheses_default(View2);
    possessives_default(View2);
    quotations_default(View2);
    selections_default(View2);
    slashes_default2(View2);
  }
};

// node_modules/compromise/src/3-three/normalize/methods.js
var termLoop2 = function(view, cb) {
  view.docs.forEach((terms) => {
    terms.forEach(cb);
  });
};
var methods_default10 = {
  // remove titlecasing, uppercase
  "case": (doc) => {
    termLoop2(doc, (term) => {
      term.text = term.text.toLowerCase();
    });
  },
  // visually romanize/anglicize 'Bjrk' into 'Bjork'.
  "unicode": (doc) => {
    const world2 = doc.world;
    const killUnicode2 = world2.methods.one.killUnicode;
    termLoop2(doc, (term) => term.text = killUnicode2(term.text, world2));
  },
  // remove hyphens, newlines, and force one space between words
  "whitespace": (doc) => {
    termLoop2(doc, (term) => {
      term.post = term.post.replace(/\s+/g, " ");
      term.post = term.post.replace(/\s([.,?!:;])/g, "$1");
      term.pre = term.pre.replace(/\s+/g, "");
    });
  },
  // remove commas, semicolons - but keep sentence-ending punctuation
  "punctuation": (doc) => {
    termLoop2(doc, (term) => {
      term.post = term.post.replace(/[-]/g, " ");
      term.post = term.post.replace(/[,:;]/g, "");
      term.post = term.post.replace(/\.{2,}/g, "");
      term.post = term.post.replace(/\?{2,}/g, "?");
      term.post = term.post.replace(/!{2,}/g, "!");
      term.post = term.post.replace(/\?!+/g, "?");
    });
    let docs = doc.docs;
    let terms = docs[docs.length - 1];
    if (terms && terms.length > 0) {
      let lastTerm = terms[terms.length - 1];
      lastTerm.post = lastTerm.post.replace(/ /g, "");
    }
  },
  // ====== subsets ===
  // turn "isn't" to "is not"
  "contractions": (doc) => {
    doc.contractions().expand();
  },
  //remove periods from acronyms, like 'F.B.I.'
  "acronyms": (doc) => {
    doc.acronyms().strip();
  },
  //remove words inside brackets (like these)
  "parentheses": (doc) => {
    doc.parentheses().strip();
  },
  // turn "Google's tax return" to "Google tax return"
  "possessives": (doc) => {
    doc.possessives().strip();
  },
  // turn "tax return" to tax return
  "quotations": (doc) => {
    doc.quotations().strip();
  },
  // remove them
  "emoji": (doc) => {
    doc.emojis().remove();
  },
  //turn 'Vice Admiral John Smith' to 'John Smith'
  "honorifics": (doc) => {
    doc.match("#Honorific+ #Person").honorifics().remove();
  },
  // remove needless adverbs
  "adverbs": (doc) => {
    doc.adverbs().remove();
  },
  // turn "batmobiles" into "batmobile"
  "nouns": (doc) => {
    doc.nouns().toSingular();
  },
  // turn all verbs into Infinitive form - "I walked"  "I walk"
  "verbs": (doc) => {
    doc.verbs().toInfinitive();
  },
  // turn "fifty" into "50"
  "numbers": (doc) => {
    doc.numbers().toNumber();
  },
  /** remove bullets from beginning of phrase */
  "debullet": (doc) => {
    const hasBullet = /^\s*([-*])\s*$/;
    doc.docs.forEach((terms) => {
      if (hasBullet.test(terms[0].pre)) {
        terms[0].pre = terms[0].pre.replace(hasBullet, "");
      }
    });
    return doc;
  }
};

// node_modules/compromise/src/3-three/normalize/api.js
var split2 = (str) => {
  return str.split("|").reduce((h2, k2) => {
    h2[k2] = true;
    return h2;
  }, {});
};
var light = "unicode|punctuation|whitespace|acronyms";
var medium = "|case|contractions|parentheses|quotations|emoji|honorifics|debullet";
var heavy = "|possessives|adverbs|nouns|verbs";
var presets = {
  light: split2(light),
  medium: split2(light + medium),
  heavy: split2(light + medium + heavy)
};
function api_default13(View2) {
  View2.prototype.normalize = function(opts2 = "light") {
    if (typeof opts2 === "string") {
      opts2 = presets[opts2];
    }
    Object.keys(opts2).forEach((fn) => {
      if (methods_default10.hasOwnProperty(fn)) {
        methods_default10[fn](this, opts2[fn]);
      }
    });
    return this;
  };
}

// node_modules/compromise/src/3-three/normalize/plugin.js
var plugin_default23 = {
  api: api_default13
};

// node_modules/compromise/src/3-three/nouns/find.js
var findNouns = function(doc) {
  let m3 = doc.clauses().match("<Noun>");
  let commas = m3.match("@hasComma");
  commas = commas.not("#Place");
  if (commas.found) {
    m3 = m3.splitAfter(commas);
  }
  m3 = m3.splitOn("#Expression");
  m3 = m3.splitOn("(he|she|we|you|they|i)");
  m3 = m3.splitOn("(#Noun|#Adjective) [(he|him|she|it)]", 0);
  m3 = m3.splitOn("[(he|him|she|it)] (#Determiner|#Value)", 0);
  m3 = m3.splitBefore("#Noun [(the|a|an)] #Adjective? #Noun", 0);
  m3 = m3.splitOn("[(here|there)] #Noun", 0);
  m3 = m3.splitOn("[#Noun] (here|there)", 0);
  m3 = m3.splitBefore("(our|my|their|your)");
  m3 = m3.splitOn("#Noun [#Determiner]", 0);
  m3 = m3.if("#Noun");
  return m3;
};
var find_default = findNouns;

// node_modules/compromise/src/3-three/nouns/api/isSubordinate.js
var list2 = [
  "after",
  "although",
  "as if",
  "as long as",
  "as",
  "because",
  "before",
  "even if",
  "even though",
  "ever since",
  "if",
  "in order that",
  "provided that",
  "since",
  "so that",
  "than",
  "that",
  "though",
  "unless",
  "until",
  "what",
  "whatever",
  "when",
  "whenever",
  "where",
  "whereas",
  "wherever",
  "whether",
  "which",
  "whichever",
  "who",
  "whoever",
  "whom",
  "whomever",
  "whose"
];
var isSubordinate = function(m3) {
  if (m3.before("#Preposition$").found) {
    return true;
  }
  let leadIn = m3.before();
  if (!leadIn.found) {
    return false;
  }
  for (let i3 = 0; i3 < list2.length; i3 += 1) {
    if (m3.has(list2[i3])) {
      return true;
    }
  }
  return false;
};
var isSubordinate_default = isSubordinate;

// node_modules/compromise/src/3-three/nouns/api/isPlural.js
var notPlural2 = "(#Pronoun|#Place|#Value|#Person|#Uncountable|#Month|#WeekDay|#Holiday|#Possessive)";
var isPlural2 = function(m3, root6) {
  if (m3.has("#Plural")) {
    return true;
  }
  if (m3.has("#Noun and #Noun")) {
    return true;
  }
  if (m3.has("(we|they)")) {
    return true;
  }
  if (root6.has(notPlural2) === true) {
    return false;
  }
  if (m3.has("#Singular")) {
    return false;
  }
  let str = root6.text("normal");
  return str.length > 3 && str.endsWith("s") && !str.endsWith("ss");
};
var isPlural_default = isPlural2;

// node_modules/compromise/src/3-three/nouns/api/parse.js
var getRoot2 = function(m3) {
  let tmp = m3.clone();
  tmp = tmp.match("#Noun+");
  tmp = tmp.remove("(#Adjective|#Preposition|#Determiner|#Value)");
  tmp = tmp.not("#Possessive");
  tmp = tmp.first();
  if (!tmp.found) {
    return m3;
  }
  return tmp;
};
var parseNoun = function(m3) {
  let root6 = getRoot2(m3);
  return {
    determiner: m3.match("#Determiner").eq(0),
    adjectives: m3.match("#Adjective"),
    number: m3.values(),
    isPlural: isPlural_default(m3, root6),
    isSubordinate: isSubordinate_default(m3),
    root: root6
  };
};
var parse_default3 = parseNoun;

// node_modules/compromise/src/3-three/nouns/api/toJSON.js
var toText2 = (m3) => m3.text();
var toArray2 = (m3) => m3.json({ terms: false, normal: true }).map((s3) => s3.normal);
var getNum = function(m3) {
  let num = null;
  if (!m3.found) {
    return num;
  }
  let val = m3.values(0);
  if (val.found) {
    let obj = val.parse()[0] || {};
    return obj.num;
  }
  return num;
};
var toJSON2 = function(m3) {
  let res = parse_default3(m3);
  return {
    root: toText2(res.root),
    number: getNum(res.number),
    determiner: toText2(res.determiner),
    adjectives: toArray2(res.adjectives),
    isPlural: res.isPlural,
    isSubordinate: res.isSubordinate
  };
};
var toJSON_default = toJSON2;

// node_modules/compromise/src/3-three/nouns/api/hasPlural.js
var hasPlural = function(root6) {
  if (root6.has("^(#Uncountable|#ProperNoun|#Place|#Pronoun|#Acronym)+$")) {
    return false;
  }
  return true;
};
var hasPlural_default = hasPlural;

// node_modules/compromise/src/3-three/nouns/api/toPlural.js
var keep = { tags: true };
var nounToPlural = function(m3, parsed) {
  if (parsed.isPlural === true) {
    return m3;
  }
  if (parsed.root.has("#Possessive")) {
    parsed.root = parsed.root.possessives().strip();
  }
  if (!hasPlural_default(parsed.root)) {
    return m3;
  }
  const { methods: methods17, model: model5 } = m3.world;
  const { toPlural } = methods17.two.transform.noun;
  let str = parsed.root.text({ keepPunct: false });
  let plural2 = toPlural(str, model5);
  m3.match(parsed.root).replaceWith(plural2, keep).tag("Plural", "toPlural");
  if (parsed.determiner.has("(a|an)")) {
    m3.remove(parsed.determiner);
  }
  let copula = parsed.root.after("not? #Adverb+? [#Copula]", 0);
  if (copula.found) {
    if (copula.has("is")) {
      m3.replace(copula, "are");
    } else if (copula.has("was")) {
      m3.replace(copula, "were");
    }
  }
  return m3;
};
var toPlural_default2 = nounToPlural;

// node_modules/compromise/src/3-three/nouns/api/toSingular.js
var keep2 = { tags: true };
var nounToSingular = function(m3, parsed) {
  if (parsed.isPlural === false) {
    return m3;
  }
  const { methods: methods17, model: model5 } = m3.world;
  const { toSingular: toSingular2 } = methods17.two.transform.noun;
  let str = parsed.root.text("normal");
  let single = toSingular2(str, model5);
  m3.replace(parsed.root, single, keep2).tag("Singular", "toPlural");
  return m3;
};
var toSingular_default2 = nounToSingular;

// node_modules/compromise/src/3-three/nouns/api/api.js
var api13 = function(View2) {
  class Nouns extends View2 {
    constructor(document2, pointer, groups) {
      super(document2, pointer, groups);
      this.viewType = "Nouns";
    }
    parse(n3) {
      return this.getNth(n3).map(parse_default3);
    }
    json(n3) {
      let opts2 = typeof n3 === "object" ? n3 : {};
      return this.getNth(n3).map((m3) => {
        let json = m3.toView().json(opts2)[0] || {};
        if (opts2 && opts2.noun !== false) {
          json.noun = toJSON_default(m3);
        }
        return json;
      }, []);
    }
    conjugate(n3) {
      const methods17 = this.world.methods.two.transform.noun;
      return this.getNth(n3).map((m3) => {
        let parsed = parse_default3(m3);
        let root6 = parsed.root.compute("root").text("root");
        let res = {
          Singular: root6
        };
        if (hasPlural_default(parsed.root)) {
          res.Plural = methods17.toPlural(root6, this.model);
        }
        if (res.Singular === res.Plural) {
          delete res.Plural;
        }
        return res;
      }, []);
    }
    isPlural(n3) {
      let res = this.filter((m3) => parse_default3(m3).isPlural);
      return res.getNth(n3);
    }
    isSingular(n3) {
      let res = this.filter((m3) => !parse_default3(m3).isPlural);
      return res.getNth(n3);
    }
    adjectives(n3) {
      let res = this.update([]);
      this.forEach((m3) => {
        let adj = parse_default3(m3).adjectives;
        if (adj.found) {
          res = res.concat(adj);
        }
      });
      return res.getNth(n3);
    }
    toPlural(n3) {
      return this.getNth(n3).map((m3) => {
        return toPlural_default2(m3, parse_default3(m3));
      });
    }
    toSingular(n3) {
      return this.getNth(n3).map((m3) => {
        let res = parse_default3(m3);
        return toSingular_default2(m3, res);
      });
    }
    // create a new View, from this one
    update(pointer) {
      let m3 = new Nouns(this.document, pointer);
      m3._cache = this._cache;
      return m3;
    }
  }
  View2.prototype.nouns = function(n3) {
    let m3 = find_default(this);
    m3 = m3.getNth(n3);
    return new Nouns(this.document, m3.pointer);
  };
};
var api_default14 = api13;

// node_modules/compromise/src/3-three/nouns/plugin.js
var plugin_default24 = {
  api: api_default14
};

// node_modules/compromise/src/3-three/numbers/fractions/find.js
var findFractions = function(doc, n3) {
  let m3 = doc.match("#Fraction+");
  m3 = m3.filter((r2) => {
    return !r2.lookBehind("#Value and$").found;
  });
  m3 = m3.notIf("#Value seconds");
  if (typeof n3 === "number") {
    m3 = m3.eq(n3);
  }
  return m3;
};
var find_default2 = findFractions;

// node_modules/compromise/src/3-three/numbers/numbers/parse/toNumber/findModifiers.js
var findModifiers = (str) => {
  const mults = [
    {
      reg: /^(minus|negative)[\s-]/i,
      mult: -1
    },
    {
      reg: /^(a\s)?half[\s-](of\s)?/i,
      mult: 0.5
    }
    //  {
    //   reg: /^(a\s)?quarter[\s\-]/i,
    //   mult: 0.25
    // }
  ];
  for (let i3 = 0; i3 < mults.length; i3++) {
    if (mults[i3].reg.test(str) === true) {
      return {
        amount: mults[i3].mult,
        str: str.replace(mults[i3].reg, "")
      };
    }
  }
  return {
    amount: 1,
    str
  };
};
var findModifiers_default = findModifiers;

// node_modules/compromise/src/3-three/numbers/numbers/parse/toNumber/data.js
var data_default3 = {
  ones: {
    zeroth: 0,
    first: 1,
    second: 2,
    third: 3,
    fourth: 4,
    fifth: 5,
    sixth: 6,
    seventh: 7,
    eighth: 8,
    ninth: 9,
    zero: 0,
    one: 1,
    two: 2,
    three: 3,
    four: 4,
    five: 5,
    six: 6,
    seven: 7,
    eight: 8,
    nine: 9
  },
  teens: {
    tenth: 10,
    eleventh: 11,
    twelfth: 12,
    thirteenth: 13,
    fourteenth: 14,
    fifteenth: 15,
    sixteenth: 16,
    seventeenth: 17,
    eighteenth: 18,
    nineteenth: 19,
    ten: 10,
    eleven: 11,
    twelve: 12,
    thirteen: 13,
    fourteen: 14,
    fifteen: 15,
    sixteen: 16,
    seventeen: 17,
    eighteen: 18,
    nineteen: 19
  },
  tens: {
    twentieth: 20,
    thirtieth: 30,
    fortieth: 40,
    fourtieth: 40,
    fiftieth: 50,
    sixtieth: 60,
    seventieth: 70,
    eightieth: 80,
    ninetieth: 90,
    twenty: 20,
    thirty: 30,
    forty: 40,
    fourty: 40,
    fifty: 50,
    sixty: 60,
    seventy: 70,
    eighty: 80,
    ninety: 90
  },
  multiples: {
    hundredth: 100,
    thousandth: 1e3,
    millionth: 1e6,
    billionth: 1e9,
    trillionth: 1e12,
    quadrillionth: 1e15,
    quintillionth: 1e18,
    sextillionth: 1e21,
    septillionth: 1e24,
    hundred: 100,
    thousand: 1e3,
    million: 1e6,
    billion: 1e9,
    trillion: 1e12,
    quadrillion: 1e15,
    quintillion: 1e18,
    sextillion: 1e21,
    septillion: 1e24,
    grand: 1e3
  }
};

// node_modules/compromise/src/3-three/numbers/numbers/parse/toNumber/validate.js
var isValid = (w, has2) => {
  if (data_default3.ones.hasOwnProperty(w)) {
    if (has2.ones || has2.teens) {
      return false;
    }
  } else if (data_default3.teens.hasOwnProperty(w)) {
    if (has2.ones || has2.teens || has2.tens) {
      return false;
    }
  } else if (data_default3.tens.hasOwnProperty(w)) {
    if (has2.ones || has2.teens || has2.tens) {
      return false;
    }
  }
  return true;
};
var validate_default2 = isValid;

// node_modules/compromise/src/3-three/numbers/numbers/parse/toNumber/parseDecimals.js
var parseDecimals = function(arr) {
  let str = "0.";
  for (let i3 = 0; i3 < arr.length; i3++) {
    let w = arr[i3];
    if (data_default3.ones.hasOwnProperty(w) === true) {
      str += data_default3.ones[w];
    } else if (data_default3.teens.hasOwnProperty(w) === true) {
      str += data_default3.teens[w];
    } else if (data_default3.tens.hasOwnProperty(w) === true) {
      str += data_default3.tens[w];
    } else if (/^[0-9]$/.test(w) === true) {
      str += w;
    } else {
      return 0;
    }
  }
  return parseFloat(str);
};
var parseDecimals_default = parseDecimals;

// node_modules/compromise/src/3-three/numbers/numbers/parse/toNumber/parseNumeric.js
var parseNumeric = (str) => {
  str = str.replace(/1st$/, "1");
  str = str.replace(/2nd$/, "2");
  str = str.replace(/3rd$/, "3");
  str = str.replace(/([4567890])r?th$/, "$1");
  str = str.replace(/^[$]/, "");
  str = str.replace(/[%$]$/, "");
  str = str.replace(/,/g, "");
  str = str.replace(/([0-9])([a-z\u00C0-\u00FF]{1,2})$/, "$1");
  return str;
};
var parseNumeric_default = parseNumeric;

// node_modules/compromise/src/3-three/numbers/numbers/parse/toNumber/index.js
var improperFraction = /^([0-9,. ]+)\/([0-9,. ]+)$/;
var casualForms = {
  "a few": 3,
  "a couple": 2,
  "a dozen": 12,
  "two dozen": 24,
  zero: 0
};
var section_sum = (obj) => {
  return Object.keys(obj).reduce((sum, k2) => {
    sum += obj[k2];
    return sum;
  }, 0);
};
var parse4 = function(str) {
  if (casualForms.hasOwnProperty(str) === true) {
    return casualForms[str];
  }
  if (str === "a" || str === "an") {
    return 1;
  }
  const modifier = findModifiers_default(str);
  str = modifier.str;
  let last_mult = null;
  let has2 = {};
  let sum = 0;
  let isNegative = false;
  const terms = str.split(/[ -]/);
  for (let i3 = 0; i3 < terms.length; i3++) {
    let w = terms[i3];
    w = parseNumeric_default(w);
    if (!w || w === "and") {
      continue;
    }
    if (w === "-" || w === "negative") {
      isNegative = true;
      continue;
    }
    if (w.charAt(0) === "-") {
      isNegative = true;
      w = w.substring(1);
    }
    if (w === "point") {
      sum += section_sum(has2);
      sum += parseDecimals_default(terms.slice(i3 + 1, terms.length));
      sum *= modifier.amount;
      return sum;
    }
    const fm = w.match(improperFraction);
    if (fm) {
      const num = parseFloat(fm[1].replace(/[, ]/g, ""));
      const denom = parseFloat(fm[2].replace(/[, ]/g, ""));
      if (denom) {
        sum += num / denom || 0;
      }
      continue;
    }
    if (data_default3.tens.hasOwnProperty(w)) {
      if (has2.ones && Object.keys(has2).length === 1) {
        sum = has2.ones * 100;
        has2 = {};
      }
    }
    if (validate_default2(w, has2) === false) {
      return null;
    }
    if (/^[0-9.]+$/.test(w)) {
      has2.ones = parseFloat(w);
    } else if (data_default3.ones.hasOwnProperty(w) === true) {
      has2.ones = data_default3.ones[w];
    } else if (data_default3.teens.hasOwnProperty(w) === true) {
      has2.teens = data_default3.teens[w];
    } else if (data_default3.tens.hasOwnProperty(w) === true) {
      has2.tens = data_default3.tens[w];
    } else if (data_default3.multiples.hasOwnProperty(w) === true) {
      let mult = data_default3.multiples[w];
      if (mult === last_mult) {
        return null;
      }
      if (mult === 100 && terms[i3 + 1] !== void 0) {
        const w2 = terms[i3 + 1];
        if (data_default3.multiples[w2]) {
          mult *= data_default3.multiples[w2];
          i3 += 1;
        }
      }
      if (last_mult === null || mult < last_mult) {
        sum += (section_sum(has2) || 1) * mult;
        last_mult = mult;
        has2 = {};
      } else {
        sum += section_sum(has2);
        last_mult = mult;
        sum = (sum || 1) * mult;
        has2 = {};
      }
    }
  }
  sum += section_sum(has2);
  sum *= modifier.amount;
  sum *= isNegative ? -1 : 1;
  if (sum === 0 && Object.keys(has2).length === 0) {
    return null;
  }
  return sum;
};
var toNumber_default = parse4;

// node_modules/compromise/src/3-three/numbers/fractions/parse.js
var endS = /s$/;
var parseNumber = function(m3) {
  let str = m3.text("reduced");
  return toNumber_default(str);
};
var mapping2 = {
  half: 2,
  halve: 2,
  quarter: 4
};
var slashForm = function(m3) {
  let str = m3.text("reduced");
  let found = str.match(/^([-+]?[0-9]+)\/([-+]?[0-9]+)(st|nd|rd|th)?s?$/);
  if (found && found[1] && found[0]) {
    return {
      numerator: Number(found[1]),
      denominator: Number(found[2])
    };
  }
  return null;
};
var nOutOfN = function(m3) {
  let found = m3.match("[<num>#Value+] out of every? [<den>#Value+]");
  if (found.found !== true) {
    return null;
  }
  let { num, den } = found.groups();
  if (!num || !den) {
    return null;
  }
  num = parseNumber(num);
  den = parseNumber(den);
  if (!num || !den) {
    return null;
  }
  if (typeof num === "number" && typeof den === "number") {
    return {
      numerator: num,
      denominator: den
    };
  }
  return null;
};
var nOrinalth = function(m3) {
  let found = m3.match("[<num>(#Cardinal|a)+] [<den>#Fraction+]");
  if (found.found !== true) {
    return null;
  }
  let { num, den } = found.groups();
  if (num.has("a")) {
    num = 1;
  } else {
    num = parseNumber(num);
  }
  let str = den.text("reduced");
  if (endS.test(str)) {
    str = str.replace(endS, "");
    den = den.replaceWith(str);
  }
  if (mapping2.hasOwnProperty(str)) {
    den = mapping2[str];
  } else {
    den = parseNumber(den);
  }
  if (typeof num === "number" && typeof den === "number") {
    return {
      numerator: num,
      denominator: den
    };
  }
  return null;
};
var oneNth = function(m3) {
  let found = m3.match("^#Ordinal$");
  if (found.found !== true) {
    return null;
  }
  if (m3.lookAhead("^of .")) {
    let num = parseNumber(found);
    return {
      numerator: 1,
      denominator: num
    };
  }
  return null;
};
var named = function(m3) {
  let str = m3.text("reduced");
  if (mapping2.hasOwnProperty(str)) {
    return { numerator: 1, denominator: mapping2[str] };
  }
  return null;
};
var round2 = (n3) => {
  let rounded = Math.round(n3 * 1e3) / 1e3;
  if (rounded === 0 && n3 !== 0) {
    return n3;
  }
  return rounded;
};
var parseFraction = function(m3) {
  m3 = m3.clone();
  let res = named(m3) || slashForm(m3) || nOutOfN(m3) || nOrinalth(m3) || oneNth(m3) || null;
  if (res !== null) {
    if (res.numerator && res.denominator) {
      res.decimal = res.numerator / res.denominator;
      res.decimal = round2(res.decimal);
    }
  }
  return res;
};
var parse_default4 = parseFraction;

// node_modules/compromise/src/3-three/numbers/numbers/_toString.js
var numToString = function(n3) {
  if (n3 < 1e6) {
    return String(n3);
  }
  let str;
  if (typeof n3 === "number") {
    str = n3.toFixed(0);
  } else {
    str = n3;
  }
  if (str.indexOf("e+") === -1) {
    return str;
  }
  return str.replace(".", "").split("e+").reduce(function(p5, b) {
    return p5 + Array(b - p5.length + 2).join(0);
  });
};
var toString_default = numToString;

// node_modules/compromise/src/3-three/numbers/numbers/format/toText/data.js
var tens_mapping = [
  ["ninety", 90],
  ["eighty", 80],
  ["seventy", 70],
  ["sixty", 60],
  ["fifty", 50],
  ["forty", 40],
  ["thirty", 30],
  ["twenty", 20]
];
var ones_mapping = [
  "",
  "one",
  "two",
  "three",
  "four",
  "five",
  "six",
  "seven",
  "eight",
  "nine",
  "ten",
  "eleven",
  "twelve",
  "thirteen",
  "fourteen",
  "fifteen",
  "sixteen",
  "seventeen",
  "eighteen",
  "nineteen"
];
var sequence = [
  [1e24, "septillion"],
  [1e20, "hundred sextillion"],
  [1e21, "sextillion"],
  [1e20, "hundred quintillion"],
  [1e18, "quintillion"],
  [1e17, "hundred quadrillion"],
  [1e15, "quadrillion"],
  [1e14, "hundred trillion"],
  [1e12, "trillion"],
  [1e11, "hundred billion"],
  [1e9, "billion"],
  [1e8, "hundred million"],
  [1e6, "million"],
  [1e5, "hundred thousand"],
  [1e3, "thousand"],
  [100, "hundred"],
  [1, "one"]
];

// node_modules/compromise/src/3-three/numbers/numbers/format/toText/index.js
var breakdown_magnitudes = function(num) {
  let working = num;
  let have = [];
  sequence.forEach((a2) => {
    if (num >= a2[0]) {
      let howmany = Math.floor(working / a2[0]);
      working -= howmany * a2[0];
      if (howmany) {
        have.push({
          unit: a2[1],
          count: howmany
        });
      }
    }
  });
  return have;
};
var breakdown_hundred = function(num) {
  let arr = [];
  if (num > 100) {
    return arr;
  }
  for (let i3 = 0; i3 < tens_mapping.length; i3++) {
    if (num >= tens_mapping[i3][1]) {
      num -= tens_mapping[i3][1];
      arr.push(tens_mapping[i3][0]);
    }
  }
  if (ones_mapping[num]) {
    arr.push(ones_mapping[num]);
  }
  return arr;
};
var handle_decimal = (num) => {
  const names = ["zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"];
  let arr = [];
  let str = toString_default(num);
  let decimal = str.match(/\.([0-9]+)/);
  if (!decimal || !decimal[0]) {
    return arr;
  }
  arr.push("point");
  let decimals = decimal[0].split("");
  for (let i3 = 0; i3 < decimals.length; i3++) {
    arr.push(names[decimals[i3]]);
  }
  return arr;
};
var toText3 = function(obj) {
  let num = obj.num;
  if (num === 0 || num === "0") {
    return "zero";
  }
  if (num > 1e21) {
    num = toString_default(num);
  }
  let arr = [];
  if (num < 0) {
    arr.push("minus");
    num = Math.abs(num);
  }
  let units = breakdown_magnitudes(num);
  for (let i3 = 0; i3 < units.length; i3++) {
    let unit_name = units[i3].unit;
    if (unit_name === "one") {
      unit_name = "";
      if (arr.length > 1) {
        arr.push("and");
      }
    }
    arr = arr.concat(breakdown_hundred(units[i3].count));
    arr.push(unit_name);
  }
  arr = arr.concat(handle_decimal(num));
  arr = arr.filter((s3) => s3);
  if (arr.length === 0) {
    arr[0] = "";
  }
  return arr.join(" ");
};
var toText_default = toText3;

// node_modules/compromise/src/3-three/numbers/fractions/convert/toCardinal.js
var toCardinal = function(obj) {
  if (!obj.numerator || !obj.denominator) {
    return "";
  }
  let a2 = toText_default({ num: obj.numerator });
  let b = toText_default({ num: obj.denominator });
  return `${a2} out of ${b}`;
};
var toCardinal_default = toCardinal;

// node_modules/compromise/src/3-three/numbers/numbers/format/toOrdinal/textOrdinal.js
var irregulars = {
  one: "first",
  two: "second",
  three: "third",
  five: "fifth",
  eight: "eighth",
  nine: "ninth",
  twelve: "twelfth",
  twenty: "twentieth",
  thirty: "thirtieth",
  forty: "fortieth",
  fourty: "fourtieth",
  fifty: "fiftieth",
  sixty: "sixtieth",
  seventy: "seventieth",
  eighty: "eightieth",
  ninety: "ninetieth"
};
var textOrdinal = (obj) => {
  let words = toText_default(obj).split(" ");
  let last = words[words.length - 1];
  if (irregulars.hasOwnProperty(last)) {
    words[words.length - 1] = irregulars[last];
  } else {
    words[words.length - 1] = last.replace(/y$/, "i") + "th";
  }
  return words.join(" ");
};
var textOrdinal_default = textOrdinal;

// node_modules/compromise/src/3-three/numbers/fractions/convert/toOrdinal.js
var toOrdinal = function(obj) {
  if (!obj.numerator || !obj.denominator) {
    return "";
  }
  let start2 = toText_default({ num: obj.numerator });
  let end2 = textOrdinal_default({ num: obj.denominator });
  if (obj.denominator === 2) {
    end2 = "half";
  }
  if (start2 && end2) {
    if (obj.numerator !== 1) {
      end2 += "s";
    }
    return `${start2} ${end2}`;
  }
  return "";
};
var toOrdinal_default = toOrdinal;

// node_modules/compromise/src/3-three/numbers/fractions/api.js
var plugin3 = function(View2) {
  class Fractions extends View2 {
    constructor(document2, pointer, groups) {
      super(document2, pointer, groups);
      this.viewType = "Fractions";
    }
    parse(n3) {
      return this.getNth(n3).map(parse_default4);
    }
    get(n3) {
      return this.getNth(n3).map(parse_default4);
    }
    json(n3) {
      return this.getNth(n3).map((p5) => {
        let json = p5.toView().json(n3)[0];
        let parsed = parse_default4(p5);
        json.fraction = parsed;
        return json;
      }, []);
    }
    // become 0.5
    toDecimal(n3) {
      this.getNth(n3).forEach((m3) => {
        let { decimal } = parse_default4(m3);
        m3 = m3.replaceWith(String(decimal), true);
        m3.tag("NumericValue");
        m3.unTag("Fraction");
      });
      return this;
    }
    toFraction(n3) {
      this.getNth(n3).forEach((m3) => {
        let obj = parse_default4(m3);
        if (obj && typeof obj.numerator === "number" && typeof obj.denominator === "number") {
          let str = `${obj.numerator}/${obj.denominator}`;
          this.replace(m3, str);
        }
      });
      return this;
    }
    toOrdinal(n3) {
      this.getNth(n3).forEach((m3) => {
        let obj = parse_default4(m3);
        let str = toOrdinal_default(obj);
        if (m3.after("^#Noun").found) {
          str += " of";
        }
        m3.replaceWith(str);
      });
      return this;
    }
    toCardinal(n3) {
      this.getNth(n3).forEach((m3) => {
        let obj = parse_default4(m3);
        let str = toCardinal_default(obj);
        m3.replaceWith(str);
      });
      return this;
    }
    toPercentage(n3) {
      this.getNth(n3).forEach((m3) => {
        let { decimal } = parse_default4(m3);
        let percent = decimal * 100;
        percent = Math.round(percent * 100) / 100;
        m3.replaceWith(`${percent}%`);
      });
      return this;
    }
  }
  View2.prototype.fractions = function(n3) {
    let m3 = find_default2(this);
    m3 = m3.getNth(n3);
    return new Fractions(this.document, m3.pointer);
  };
};
var api_default15 = plugin3;

// node_modules/compromise/src/3-three/numbers/numbers/find.js
var ones = "one|two|three|four|five|six|seven|eight|nine";
var tens = "twenty|thirty|forty|fifty|sixty|seventy|eighty|ninety|fourty";
var teens = "eleven|twelve|thirteen|fourteen|fifteen|sixteen|seventeen|eighteen|nineteen";
var findNumbers = function(doc) {
  let m3 = doc.match("#Value+");
  if (m3.has("#NumericValue #NumericValue")) {
    if (m3.has("#Value @hasComma #Value")) {
      m3.splitAfter("@hasComma");
    } else if (m3.has("#NumericValue #Fraction")) {
      m3.splitAfter("#NumericValue #Fraction");
    } else {
      m3 = m3.splitAfter("#NumericValue");
    }
  }
  if (m3.has("#Value #Value #Value") && !m3.has("#Multiple")) {
    if (m3.has("(" + tens + ") #Cardinal #Cardinal")) {
      m3 = m3.splitAfter("(" + tens + ") #Cardinal");
    }
  }
  if (m3.has("#Value #Value")) {
    if (m3.has("#NumericValue #NumericValue")) {
      m3 = m3.splitOn("#Year");
    }
    if (m3.has("(" + tens + ") (" + teens + ")")) {
      m3 = m3.splitAfter("(" + tens + ")");
    }
    let double = m3.match("#Cardinal #Cardinal");
    if (double.found && !m3.has("(point|decimal|#Fraction)")) {
      if (!double.has("#Cardinal (#Multiple|point|decimal)")) {
        let noMultiple = m3.has(`(${ones}) (${tens})`);
        let tensVal = double.has("(" + tens + ") #Cardinal");
        let multVal = double.has("#Multiple #Value");
        if (!noMultiple && !tensVal && !multVal) {
          double.terms().forEach((d2) => {
            m3 = m3.splitOn(d2);
          });
        }
      }
    }
    if (m3.match("#Ordinal #Ordinal").match("#TextValue").found && !m3.has("#Multiple")) {
      if (!m3.has("(" + tens + ") #Ordinal")) {
        m3 = m3.splitAfter("#Ordinal");
      }
    }
    m3 = m3.splitBefore("#Ordinal [#Cardinal]", 0);
    if (m3.has("#TextValue #NumericValue") && !m3.has("(" + tens + "|#Multiple)")) {
      m3 = m3.splitBefore("#TextValue #NumericValue");
    }
  }
  m3 = m3.splitAfter("#NumberRange");
  m3 = m3.splitBefore("#Year");
  return m3;
};
var find_default3 = findNumbers;

// node_modules/compromise/src/3-three/numbers/numbers/parse/index.js
var parseNumeric2 = function(str, m3) {
  str = str.replace(/,/g, "");
  let arr = str.split(/([0-9.,]*)/);
  let [prefix5, num] = arr;
  let suffix = arr.slice(2).join("");
  if (num !== "" && m3.length < 2) {
    num = Number(num || str);
    if (typeof num !== "number") {
      num = null;
    }
    suffix = suffix || "";
    if (suffix === "st" || suffix === "nd" || suffix === "rd" || suffix === "th") {
      suffix = "";
    }
    return {
      prefix: prefix5 || "",
      num,
      suffix
    };
  }
  return null;
};
var parseNumber2 = function(m3) {
  if (typeof m3 === "string") {
    return { num: toNumber_default(m3) };
  }
  let str = m3.text("reduced");
  let unit = m3.growRight("#Unit").match("#Unit$").text("machine");
  let hasComma = /[0-9],[0-9]/.test(m3.text("text"));
  if (m3.terms().length === 1 && !m3.has("#Multiple")) {
    let res = parseNumeric2(str, m3);
    if (res !== null) {
      res.hasComma = hasComma;
      res.unit = unit;
      return res;
    }
  }
  let frPart = m3.match("#Fraction{2,}$");
  frPart = frPart.found === false ? m3.match("^#Fraction$") : frPart;
  let fraction = null;
  if (frPart.found) {
    if (frPart.has("#Value and #Value #Fraction")) {
      frPart = frPart.match("and #Value #Fraction");
    }
    fraction = parse_default4(frPart);
    m3 = m3.not(frPart);
    m3 = m3.not("and$");
    str = m3.text("reduced");
  }
  let num = 0;
  if (str) {
    num = toNumber_default(str) || 0;
  }
  if (fraction && fraction.decimal) {
    num += fraction.decimal;
  }
  return {
    hasComma,
    prefix: "",
    num,
    suffix: "",
    isOrdinal: m3.has("#Ordinal"),
    isText: m3.has("#TextValue"),
    isFraction: m3.has("#Fraction"),
    isMoney: m3.has("#Money"),
    unit
  };
};
var parse_default5 = parseNumber2;

// node_modules/compromise/src/3-three/numbers/numbers/format/toOrdinal/numOrdinal.js
var numOrdinal = function(obj) {
  let num = obj.num;
  if (!num && num !== 0) {
    return null;
  }
  let tens2 = num % 100;
  if (tens2 > 10 && tens2 < 20) {
    return String(num) + "th";
  }
  const mapping3 = {
    0: "th",
    1: "st",
    2: "nd",
    3: "rd"
  };
  let str = toString_default(num);
  let last = str.slice(str.length - 1, str.length);
  if (mapping3[last]) {
    str += mapping3[last];
  } else {
    str += "th";
  }
  return str;
};
var numOrdinal_default = numOrdinal;

// node_modules/compromise/src/3-three/numbers/numbers/format/suffix.js
var prefixes = {
  "\xA2": "cents",
  $: "dollars",
  "\xA3": "pounds",
  "\xA5": "yen",
  "\u20AC": "euros",
  "\u20A1": "col\xF3n",
  "\u0E3F": "baht",
  "\u20AD": "kip",
  "\u20A9": "won",
  "\u20B9": "rupees",
  "\u20BD": "ruble",
  "\u20BA": "liras"
};
var suffixes4 = {
  "%": "percent",
  // s: 'seconds',
  // cm: 'centimetres',
  // km: 'kilometres',
  // ft: 'feet',
  "\xB0": "degrees"
};
var addSuffix = function(obj) {
  let res = {
    suffix: "",
    prefix: obj.prefix
  };
  if (prefixes.hasOwnProperty(obj.prefix)) {
    res.suffix += " " + prefixes[obj.prefix];
    res.prefix = "";
  }
  if (suffixes4.hasOwnProperty(obj.suffix)) {
    res.suffix += " " + suffixes4[obj.suffix];
  }
  if (res.suffix && obj.num === 1) {
    res.suffix = res.suffix.replace(/s$/, "");
  }
  if (!res.suffix && obj.suffix) {
    res.suffix += " " + obj.suffix;
  }
  return res;
};
var suffix_default2 = addSuffix;

// node_modules/compromise/src/3-three/numbers/numbers/format/index.js
var format = function(obj, fmt2) {
  if (fmt2 === "TextOrdinal") {
    let { prefix: prefix5, suffix } = suffix_default2(obj);
    return prefix5 + textOrdinal_default(obj) + suffix;
  }
  if (fmt2 === "Ordinal") {
    return obj.prefix + numOrdinal_default(obj) + obj.suffix;
  }
  if (fmt2 === "TextCardinal") {
    let { prefix: prefix5, suffix } = suffix_default2(obj);
    return prefix5 + toText_default(obj) + suffix;
  }
  let num = obj.num;
  if (obj.hasComma) {
    num = num.toLocaleString();
  }
  return obj.prefix + String(num) + obj.suffix;
};
var format_default = format;

// node_modules/compromise/src/3-three/numbers/numbers/isUnit.js
var isArray11 = (arr) => Object.prototype.toString.call(arr) === "[object Array]";
var coerceToObject = function(input) {
  if (typeof input === "string" || typeof input === "number") {
    let tmp = {};
    tmp[input] = true;
    return tmp;
  }
  if (isArray11(input)) {
    return input.reduce((h2, s3) => {
      h2[s3] = true;
      return h2;
    }, {});
  }
  return input || {};
};
var isUnit = function(doc, input = {}) {
  input = coerceToObject(input);
  return doc.filter((p5) => {
    let { unit } = parse_default5(p5);
    if (unit && input[unit] === true) {
      return true;
    }
    return false;
  });
};
var isUnit_default = isUnit;

// node_modules/compromise/src/3-three/numbers/numbers/api.js
var addMethod = function(View2) {
  class Numbers extends View2 {
    constructor(document2, pointer, groups) {
      super(document2, pointer, groups);
      this.viewType = "Numbers";
    }
    parse(n3) {
      return this.getNth(n3).map(parse_default5);
    }
    get(n3) {
      return this.getNth(n3).map(parse_default5).map((o2) => o2.num);
    }
    json(n3) {
      let opts2 = typeof n3 === "object" ? n3 : {};
      return this.getNth(n3).map((p5) => {
        let json = p5.toView().json(opts2)[0];
        let parsed = parse_default5(p5);
        json.number = {
          prefix: parsed.prefix,
          num: parsed.num,
          suffix: parsed.suffix,
          hasComma: parsed.hasComma,
          unit: parsed.unit
        };
        return json;
      }, []);
    }
    /** any known measurement unit, for the number */
    units() {
      return this.growRight("#Unit").match("#Unit$");
    }
    /** return values that match a given unit */
    isUnit(allowed) {
      return isUnit_default(this, allowed);
    }
    /** return only ordinal numbers */
    isOrdinal() {
      return this.if("#Ordinal");
    }
    /** return only cardinal numbers*/
    isCardinal() {
      return this.if("#Cardinal");
    }
    /** convert to numeric form like '8' or '8th' */
    toNumber() {
      let res = this.map((val) => {
        if (!this.has("#TextValue")) {
          return val;
        }
        let obj = parse_default5(val);
        if (obj.num === null) {
          return val;
        }
        let fmt2 = val.has("#Ordinal") ? "Ordinal" : "Cardinal";
        let str = format_default(obj, fmt2);
        val.replaceWith(str, { tags: true });
        return val.tag("NumericValue");
      });
      return new Numbers(res.document, res.pointer);
    }
    /** add commas, or nicer formatting for numbers */
    toLocaleString() {
      let m3 = this;
      m3.forEach((val) => {
        let obj = parse_default5(val);
        if (obj.num === null) {
          return;
        }
        let num = obj.num.toLocaleString();
        if (val.has("#Ordinal")) {
          let str = format_default(obj, "Ordinal");
          let end2 = str.match(/[a-z]+$/);
          if (end2) {
            num += end2[0] || "";
          }
        }
        val.replaceWith(num, { tags: true });
      });
      return this;
    }
    /** convert to numeric form like 'eight' or 'eighth' */
    toText() {
      let m3 = this;
      let res = m3.map((val) => {
        if (val.has("#TextValue")) {
          return val;
        }
        let obj = parse_default5(val);
        if (obj.num === null) {
          return val;
        }
        let fmt2 = val.has("#Ordinal") ? "TextOrdinal" : "TextCardinal";
        let str = format_default(obj, fmt2);
        val.replaceWith(str, { tags: true });
        val.tag("TextValue");
        return val;
      });
      return new Numbers(res.document, res.pointer);
    }
    /** convert ordinal to cardinal form, like 'eight', or '8' */
    toCardinal() {
      let m3 = this;
      let res = m3.map((val) => {
        if (!val.has("#Ordinal")) {
          return val;
        }
        let obj = parse_default5(val);
        if (obj.num === null) {
          return val;
        }
        let fmt2 = val.has("#TextValue") ? "TextCardinal" : "Cardinal";
        let str = format_default(obj, fmt2);
        val.replaceWith(str, { tags: true });
        val.tag("Cardinal");
        return val;
      });
      return new Numbers(res.document, res.pointer);
    }
    /** convert cardinal to ordinal form, like 'eighth', or '8th' */
    toOrdinal() {
      let m3 = this;
      let res = m3.map((val) => {
        if (val.has("#Ordinal")) {
          return val;
        }
        let obj = parse_default5(val);
        if (obj.num === null) {
          return val;
        }
        let fmt2 = val.has("#TextValue") ? "TextOrdinal" : "Ordinal";
        let str = format_default(obj, fmt2);
        val.replaceWith(str, { tags: true });
        val.tag("Ordinal");
        return val;
      });
      return new Numbers(res.document, res.pointer);
    }
    /** return only numbers that are == n */
    isEqual(n3) {
      return this.filter((val) => {
        let num = parse_default5(val).num;
        return num === n3;
      });
    }
    /** return only numbers that are > n*/
    greaterThan(n3) {
      return this.filter((val) => {
        let num = parse_default5(val).num;
        return num > n3;
      });
    }
    /** return only numbers that are < n*/
    lessThan(n3) {
      return this.filter((val) => {
        let num = parse_default5(val).num;
        return num < n3;
      });
    }
    /** return only numbers > min and < max */
    between(min2, max3) {
      return this.filter((val) => {
        let num = parse_default5(val).num;
        return num > min2 && num < max3;
      });
    }
    /** set these number to n */
    set(n3) {
      if (n3 === void 0) {
        return this;
      }
      if (typeof n3 === "string") {
        n3 = parse_default5(n3).num;
      }
      let m3 = this;
      let res = m3.map((val) => {
        let obj = parse_default5(val);
        obj.num = n3;
        if (obj.num === null) {
          return val;
        }
        let fmt2 = val.has("#Ordinal") ? "Ordinal" : "Cardinal";
        if (val.has("#TextValue")) {
          fmt2 = val.has("#Ordinal") ? "TextOrdinal" : "TextCardinal";
        }
        let str = format_default(obj, fmt2);
        if (obj.hasComma && fmt2 === "Cardinal") {
          str = Number(str).toLocaleString();
        }
        val = val.not("#Currency");
        val.replaceWith(str, { tags: true });
        return val;
      });
      return new Numbers(res.document, res.pointer);
    }
    add(n3) {
      if (!n3) {
        return this;
      }
      if (typeof n3 === "string") {
        n3 = parse_default5(n3).num;
      }
      let m3 = this;
      let res = m3.map((val) => {
        let obj = parse_default5(val);
        if (obj.num === null) {
          return val;
        }
        obj.num += n3;
        let fmt2 = val.has("#Ordinal") ? "Ordinal" : "Cardinal";
        if (obj.isText) {
          fmt2 = val.has("#Ordinal") ? "TextOrdinal" : "TextCardinal";
        }
        let str = format_default(obj, fmt2);
        val.replaceWith(str, { tags: true });
        return val;
      });
      return new Numbers(res.document, res.pointer);
    }
    /** decrease each number by n*/
    subtract(n3, agree) {
      return this.add(n3 * -1, agree);
    }
    /** increase each number by 1 */
    increment(agree) {
      return this.add(1, agree);
    }
    /** decrease each number by 1 */
    decrement(agree) {
      return this.add(-1, agree);
    }
    // overloaded - keep Numbers class
    update(pointer) {
      let m3 = new Numbers(this.document, pointer);
      m3._cache = this._cache;
      return m3;
    }
  }
  Numbers.prototype.toNice = Numbers.prototype.toLocaleString;
  Numbers.prototype.isBetween = Numbers.prototype.between;
  Numbers.prototype.minus = Numbers.prototype.subtract;
  Numbers.prototype.plus = Numbers.prototype.add;
  Numbers.prototype.equals = Numbers.prototype.isEqual;
  View2.prototype.numbers = function(n3) {
    let m3 = find_default3(this);
    m3 = m3.getNth(n3);
    return new Numbers(this.document, m3.pointer);
  };
  View2.prototype.percentages = function(n3) {
    let m3 = find_default3(this);
    m3 = m3.filter((v2) => v2.has("#Percent") || v2.after("^percent"));
    m3 = m3.getNth(n3);
    return new Numbers(this.document, m3.pointer);
  };
  View2.prototype.money = function(n3) {
    let m3 = find_default3(this);
    m3 = m3.filter((v2) => v2.has("#Money") || v2.after("^#Currency"));
    m3 = m3.getNth(n3);
    return new Numbers(this.document, m3.pointer);
  };
  View2.prototype.values = View2.prototype.numbers;
};
var api_default16 = addMethod;

// node_modules/compromise/src/3-three/numbers/plugin.js
var api14 = function(View2) {
  api_default15(View2);
  api_default16(View2);
};
var plugin_default25 = {
  api: api14
  // add @greaterThan, @lessThan
  // mutate: world => {
  //   let termMethods = world.methods.one.termMethods
  //   termMethods.lessThan = function (term) {
  //     return false //TODO: implement
  //     // return /[aeiou]/.test(term.text)
  //   }
  // },
};

// node_modules/compromise/src/3-three/redact/plugin.js
var defaults3 = {
  people: true,
  emails: true,
  phoneNumbers: true,
  places: true
};
var redact = function(opts2 = {}) {
  opts2 = Object.assign({}, defaults3, opts2);
  if (opts2.people !== false) {
    this.people().replaceWith("\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588");
  }
  if (opts2.emails !== false) {
    this.emails().replaceWith("\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588");
  }
  if (opts2.places !== false) {
    this.places().replaceWith("\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588");
  }
  if (opts2.phoneNumbers !== false) {
    this.phoneNumbers().replaceWith("\u2588\u2588\u2588\u2588\u2588\u2588\u2588");
  }
  return this;
};
var plugin4 = {
  api: function(View2) {
    View2.prototype.redact = redact;
  }
};
var plugin_default26 = plugin4;

// node_modules/compromise/src/3-three/sentences/questions.js
var isQuestion = function(doc) {
  let clauses2 = doc.clauses();
  if (/\.\.$/.test(doc.out("text"))) {
    return false;
  }
  if (doc.has("^#QuestionWord") && doc.has("@hasComma")) {
    return false;
  }
  if (doc.has("or not$")) {
    return true;
  }
  if (doc.has("^#QuestionWord")) {
    return true;
  }
  if (doc.has("^(do|does|did|is|was|can|could|will|would|may) #Noun")) {
    return true;
  }
  if (doc.has("^(have|must) you")) {
    return true;
  }
  if (clauses2.has("(do|does|is|was) #Noun+ #Adverb? (#Adjective|#Infinitive)$")) {
    return true;
  }
  return false;
};
var findQuestions = function(view) {
  const hasQ = /\?/;
  const { document: document2 } = view;
  return view.filter((m3) => {
    let terms = m3.docs[0] || [];
    let lastTerm = terms[terms.length - 1];
    if (!lastTerm || document2[lastTerm.index[0]].length !== terms.length) {
      return false;
    }
    if (hasQ.test(lastTerm.post)) {
      return true;
    }
    return isQuestion(m3);
  });
};
var questions_default = findQuestions;

// node_modules/compromise/src/3-three/sentences/parse/mainClause.js
var subordinate = `(after|although|as|because|before|if|since|than|that|though|when|whenever|where|whereas|wherever|whether|while|why|unless|until|once)`;
var relative = `(that|which|whichever|who|whoever|whom|whose|whomever)`;
var mainClause = function(s3) {
  let m3 = s3;
  if (m3.length === 1) {
    return m3;
  }
  m3 = m3.if("#Verb");
  if (m3.length === 1) {
    return m3;
  }
  m3 = m3.ifNo(subordinate);
  m3 = m3.ifNo("^even (if|though)");
  m3 = m3.ifNo("^so that");
  m3 = m3.ifNo("^rather than");
  m3 = m3.ifNo("^provided that");
  if (m3.length === 1) {
    return m3;
  }
  m3 = m3.ifNo(relative);
  if (m3.length === 1) {
    return m3;
  }
  m3 = m3.ifNo("(^despite|^during|^before|^through|^throughout)");
  if (m3.length === 1) {
    return m3;
  }
  m3 = m3.ifNo("^#Gerund");
  if (m3.length === 1) {
    return m3;
  }
  if (m3.length === 0) {
    m3 = s3;
  }
  return m3.eq(0);
};
var mainClause_default = mainClause;

// node_modules/compromise/src/3-three/sentences/parse/index.js
var grammar = function(vb3) {
  let tense = null;
  if (vb3.has("#PastTense")) {
    tense = "PastTense";
  } else if (vb3.has("#FutureTense")) {
    tense = "FutureTense";
  } else if (vb3.has("#PresentTense")) {
    tense = "PresentTense";
  }
  return {
    tense
  };
};
var parse5 = function(s3) {
  let clauses2 = s3.clauses();
  let main = mainClause_default(clauses2);
  let chunks2 = main.chunks();
  let subj = s3.none();
  let verb = s3.none();
  let pred = s3.none();
  chunks2.forEach((ch, i3) => {
    if (i3 === 0 && !ch.has("<Verb>")) {
      subj = ch;
      return;
    }
    if (!verb.found && ch.has("<Verb>")) {
      verb = ch;
      return;
    }
    if (verb.found) {
      pred = pred.concat(ch);
    }
  });
  if (verb.found && !subj.found) {
    subj = verb.before("<Noun>+").first();
  }
  return {
    subj,
    verb,
    pred,
    grammar: grammar(verb)
  };
};
var parse_default6 = parse5;

// node_modules/compromise/src/3-three/sentences/conjugate/toPast.js
var toPast2 = function(s3) {
  let verbs = s3.verbs();
  let first = verbs.eq(0);
  if (first.has("#PastTense")) {
    return s3;
  }
  first.toPastTense();
  if (verbs.length > 1) {
    verbs = verbs.slice(1);
    verbs = verbs.filter((v2) => !v2.lookBehind("to$").found);
    verbs = verbs.if("#PresentTense");
    verbs = verbs.notIf("#Gerund");
    let list4 = s3.match("to #Verb+ #Conjunction #Verb").terms();
    verbs = verbs.not(list4);
    if (verbs.found) {
      verbs.verbs().toPastTense();
    }
  }
  return s3;
};
var toPast_default = toPast2;

// node_modules/compromise/src/3-three/sentences/conjugate/toPresent.js
var toPresent2 = function(s3) {
  let verbs = s3.verbs();
  let first = verbs.eq(0);
  first.toPresentTense();
  if (verbs.length > 1) {
    verbs = verbs.slice(1);
    verbs = verbs.filter((v2) => !v2.lookBehind("to$").found);
    verbs = verbs.notIf("#Gerund");
    if (verbs.found) {
      verbs.verbs().toPresentTense();
    }
  }
  return s3;
};
var toPresent_default = toPresent2;

// node_modules/compromise/src/3-three/sentences/conjugate/toFuture.js
var toFuture = function(s3) {
  let verbs = s3.verbs();
  let first = verbs.eq(0);
  first.toFutureTense();
  s3 = s3.fullSentence();
  verbs = s3.verbs();
  if (verbs.length > 1) {
    verbs = verbs.slice(1);
    let toChange = verbs.filter((vb3) => {
      if (vb3.lookBehind("to$").found) {
        return false;
      }
      if (vb3.has("#Copula #Gerund")) {
        return true;
      }
      if (vb3.has("#Gerund")) {
        return false;
      }
      if (vb3.has("#Copula")) {
        return true;
      }
      if (vb3.has("#PresentTense") && !vb3.has("#Infinitive") && vb3.lookBefore("(he|she|it|that|which)$").found) {
        return false;
      }
      return true;
    });
    if (toChange.found) {
      toChange.forEach((m3) => {
        if (m3.has("#Copula")) {
          m3.match("was").replaceWith("is");
          m3.match("is").replaceWith("will be");
          return;
        }
        m3.toInfinitive();
      });
    }
  }
  return s3;
};
var toFuture_default = toFuture;

// node_modules/compromise/src/3-three/sentences/conjugate/toNegative.js
var toNegative = function(s3) {
  s3.verbs().first().toNegative().compute("chunks");
  return s3;
};
var toPositive = function(s3) {
  s3.verbs().first().toPositive().compute("chunks");
  return s3;
};

// node_modules/compromise/src/3-three/sentences/conjugate/toInfinitive.js
var toInfinitive2 = function(s3) {
  s3.verbs().toInfinitive();
  return s3;
};
var toInfinitive_default2 = toInfinitive2;

// node_modules/compromise/src/3-three/sentences/api.js
var api15 = function(View2) {
  class Sentences extends View2 {
    constructor(document2, pointer, groups) {
      super(document2, pointer, groups);
      this.viewType = "Sentences";
    }
    json(opts2 = {}) {
      return this.map((m3) => {
        let json = m3.toView().json(opts2)[0] || {};
        let { subj, verb, pred, grammar: grammar2 } = parse_default6(m3);
        json.sentence = {
          subject: subj.text("normal"),
          verb: verb.text("normal"),
          predicate: pred.text("normal"),
          grammar: grammar2
        };
        return json;
      }, []);
    }
    toPastTense(n3) {
      return this.getNth(n3).map((s3) => {
        let parsed = parse_default6(s3);
        return toPast_default(s3, parsed);
      });
    }
    toPresentTense(n3) {
      return this.getNth(n3).map((s3) => {
        let parsed = parse_default6(s3);
        return toPresent_default(s3, parsed);
      });
    }
    toFutureTense(n3) {
      return this.getNth(n3).map((s3) => {
        let parsed = parse_default6(s3);
        s3 = toFuture_default(s3, parsed);
        return s3;
      });
    }
    toInfinitive(n3) {
      return this.getNth(n3).map((s3) => {
        let parsed = parse_default6(s3);
        return toInfinitive_default2(s3, parsed);
      });
    }
    toNegative(n3) {
      return this.getNth(n3).map((vb3) => {
        let parsed = parse_default6(vb3);
        return toNegative(vb3, parsed);
      });
    }
    toPositive(n3) {
      return this.getNth(n3).map((vb3) => {
        let parsed = parse_default6(vb3);
        return toPositive(vb3, parsed);
      });
    }
    isQuestion(n3) {
      return this.questions(n3);
    }
    isExclamation(n3) {
      let res = this.filter((s3) => s3.lastTerm().has("@hasExclamation"));
      return res.getNth(n3);
    }
    isStatement(n3) {
      let res = this.filter((s3) => !s3.isExclamation().found && !s3.isQuestion().found);
      return res.getNth(n3);
    }
    // overloaded - keep Sentences class
    update(pointer) {
      let m3 = new Sentences(this.document, pointer);
      m3._cache = this._cache;
      return m3;
    }
  }
  Sentences.prototype.toPresent = Sentences.prototype.toPresentTense;
  Sentences.prototype.toPast = Sentences.prototype.toPastTense;
  Sentences.prototype.toFuture = Sentences.prototype.toFutureTense;
  const methods17 = {
    sentences: function(n3) {
      let m3 = this.map((s3) => s3.fullSentence());
      m3 = m3.getNth(n3);
      return new Sentences(this.document, m3.pointer);
    },
    questions: function(n3) {
      let m3 = questions_default(this);
      return m3.getNth(n3);
    }
  };
  Object.assign(View2.prototype, methods17);
};
var api_default17 = api15;

// node_modules/compromise/src/3-three/sentences/plugin.js
var plugin_default27 = { api: api_default17 };

// node_modules/compromise/src/3-three/topics/people/find.js
var find5 = function(doc) {
  let m3 = doc.splitAfter("@hasComma");
  m3 = m3.match("#Honorific+? #Person+");
  let poss = m3.match("#Possessive").notIf("(his|her)");
  m3 = m3.splitAfter(poss);
  return m3;
};
var find_default4 = find5;

// node_modules/compromise/src/3-three/topics/people/parse.js
var parse6 = function(m3) {
  let res = {};
  res.firstName = m3.match("#FirstName+");
  res.lastName = m3.match("#LastName+");
  res.honorific = m3.match("#Honorific+");
  let last = res.lastName;
  let first = res.firstName;
  if (!first.found || !last.found) {
    if (!first.found && !last.found && m3.has("^#Honorific .$")) {
      res.lastName = m3.match(".$");
      return res;
    }
  }
  return res;
};
var parse_default7 = parse6;

// node_modules/compromise/src/3-three/topics/people/gender.js
var m2 = "male";
var f2 = "female";
var honorifics = {
  mr: m2,
  mrs: f2,
  miss: f2,
  madam: f2,
  // british stuff
  king: m2,
  queen: f2,
  duke: m2,
  duchess: f2,
  baron: m2,
  baroness: f2,
  count: m2,
  countess: f2,
  prince: m2,
  princess: f2,
  sire: m2,
  dame: f2,
  lady: f2,
  ayatullah: m2,
  //i think?
  congressman: m2,
  congresswoman: f2,
  "first lady": f2,
  // marked as non-binary
  mx: null
};
var predictGender = function(parsed, person) {
  let { firstName, honorific } = parsed;
  if (firstName.has("#FemaleName")) {
    return f2;
  }
  if (firstName.has("#MaleName")) {
    return m2;
  }
  if (honorific.found) {
    let hon = honorific.text("normal");
    hon = hon.replace(/\./g, "");
    if (honorifics.hasOwnProperty(hon)) {
      return honorifics[hon];
    }
    if (/^her /.test(hon)) {
      return f2;
    }
    if (/^his /.test(hon)) {
      return m2;
    }
  }
  let after2 = person.after();
  if (!after2.has("#Person") && after2.has("#Pronoun")) {
    let pro = after2.match("#Pronoun");
    if (pro.has("(they|their)")) {
      return null;
    }
    let hasMasc = pro.has("(he|his)");
    let hasFem = pro.has("(she|her|hers)");
    if (hasMasc && !hasFem) {
      return m2;
    }
    if (hasFem && !hasMasc) {
      return f2;
    }
  }
  return null;
};
var gender_default = predictGender;

// node_modules/compromise/src/3-three/topics/people/api.js
var addMethod2 = function(View2) {
  class People extends View2 {
    constructor(document2, pointer, groups) {
      super(document2, pointer, groups);
      this.viewType = "People";
    }
    parse(n3) {
      return this.getNth(n3).map(parse_default7);
    }
    json(n3) {
      let opts2 = typeof n3 === "object" ? n3 : {};
      return this.getNth(n3).map((p5) => {
        let json = p5.toView().json(opts2)[0];
        let parsed = parse_default7(p5);
        json.person = {
          firstName: parsed.firstName.text("normal"),
          lastName: parsed.lastName.text("normal"),
          honorific: parsed.honorific.text("normal"),
          presumed_gender: gender_default(parsed, p5)
        };
        return json;
      }, []);
    }
    // used for co-reference resolution only
    presumedMale() {
      return this.filter((m3) => {
        return m3.has("(#MaleName|mr|mister|sr|jr|king|pope|prince|sir)");
      });
    }
    presumedFemale() {
      return this.filter((m3) => {
        return m3.has("(#FemaleName|mrs|miss|queen|princess|madam)");
      });
    }
    // overloaded - keep People class
    update(pointer) {
      let m3 = new People(this.document, pointer);
      m3._cache = this._cache;
      return m3;
    }
  }
  View2.prototype.people = function(n3) {
    let m3 = find_default4(this);
    m3 = m3.getNth(n3);
    return new People(this.document, m3.pointer);
  };
};
var api_default18 = addMethod2;

// node_modules/compromise/src/3-three/topics/places/find.js
var find6 = function(doc) {
  let m3 = doc.match("(#Place|#Address)+");
  let splits = m3.match("@hasComma");
  splits = splits.filter((c2) => {
    if (c2.has("(asia|africa|europe|america)$")) {
      return true;
    }
    if (c2.has("(#City|#Region|#ProperNoun)$") && c2.after("^(#Country|#Region)").found) {
      return false;
    }
    return true;
  });
  m3 = m3.splitAfter(splits);
  return m3;
};
var find_default5 = find6;

// node_modules/compromise/src/3-three/topics/places/api.js
var addMethod3 = function(View2) {
  View2.prototype.places = function(n3) {
    let m3 = find_default5(this);
    m3 = m3.getNth(n3);
    return new View2(this.document, m3.pointer);
  };
};
var api_default19 = addMethod3;

// node_modules/compromise/src/3-three/topics/orgs/api.js
var api16 = function(View2) {
  View2.prototype.organizations = function(n3) {
    let m3 = this.match("#Organization+");
    return m3.getNth(n3);
  };
};
var api_default20 = api16;

// node_modules/compromise/src/3-three/topics/topics.js
var find7 = function(n3) {
  let r2 = this.clauses();
  let m3 = r2.people();
  m3 = m3.concat(r2.places());
  m3 = m3.concat(r2.organizations());
  m3 = m3.not("(someone|man|woman|mother|brother|sister|father)");
  m3 = m3.sort("seq");
  m3 = m3.getNth(n3);
  return m3;
};
var api17 = function(View2) {
  View2.prototype.topics = find7;
};
var topics_default = api17;

// node_modules/compromise/src/3-three/topics/plugin.js
var api18 = function(View2) {
  api_default18(View2);
  api_default19(View2);
  api_default20(View2);
  topics_default(View2);
};
var plugin_default28 = { api: api18 };

// node_modules/compromise/src/3-three/verbs/find.js
var findVerbs = function(doc) {
  let m3 = doc.match("<Verb>");
  m3 = m3.not("#Conjunction");
  m3 = m3.not("#Preposition");
  m3 = m3.splitAfter("@hasComma");
  m3 = m3.splitAfter("[(do|did|am|was|is|will)] (is|was)", 0);
  m3 = m3.splitBefore("(#Verb && !#Copula) [being] #Verb", 0);
  m3 = m3.splitBefore("#Verb [to be] #Verb", 0);
  m3 = m3.splitAfter("[help] #PresentTense", 0);
  m3 = m3.splitBefore("(#PresentTense|#PastTense) [#Copula]$", 0);
  m3 = m3.splitBefore("(#PresentTense|#PastTense) [will be]$", 0);
  m3 = m3.splitBefore("(#PresentTense|#PastTense) [(had|has)]", 0);
  m3 = m3.not("#Reflexive$");
  m3 = m3.not("#Adjective");
  m3 = m3.splitAfter("[#PastTense] #PastTense", 0);
  m3 = m3.splitAfter("[#PastTense] #Auxiliary+ #PastTense", 0);
  m3 = m3.splitAfter("#Copula [#Gerund] #PastTense", 0);
  m3 = m3.if("#Verb");
  if (m3.has("(#Verb && !#Auxiliary) #Adverb+? #Copula")) {
    m3 = m3.splitBefore("#Copula");
  }
  return m3;
};
var find_default6 = findVerbs;

// node_modules/compromise/src/3-three/verbs/api/parse/root.js
var getMain = function(vb3) {
  let root6 = vb3;
  if (vb3.wordCount() > 1) {
    root6 = vb3.not("(#Negative|#Auxiliary|#Modal|#Adverb|#Prefix)");
  }
  if (root6.length > 1 && !root6.has("#Phrasal #Particle")) {
    root6 = root6.last();
  }
  root6 = root6.not("(want|wants|wanted) to");
  if (!root6.found) {
    root6 = vb3.not("#Negative");
    return root6;
  }
  return root6;
};
var root_default2 = getMain;

// node_modules/compromise/src/3-three/verbs/api/parse/adverbs.js
var getAdverbs = function(vb3, root6) {
  let res = {
    pre: vb3.none(),
    post: vb3.none()
  };
  if (!vb3.has("#Adverb")) {
    return res;
  }
  let parts = vb3.splitOn(root6);
  if (parts.length === 3) {
    return {
      pre: parts.eq(0).adverbs(),
      post: parts.eq(2).adverbs()
    };
  }
  if (parts.eq(0).isDoc(root6)) {
    res.post = parts.eq(1).adverbs();
    return res;
  }
  res.pre = parts.eq(0).adverbs();
  return res;
};
var adverbs_default = getAdverbs;

// node_modules/compromise/src/3-three/verbs/api/parse/index.js
var getAuxiliary = function(vb3, root6) {
  let parts = vb3.splitBefore(root6);
  if (parts.length <= 1) {
    return vb3.none();
  }
  let aux = parts.eq(0);
  aux = aux.not("(#Adverb|#Negative|#Prefix)");
  return aux;
};
var getNegative = function(vb3) {
  return vb3.match("#Negative");
};
var getPhrasal = function(root6) {
  if (!root6.has("(#Particle|#PhrasalVerb)")) {
    return {
      verb: root6.none(),
      particle: root6.none()
    };
  }
  let particle = root6.match("#Particle$");
  return {
    verb: root6.not(particle),
    particle
  };
};
var parseVerb = function(view) {
  let vb3 = view.clone();
  vb3.contractions().expand();
  const root6 = root_default2(vb3);
  let res = {
    root: root6,
    prefix: vb3.match("#Prefix"),
    adverbs: adverbs_default(vb3, root6),
    auxiliary: getAuxiliary(vb3, root6),
    negative: getNegative(vb3),
    phrasal: getPhrasal(root6)
  };
  return res;
};
var parse_default8 = parseVerb;

// node_modules/compromise/src/3-three/verbs/api/parse/grammar/forms.js
var present = { tense: "PresentTense" };
var conditional = { conditional: true };
var future = { tense: "FutureTense" };
var prog = { progressive: true };
var past2 = { tense: "PastTense" };
var complete = { complete: true, progressive: false };
var passive2 = { passive: true };
var plural = { plural: true };
var singular = { plural: false };
var getData = function(tags) {
  let data = {};
  tags.forEach((o2) => {
    Object.assign(data, o2);
  });
  return data;
};
var verbForms = {
  // === Simple ===
  "imperative": [
    // walk!
    ["#Imperative", []]
  ],
  "want-infinitive": [
    ["^(want|wants|wanted) to #Infinitive$", [present]],
    ["^wanted to #Infinitive$", [past2]],
    ["^will want to #Infinitive$", [future]]
  ],
  "gerund-phrase": [
    // started looking
    ["^#PastTense #Gerund$", [past2]],
    // starts looking
    ["^#PresentTense #Gerund$", [present]],
    // start looking
    ["^#Infinitive #Gerund$", [present]],
    // will start looking
    ["^will #Infinitive #Gerund$", [future]],
    // have started looking
    ["^have #PastTense #Gerund$", [past2]],
    // will have started looking
    ["^will have #PastTense #Gerund$", [past2]]
  ],
  "simple-present": [
    // he walks',
    ["^#PresentTense$", [present]],
    // we walk
    ["^#Infinitive$", [present]]
  ],
  "simple-past": [
    // he walked',
    ["^#PastTense$", [past2]]
  ],
  "simple-future": [
    // he will walk
    ["^will #Adverb? #Infinitive", [future]]
  ],
  // === Progressive ===
  "present-progressive": [
    // he is walking
    ["^(is|are|am) #Gerund$", [present, prog]]
  ],
  "past-progressive": [
    // he was walking
    ["^(was|were) #Gerund$", [past2, prog]]
  ],
  "future-progressive": [
    // he will be
    ["^will be #Gerund$", [future, prog]]
  ],
  // === Perfect ===
  "present-perfect": [
    // he has walked
    ["^(has|have) #PastTense$", [past2, complete]]
    //past?
  ],
  "past-perfect": [
    // he had walked
    ["^had #PastTense$", [past2, complete]],
    // had been to see
    ["^had #PastTense to #Infinitive", [past2, complete]]
  ],
  "future-perfect": [
    // he will have
    ["^will have #PastTense$", [future, complete]]
  ],
  // === Progressive-perfect ===
  "present-perfect-progressive": [
    // he has been walking
    ["^(has|have) been #Gerund$", [past2, prog]]
    //present?
  ],
  "past-perfect-progressive": [
    // he had been
    ["^had been #Gerund$", [past2, prog]]
  ],
  "future-perfect-progressive": [
    // will have been
    ["^will have been #Gerund$", [future, prog]]
  ],
  // ==== Passive ===
  "passive-past": [
    // got walked, was walked, were walked
    ["(got|were|was) #Passive", [past2, passive2]],
    // was being walked
    ["^(was|were) being #Passive", [past2, passive2]],
    // had been walked, have been eaten
    ["^(had|have) been #Passive", [past2, passive2]]
  ],
  "passive-present": [
    // is walked, are stolen
    ["^(is|are|am) #Passive", [present, passive2]],
    // is being walked
    ["^(is|are|am) being #Passive", [present, passive2]],
    // has been cleaned
    ["^has been #Passive", [present, passive2]]
  ],
  "passive-future": [
    // will have been walked
    ["will have been #Passive", [future, passive2, conditional]],
    // will be cleaned
    ["will be being? #Passive", [future, passive2, conditional]]
  ],
  // === Conditional ===
  "present-conditional": [
    // would be walked
    ["would be #PastTense", [present, conditional]]
  ],
  "past-conditional": [
    // would have been walked
    ["would have been #PastTense", [past2, conditional]]
  ],
  // ==== Auxiliary ===
  "auxiliary-future": [
    // going to drink
    ["(is|are|am|was) going to (#Infinitive|#PresentTense)", [future]]
  ],
  "auxiliary-past": [
    // he did walk
    ["^did #Infinitive$", [past2, singular]],
    // used to walk
    ["^used to #Infinitive$", [past2, complete]]
  ],
  "auxiliary-present": [
    // we do walk
    ["^(does|do) #Infinitive$", [present, complete, plural]]
  ],
  // === modals ===
  "modal-past": [
    // he could have walked
    ["^(could|must|should|shall) have #PastTense$", [past2]]
  ],
  "modal-infinitive": [
    // he can walk
    ["^#Modal #Infinitive$", []]
  ],
  "infinitive": [
    // walk
    ["^#Infinitive$", []]
  ]
};
var list3 = [];
Object.keys(verbForms).map((k2) => {
  verbForms[k2].forEach((a2) => {
    list3.push({
      name: k2,
      match: a2[0],
      data: getData(a2[1])
    });
  });
});
var forms_default = list3;

// node_modules/compromise/src/3-three/verbs/api/parse/grammar/index.js
var cleanUp2 = function(vb3, res) {
  vb3 = vb3.clone();
  if (res.adverbs.post && res.adverbs.post.found) {
    vb3.remove(res.adverbs.post);
  }
  if (res.adverbs.pre && res.adverbs.pre.found) {
    vb3.remove(res.adverbs.pre);
  }
  if (vb3.has("#Negative")) {
    vb3 = vb3.remove("#Negative");
  }
  if (vb3.has("#Prefix")) {
    vb3 = vb3.remove("#Prefix");
  }
  if (res.root.has("#PhrasalVerb #Particle")) {
    vb3.remove("#Particle$");
  }
  vb3 = vb3.not("#Adverb");
  return vb3;
};
var isInfinitive = function(vb3) {
  if (vb3.has("#Infinitive")) {
    let m3 = vb3.growLeft("to");
    if (m3.has("^to #Infinitive")) {
      return true;
    }
  }
  return false;
};
var getGrammar = function(vb3, res) {
  let grammar2 = {};
  vb3 = cleanUp2(vb3, res);
  for (let i3 = 0; i3 < forms_default.length; i3 += 1) {
    let todo = forms_default[i3];
    if (vb3.has(todo.match) === true) {
      grammar2.form = todo.name;
      Object.assign(grammar2, todo.data);
      break;
    }
  }
  if (!grammar2.form) {
    if (vb3.has("^#Verb$")) {
      grammar2.form = "infinitive";
    }
  }
  if (!grammar2.tense) {
    grammar2.tense = res.root.has("#PastTense") ? "PastTense" : "PresentTense";
  }
  grammar2.copula = res.root.has("#Copula");
  grammar2.isInfinitive = isInfinitive(vb3);
  return grammar2;
};
var grammar_default = getGrammar;

// node_modules/compromise/src/3-three/verbs/api/parse/getSubject.js
var shouldSkip = function(last) {
  if (last.length <= 1) {
    return false;
  }
  let obj = last.parse()[0] || {};
  return obj.isSubordinate;
};
var noSubClause = function(before2) {
  let parts = before2.clauses();
  parts = parts.filter((m3, i3) => {
    if (m3.has("^(if|unless|while|but|for|per|at|by|that|which|who|from)")) {
      return false;
    }
    if (i3 > 0 && m3.has("^#Verb . #Noun+$")) {
      return false;
    }
    if (i3 > 0 && m3.has("^#Adverb")) {
      return false;
    }
    return true;
  });
  if (parts.length === 0) {
    return before2;
  }
  return parts;
};
var lastNoun2 = function(vb3) {
  let before2 = vb3.before();
  before2 = noSubClause(before2);
  let nouns = before2.nouns();
  let last = nouns.last();
  let pronoun = last.match("(i|he|she|we|you|they)");
  if (pronoun.found) {
    return pronoun.nouns();
  }
  let det = nouns.if("^(that|this|those)");
  if (det.found) {
    return det;
  }
  if (nouns.found === false) {
    det = before2.match("^(that|this|those)");
    if (det.found) {
      return det;
    }
  }
  last = nouns.last();
  if (shouldSkip(last)) {
    nouns.remove(last);
    last = nouns.last();
  }
  if (shouldSkip(last)) {
    nouns.remove(last);
    last = nouns.last();
  }
  return last;
};
var isPlural3 = function(subj, vb3) {
  if (vb3.has("(are|were|does)")) {
    return true;
  }
  if (subj.has("(those|they|we)")) {
    return true;
  }
  if (subj.found && subj.isPlural) {
    return subj.isPlural().found;
  }
  return false;
};
var getSubject = function(vb3) {
  let subj = lastNoun2(vb3);
  return {
    subject: subj,
    plural: isPlural3(subj, vb3)
  };
};
var getSubject_default = getSubject;

// node_modules/compromise/src/3-three/verbs/api/lib.js
var noop2 = (vb3) => vb3;
var isPlural4 = (vb3, parsed) => {
  let subj = getSubject_default(vb3, parsed);
  let m3 = subj.subject;
  if (m3.has("i") || m3.has("we")) {
    return true;
  }
  return subj.plural;
};
var wasWere = (vb3, parsed) => {
  let { subject, plural: plural2 } = getSubject_default(vb3, parsed);
  if (plural2 || subject.has("we")) {
    return "were";
  }
  return "was";
};
var isAreAm = function(vb3, parsed) {
  if (vb3.has("were")) {
    return "are";
  }
  let { subject, plural: plural2 } = getSubject_default(vb3, parsed);
  if (subject.has("i")) {
    return "am";
  }
  if (subject.has("we") || plural2) {
    return "are";
  }
  return "is";
};
var doDoes = function(vb3, parsed) {
  let subj = getSubject_default(vb3, parsed);
  let m3 = subj.subject;
  if (m3.has("i") || m3.has("we")) {
    return "do";
  }
  if (subj.plural) {
    return "do";
  }
  return "does";
};
var getTense2 = function(m3) {
  if (m3.has("#Infinitive")) {
    return "Infinitive";
  }
  if (m3.has("#Participle")) {
    return "Participle";
  }
  if (m3.has("#PastTense")) {
    return "PastTense";
  }
  if (m3.has("#Gerund")) {
    return "Gerund";
  }
  if (m3.has("#PresentTense")) {
    return "PresentTense";
  }
  return void 0;
};
var toInf = function(vb3, parsed) {
  const { toInfinitive: toInfinitive3 } = vb3.methods.two.transform.verb;
  let str = parsed.root.text({ keepPunct: false });
  str = toInfinitive3(str, vb3.model, getTense2(vb3));
  if (str) {
    vb3.replace(parsed.root, str);
  }
  return vb3;
};
var noWill = (vb3) => {
  if (vb3.has("will not")) {
    return vb3.replace("will not", "have not");
  }
  return vb3.remove("will");
};

// node_modules/compromise/src/3-three/verbs/api/toJSON.js
var toArray3 = function(m3) {
  if (!m3 || !m3.isView) {
    return [];
  }
  const opts2 = { normal: true, terms: false, text: false };
  return m3.json(opts2).map((s3) => s3.normal);
};
var toText4 = function(m3) {
  if (!m3 || !m3.isView) {
    return "";
  }
  return m3.text("normal");
};
var toInf2 = function(root6) {
  const { toInfinitive: toInfinitive3 } = root6.methods.two.transform.verb;
  let str = root6.text("normal");
  return toInfinitive3(str, root6.model, getTense2(root6));
};
var toJSON3 = function(vb3) {
  let parsed = parse_default8(vb3);
  vb3 = vb3.clone().toView();
  const info = grammar_default(vb3, parsed);
  return {
    root: parsed.root.text(),
    preAdverbs: toArray3(parsed.adverbs.pre),
    postAdverbs: toArray3(parsed.adverbs.post),
    auxiliary: toText4(parsed.auxiliary),
    negative: parsed.negative.found,
    prefix: toText4(parsed.prefix),
    infinitive: toInf2(parsed.root),
    grammar: info
  };
};
var toJSON_default2 = toJSON3;

// node_modules/compromise/src/3-three/verbs/api/conjugate/toInfinitive.js
var keep3 = { tags: true };
var toInf3 = function(vb3, parsed) {
  const { toInfinitive: toInfinitive3 } = vb3.methods.two.transform.verb;
  const { root: root6, auxiliary } = parsed;
  let aux = auxiliary.terms().harden();
  let str = root6.text("normal");
  str = toInfinitive3(str, vb3.model, getTense2(root6));
  if (str) {
    vb3.replace(root6, str, keep3).tag("Verb").firstTerm().tag("Infinitive");
  }
  if (aux.found) {
    vb3.remove(aux);
  }
  if (parsed.negative.found) {
    if (!vb3.has("not")) {
      vb3.prepend("not");
    }
    let does = doDoes(vb3, parsed);
    vb3.prepend(does);
  }
  vb3.fullSentence().compute(["freeze", "lexicon", "preTagger", "postTagger", "unfreeze", "chunks"]);
  return vb3;
};
var toInfinitive_default3 = toInf3;

// node_modules/compromise/src/3-three/verbs/api/conjugate/toPast.js
var keep4 = { tags: true };
var fns6 = {
  noAux: (vb3, parsed) => {
    if (parsed.auxiliary.found) {
      vb3 = vb3.remove(parsed.auxiliary);
    }
    return vb3;
  },
  // walk->walked
  simple: (vb3, parsed) => {
    const { conjugate: conjugate2, toInfinitive: toInfinitive3 } = vb3.methods.two.transform.verb;
    const root6 = parsed.root;
    if (root6.has("#Modal")) {
      return vb3;
    }
    let str = root6.text({ keepPunct: false });
    str = toInfinitive3(str, vb3.model, getTense2(root6));
    let all4 = conjugate2(str, vb3.model);
    str = all4.PastTense;
    str = str === "been" ? "was" : str;
    if (str === "was") {
      str = wasWere(vb3, parsed);
    }
    if (str) {
      vb3.replace(root6, str, keep4);
    }
    return vb3;
  },
  both: function(vb3, parsed) {
    if (parsed.negative.found) {
      vb3.replace("will", "did");
      return vb3;
    }
    vb3 = fns6.simple(vb3, parsed);
    vb3 = fns6.noAux(vb3, parsed);
    return vb3;
  },
  hasHad: (vb3) => {
    vb3.replace("has", "had", keep4);
    return vb3;
  },
  // some verbs have this weird past-tense form
  // drive -> driven, (!drove)
  hasParticiple: (vb3, parsed) => {
    const { conjugate: conjugate2, toInfinitive: toInfinitive3 } = vb3.methods.two.transform.verb;
    const root6 = parsed.root;
    let str = root6.text("normal");
    str = toInfinitive3(str, vb3.model, getTense2(root6));
    return conjugate2(str, vb3.model).Participle;
  }
};
var forms = {
  // walk -> walked
  "infinitive": fns6.simple,
  // he walks -> he walked
  "simple-present": fns6.simple,
  // he walked
  "simple-past": noop2,
  // he will walk -> he walked
  "simple-future": fns6.both,
  // he is walking
  "present-progressive": (vb3) => {
    vb3.replace("are", "were", keep4);
    vb3.replace("(is|are|am)", "was", keep4);
    return vb3;
  },
  // he was walking
  "past-progressive": noop2,
  // he will be walking
  "future-progressive": (vb3, parsed) => {
    vb3.match(parsed.root).insertBefore("was");
    vb3.remove("(will|be)");
    return vb3;
  },
  // has walked -> had walked (?)
  "present-perfect": fns6.hasHad,
  // had walked
  "past-perfect": noop2,
  // will have walked -> had walked
  "future-perfect": (vb3, parsed) => {
    vb3.match(parsed.root).insertBefore("had");
    if (vb3.has("will")) {
      vb3 = noWill(vb3);
    }
    vb3.remove("have");
    return vb3;
  },
  // has been walking -> had been
  "present-perfect-progressive": fns6.hasHad,
  // had been walking
  "past-perfect-progressive": noop2,
  // will have been -> had
  "future-perfect-progressive": (vb3) => {
    vb3.remove("will");
    vb3.replace("have", "had", keep4);
    return vb3;
  },
  // got walked
  "passive-past": (vb3) => {
    vb3.replace("have", "had", keep4);
    return vb3;
  },
  // is being walked  -> 'was being walked'
  "passive-present": (vb3) => {
    vb3.replace("(is|are)", "was", keep4);
    return vb3;
  },
  // will be walked -> had been walked
  "passive-future": (vb3, parsed) => {
    if (parsed.auxiliary.has("will be")) {
      vb3.match(parsed.root).insertBefore("had been");
      vb3.remove("(will|be)");
    }
    if (parsed.auxiliary.has("will have been")) {
      vb3.replace("have", "had", keep4);
      vb3.remove("will");
    }
    return vb3;
  },
  // would be walked -> 'would have been walked'
  "present-conditional": (vb3) => {
    vb3.replace("be", "have been");
    return vb3;
  },
  // would have been walked
  "past-conditional": noop2,
  // is going to drink -> was going to drink
  "auxiliary-future": (vb3) => {
    vb3.replace("(is|are|am)", "was", keep4);
    return vb3;
  },
  // used to walk
  "auxiliary-past": noop2,
  // we do walk -> we did walk
  "auxiliary-present": (vb3) => {
    vb3.replace("(do|does)", "did", keep4);
    return vb3;
  },
  // must walk -> 'must have walked'
  "modal-infinitive": (vb3, parsed) => {
    if (vb3.has("can")) {
      vb3.replace("can", "could", keep4);
    } else {
      fns6.simple(vb3, parsed);
      vb3.match("#Modal").insertAfter("have").tag("Auxiliary");
    }
    return vb3;
  },
  // must have walked
  "modal-past": noop2,
  // wanted to walk
  "want-infinitive": (vb3) => {
    vb3.replace("(want|wants)", "wanted", keep4);
    vb3.remove("will");
    return vb3;
  },
  // started looking
  "gerund-phrase": (vb3, parsed) => {
    parsed.root = parsed.root.not("#Gerund$");
    fns6.simple(vb3, parsed);
    noWill(vb3);
    return vb3;
  }
};
var toPast3 = function(vb3, parsed, form) {
  if (forms.hasOwnProperty(form)) {
    vb3 = forms[form](vb3, parsed);
    vb3.fullSentence().compute(["tagger", "chunks"]);
    return vb3;
  }
  return vb3;
};
var toPast_default2 = toPast3;

// node_modules/compromise/src/3-three/verbs/api/conjugate/toParticiple.js
var haveHas = function(vb3, parsed) {
  let subj = getSubject_default(vb3, parsed);
  let m3 = subj.subject;
  if (m3.has("(i|we|you)")) {
    return "have";
  }
  if (subj.plural === false) {
    return "has";
  }
  if (m3.has("he") || m3.has("she") || m3.has("#Person")) {
    return "has";
  }
  return "have";
};
var simple = (vb3, parsed) => {
  const { conjugate: conjugate2, toInfinitive: toInfinitive3 } = vb3.methods.two.transform.verb;
  const { root: root6, auxiliary } = parsed;
  if (root6.has("#Modal")) {
    return vb3;
  }
  let str = root6.text({ keepPunct: false });
  str = toInfinitive3(str, vb3.model, getTense2(root6));
  let all4 = conjugate2(str, vb3.model);
  str = all4.Participle || all4.PastTense;
  if (str) {
    vb3 = vb3.replace(root6, str);
    let have = haveHas(vb3, parsed);
    vb3.prepend(have).match(have).tag("Auxiliary");
    vb3.remove(auxiliary);
  }
  return vb3;
};
var forms2 = {
  // walk -> walked
  "infinitive": simple,
  // he walks -> he walked
  "simple-present": simple,
  // he walked
  // 'simple-past': noop,
  // he will walk -> he walked
  "simple-future": (vb3, parsed) => vb3.replace("will", haveHas(vb3, parsed)),
  // he is walking
  // 'present-progressive': noop,
  // he was walking
  // 'past-progressive': noop,
  // he will be walking
  // 'future-progressive': noop,
  // has walked -> had walked (?)
  "present-perfect": noop2,
  // had walked
  "past-perfect": noop2,
  // will have walked -> had walked
  "future-perfect": (vb3, parsed) => vb3.replace("will have", haveHas(vb3, parsed)),
  // has been walking -> had been
  "present-perfect-progressive": noop2,
  // had been walking
  "past-perfect-progressive": noop2,
  // will have been -> had
  "future-perfect-progressive": noop2
  // got walked
  // 'passive-past': noop,
  // is being walked  -> 'was being walked'
  // 'passive-present': noop,
  // will be walked -> had been walked
  // 'passive-future': noop,
  // would be walked -> 'would have been walked'
  // 'present-conditional': noop,
  // would have been walked
  // 'past-conditional': noop,
  // is going to drink -> was going to drink
  // 'auxiliary-future': noop,
  // used to walk
  // 'auxiliary-past': noop,
  // we do walk -> we did walk
  // 'auxiliary-present': noop,
  // must walk -> 'must have walked'
  // 'modal-infinitive': noop,
  // must have walked
  // 'modal-past': noop,
  // wanted to walk
  // 'want-infinitive': noop,
  // started looking
  // 'gerund-phrase': noop,
};
var toPast4 = function(vb3, parsed, form) {
  if (forms2.hasOwnProperty(form)) {
    vb3 = forms2[form](vb3, parsed);
    vb3.fullSentence().compute(["tagger", "chunks"]);
    return vb3;
  }
  vb3 = simple(vb3, parsed, form);
  vb3.fullSentence().compute(["tagger", "chunks"]);
  return vb3;
};
var toParticiple_default = toPast4;

// node_modules/compromise/src/3-three/verbs/api/conjugate/toPresent.js
var keep5 = { tags: true };
var simple2 = (vb3, parsed) => {
  const { conjugate: conjugate2, toInfinitive: toInfinitive3 } = vb3.methods.two.transform.verb;
  const root6 = parsed.root;
  let str = root6.text("normal");
  str = toInfinitive3(str, vb3.model, getTense2(root6));
  if (isPlural4(vb3, parsed) === false) {
    str = conjugate2(str, vb3.model).PresentTense;
  }
  if (root6.has("#Copula")) {
    str = isAreAm(vb3, parsed);
  }
  if (str) {
    vb3 = vb3.replace(root6, str, keep5);
    vb3.not("#Particle").tag("PresentTense");
  }
  return vb3;
};
var toGerund2 = (vb3, parsed) => {
  const { conjugate: conjugate2, toInfinitive: toInfinitive3 } = vb3.methods.two.transform.verb;
  const root6 = parsed.root;
  let str = root6.text("normal");
  str = toInfinitive3(str, vb3.model, getTense2(root6));
  if (isPlural4(vb3, parsed) === false) {
    str = conjugate2(str, vb3.model).Gerund;
  }
  if (str) {
    vb3 = vb3.replace(root6, str, keep5);
    vb3.not("#Particle").tag("Gerund");
  }
  return vb3;
};
var vbToInf = (vb3, parsed) => {
  const { toInfinitive: toInfinitive3 } = vb3.methods.two.transform.verb;
  const root6 = parsed.root;
  let str = parsed.root.text("normal");
  str = toInfinitive3(str, vb3.model, getTense2(root6));
  if (str) {
    vb3 = vb3.replace(parsed.root, str, keep5);
  }
  return vb3;
};
var forms3 = {
  // walk
  "infinitive": simple2,
  // he walks -> he walked
  "simple-present": (vb3, parsed) => {
    const { conjugate: conjugate2 } = vb3.methods.two.transform.verb;
    let { root: root6 } = parsed;
    if (root6.has("#Infinitive")) {
      let subj = getSubject_default(vb3, parsed);
      let m3 = subj.subject;
      if (isPlural4(vb3, parsed) || m3.has("i")) {
        return vb3;
      }
      let str = root6.text("normal");
      let pres = conjugate2(str, vb3.model).PresentTense;
      if (str !== pres) {
        vb3.replace(root6, pres, keep5);
      }
    } else {
      return simple2(vb3, parsed);
    }
    return vb3;
  },
  // he walked
  "simple-past": simple2,
  // he will walk -> he walked
  "simple-future": (vb3, parsed) => {
    const { root: root6, auxiliary } = parsed;
    if (auxiliary.has("will") && root6.has("be")) {
      let str = isAreAm(vb3, parsed);
      vb3.replace(root6, str);
      vb3 = vb3.remove("will");
      vb3.replace("not " + str, str + " not");
    } else {
      simple2(vb3, parsed);
      vb3 = vb3.remove("will");
    }
    return vb3;
  },
  // is walking ->
  "present-progressive": noop2,
  // was walking -> is walking
  "past-progressive": (vb3, parsed) => {
    let str = isAreAm(vb3, parsed);
    return vb3.replace("(were|was)", str, keep5);
  },
  // will be walking -> is walking
  "future-progressive": (vb3) => {
    vb3.match("will").insertBefore("is");
    vb3.remove("be");
    return vb3.remove("will");
  },
  // has walked ->  (?)
  "present-perfect": (vb3, parsed) => {
    simple2(vb3, parsed);
    vb3 = vb3.remove("(have|had|has)");
    return vb3;
  },
  // had walked -> has walked
  "past-perfect": (vb3, parsed) => {
    let subj = getSubject_default(vb3, parsed);
    let m3 = subj.subject;
    if (isPlural4(vb3, parsed) || m3.has("i")) {
      vb3 = toInf(vb3, parsed);
      vb3.remove("had");
      return vb3;
    }
    vb3.replace("had", "has", keep5);
    return vb3;
  },
  // will have walked -> has walked
  "future-perfect": (vb3) => {
    vb3.match("will").insertBefore("has");
    return vb3.remove("have").remove("will");
  },
  // has been walking
  "present-perfect-progressive": noop2,
  // had been walking
  "past-perfect-progressive": (vb3) => vb3.replace("had", "has", keep5),
  // will have been -> has been
  "future-perfect-progressive": (vb3) => {
    vb3.match("will").insertBefore("has");
    return vb3.remove("have").remove("will");
  },
  // got walked -> is walked
  // was walked -> is walked
  // had been walked -> is walked
  "passive-past": (vb3, parsed) => {
    let str = isAreAm(vb3, parsed);
    if (vb3.has("(had|have|has)") && vb3.has("been")) {
      vb3.replace("(had|have|has)", str, keep5);
      vb3.replace("been", "being");
      return vb3;
    }
    return vb3.replace("(got|was|were)", str);
  },
  // is being walked  ->
  "passive-present": noop2,
  // will be walked -> is being walked
  "passive-future": (vb3) => {
    vb3.replace("will", "is");
    return vb3.replace("be", "being");
  },
  // would be walked ->
  "present-conditional": noop2,
  // would have been walked ->
  "past-conditional": (vb3) => {
    vb3.replace("been", "be");
    return vb3.remove("have");
  },
  // is going to drink -> is drinking
  "auxiliary-future": (vb3, parsed) => {
    toGerund2(vb3, parsed);
    vb3.remove("(going|to)");
    return vb3;
  },
  // used to walk -> is walking
  // did walk -> is walking
  "auxiliary-past": (vb3, parsed) => {
    if (parsed.auxiliary.has("did")) {
      let str = doDoes(vb3, parsed);
      vb3.replace(parsed.auxiliary, str);
      return vb3;
    }
    toGerund2(vb3, parsed);
    vb3.replace(parsed.auxiliary, "is");
    return vb3;
  },
  // we do walk ->
  "auxiliary-present": noop2,
  // must walk -> 'must have walked'
  "modal-infinitive": noop2,
  // must have walked
  "modal-past": (vb3, parsed) => {
    vbToInf(vb3, parsed);
    return vb3.remove("have");
  },
  // started looking
  "gerund-phrase": (vb3, parsed) => {
    parsed.root = parsed.root.not("#Gerund$");
    simple2(vb3, parsed);
    return vb3.remove("(will|have)");
  },
  // wanted to walk
  "want-infinitive": (vb3, parsed) => {
    let str = "wants";
    if (isPlural4(vb3, parsed)) {
      str = "want";
    }
    vb3.replace("(want|wanted|wants)", str, keep5);
    vb3.remove("will");
    return vb3;
  }
};
var toPresent3 = function(vb3, parsed, form) {
  if (forms3.hasOwnProperty(form)) {
    vb3 = forms3[form](vb3, parsed);
    vb3.fullSentence().compute(["tagger", "chunks"]);
    return vb3;
  }
  return vb3;
};
var toPresent_default2 = toPresent3;

// node_modules/compromise/src/3-three/verbs/api/conjugate/toFuture.js
var keep6 = { tags: true };
var simple3 = (vb3, parsed) => {
  const { toInfinitive: toInfinitive3 } = vb3.methods.two.transform.verb;
  const { root: root6, auxiliary } = parsed;
  if (root6.has("#Modal")) {
    return vb3;
  }
  let str = root6.text("normal");
  str = toInfinitive3(str, vb3.model, getTense2(root6));
  if (str) {
    vb3 = vb3.replace(root6, str, keep6);
    vb3.not("#Particle").tag("Verb");
  }
  vb3.prepend("will").match("will").tag("Auxiliary");
  vb3.remove(auxiliary);
  return vb3;
};
var progressive = (vb3, parsed) => {
  const { conjugate: conjugate2, toInfinitive: toInfinitive3 } = vb3.methods.two.transform.verb;
  const { root: root6, auxiliary } = parsed;
  let str = root6.text("normal");
  str = toInfinitive3(str, vb3.model, getTense2(root6));
  if (str) {
    str = conjugate2(str, vb3.model).Gerund;
    vb3.replace(root6, str, keep6);
    vb3.not("#Particle").tag("PresentTense");
  }
  vb3.remove(auxiliary);
  vb3.prepend("will be").match("will be").tag("Auxiliary");
  return vb3;
};
var forms4 = {
  // walk ->
  "infinitive": simple3,
  // he walks ->
  "simple-present": simple3,
  // he walked
  "simple-past": simple3,
  // he will walk ->
  "simple-future": noop2,
  // is walking ->
  "present-progressive": progressive,
  // was walking ->
  "past-progressive": progressive,
  // will be walking ->
  "future-progressive": noop2,
  // has walked ->
  "present-perfect": (vb3) => {
    vb3.match("(have|has)").replaceWith("will have");
    return vb3;
  },
  // had walked ->
  "past-perfect": (vb3) => vb3.replace("(had|has)", "will have"),
  // will have walked ->
  "future-perfect": noop2,
  // has been walking
  "present-perfect-progressive": (vb3) => vb3.replace("has", "will have"),
  // had been walking
  "past-perfect-progressive": (vb3) => vb3.replace("had", "will have"),
  // will have been ->
  "future-perfect-progressive": noop2,
  // got walked ->
  // was walked ->
  // was being walked ->
  // had been walked ->
  "passive-past": (vb3) => {
    if (vb3.has("got")) {
      return vb3.replace("got", "will get");
    }
    if (vb3.has("(was|were)")) {
      vb3.replace("(was|were)", "will be");
      return vb3.remove("being");
    }
    if (vb3.has("(have|has|had) been")) {
      return vb3.replace("(have|has|had) been", "will be");
    }
    return vb3;
  },
  // is being walked  ->
  "passive-present": (vb3) => {
    vb3.replace("being", "will be");
    vb3.remove("(is|are|am)");
    return vb3;
  },
  // will be walked ->
  "passive-future": noop2,
  // would be walked ->
  "present-conditional": (vb3) => vb3.replace("would", "will"),
  // would have been walked ->
  "past-conditional": (vb3) => vb3.replace("would", "will"),
  // is going to drink ->
  "auxiliary-future": noop2,
  // used to walk -> is walking
  // did walk -> is walking
  "auxiliary-past": (vb3) => {
    if (vb3.has("used") && vb3.has("to")) {
      vb3.replace("used", "will");
      return vb3.remove("to");
    }
    vb3.replace("did", "will");
    return vb3;
  },
  // we do walk ->
  // he does walk ->
  "auxiliary-present": (vb3) => {
    return vb3.replace("(do|does)", "will");
  },
  // must walk ->
  "modal-infinitive": noop2,
  // must have walked
  "modal-past": noop2,
  // started looking
  "gerund-phrase": (vb3, parsed) => {
    parsed.root = parsed.root.not("#Gerund$");
    simple3(vb3, parsed);
    return vb3.remove("(had|have)");
  },
  // wanted to walk
  "want-infinitive": (vb3) => {
    vb3.replace("(want|wants|wanted)", "will want");
    return vb3;
  }
};
var toFuture2 = function(vb3, parsed, form) {
  if (vb3.has("will") || vb3.has("going to")) {
    return vb3;
  }
  if (forms4.hasOwnProperty(form)) {
    vb3 = forms4[form](vb3, parsed);
    vb3.fullSentence().compute(["tagger", "chunks"]);
    return vb3;
  }
  return vb3;
};
var toFuture_default2 = toFuture2;

// node_modules/compromise/src/3-three/verbs/api/conjugate/toGerund.js
var keep7 = { tags: true };
var toGerund3 = function(vb3, parsed) {
  const { toInfinitive: toInfinitive3, conjugate: conjugate2 } = vb3.methods.two.transform.verb;
  const { root: root6, auxiliary } = parsed;
  if (vb3.has("#Gerund")) {
    return vb3;
  }
  let str = root6.text("normal");
  str = toInfinitive3(str, vb3.model, getTense2(root6));
  let gerund = conjugate2(str, vb3.model).Gerund;
  if (gerund) {
    let aux = isAreAm(vb3, parsed);
    vb3.replace(root6, gerund, keep7);
    vb3.remove(auxiliary);
    vb3.prepend(aux);
  }
  vb3.replace("not is", "is not");
  vb3.replace("not are", "are not");
  vb3.fullSentence().compute(["tagger", "chunks"]);
  return vb3;
};
var toGerund_default = toGerund3;

// node_modules/compromise/src/3-three/verbs/api/conjugate/toNegative.js
var keep8 = { tags: true };
var doesNot = function(vb3, parsed) {
  let does = doDoes(vb3, parsed);
  vb3.prepend(does + " not");
  return vb3;
};
var isWas = function(vb3) {
  let m3 = vb3.match("be");
  if (m3.found) {
    m3.prepend("not");
    return vb3;
  }
  m3 = vb3.match("(is|was|am|are|will|were)");
  if (m3.found) {
    m3.append("not");
    return vb3;
  }
  return vb3;
};
var hasCopula = (vb3) => vb3.has("(is|was|am|are|will|were|be)");
var forms5 = {
  // he walks' -> 'he does not walk'
  "simple-present": (vb3, parsed) => {
    if (hasCopula(vb3) === true) {
      return isWas(vb3, parsed);
    }
    vb3 = toInf(vb3, parsed);
    vb3 = doesNot(vb3, parsed);
    return vb3;
  },
  // 'he walked' -> 'he did not walk'
  "simple-past": (vb3, parsed) => {
    if (hasCopula(vb3) === true) {
      return isWas(vb3, parsed);
    }
    vb3 = toInf(vb3, parsed);
    vb3.prepend("did not");
    return vb3;
  },
  // walk! -> 'do not walk'
  "imperative": (vb3) => {
    vb3.prepend("do not");
    return vb3;
  },
  // walk -> does not walk
  "infinitive": (vb3, parsed) => {
    if (hasCopula(vb3) === true) {
      return isWas(vb3, parsed);
    }
    return doesNot(vb3, parsed);
  },
  "passive-past": (vb3) => {
    if (vb3.has("got")) {
      vb3.replace("got", "get", keep8);
      vb3.prepend("did not");
      return vb3;
    }
    let m3 = vb3.match("(was|were|had|have)");
    if (m3.found) {
      m3.append("not");
    }
    return vb3;
  },
  "auxiliary-past": (vb3) => {
    if (vb3.has("used")) {
      vb3.prepend("did not");
      return vb3;
    }
    let m3 = vb3.match("(did|does|do)");
    if (m3.found) {
      m3.append("not");
    }
    return vb3;
  },
  // wants to walk
  "want-infinitive": (vb3, parsed) => {
    vb3 = doesNot(vb3, parsed);
    vb3 = vb3.replace("wants", "want", keep8);
    return vb3;
  }
};
var toNegative2 = function(vb3, parsed, form) {
  if (vb3.has("#Negative")) {
    return vb3;
  }
  if (forms5.hasOwnProperty(form)) {
    vb3 = forms5[form](vb3, parsed);
    return vb3;
  }
  let m3 = vb3.matchOne("be");
  if (m3.found) {
    m3.prepend("not");
    return vb3;
  }
  if (hasCopula(vb3) === true) {
    return isWas(vb3, parsed);
  }
  m3 = vb3.matchOne("(will|had|have|has|did|does|do|#Modal)");
  if (m3.found) {
    m3.append("not");
    return vb3;
  }
  return vb3;
};
var toNegative_default = toNegative2;

// node_modules/compromise/src/3-three/verbs/api/api.js
var api19 = function(View2) {
  class Verbs extends View2 {
    constructor(document2, pointer, groups) {
      super(document2, pointer, groups);
      this.viewType = "Verbs";
    }
    parse(n3) {
      return this.getNth(n3).map(parse_default8);
    }
    json(opts2, n3) {
      let m3 = this.getNth(n3);
      let arr = m3.map((vb3) => {
        let json = vb3.toView().json(opts2)[0] || {};
        json.verb = toJSON_default2(vb3);
        return json;
      }, []);
      return arr;
    }
    subjects(n3) {
      return this.getNth(n3).map((vb3) => {
        let parsed = parse_default8(vb3);
        return getSubject_default(vb3, parsed).subject;
      });
    }
    adverbs(n3) {
      return this.getNth(n3).map((vb3) => vb3.match("#Adverb"));
    }
    isSingular(n3) {
      return this.getNth(n3).filter((vb3) => {
        return getSubject_default(vb3).plural !== true;
      });
    }
    isPlural(n3) {
      return this.getNth(n3).filter((vb3) => {
        return getSubject_default(vb3).plural === true;
      });
    }
    isImperative(n3) {
      return this.getNth(n3).filter((vb3) => vb3.has("#Imperative"));
    }
    toInfinitive(n3) {
      return this.getNth(n3).map((vb3) => {
        let parsed = parse_default8(vb3);
        let info = grammar_default(vb3, parsed);
        return toInfinitive_default3(vb3, parsed, info.form);
      });
    }
    toPresentTense(n3) {
      return this.getNth(n3).map((vb3) => {
        let parsed = parse_default8(vb3);
        let info = grammar_default(vb3, parsed);
        if (info.isInfinitive) {
          return vb3;
        }
        return toPresent_default2(vb3, parsed, info.form);
      });
    }
    toPastTense(n3) {
      return this.getNth(n3).map((vb3) => {
        let parsed = parse_default8(vb3);
        let info = grammar_default(vb3, parsed);
        if (info.isInfinitive) {
          return vb3;
        }
        return toPast_default2(vb3, parsed, info.form);
      });
    }
    toFutureTense(n3) {
      return this.getNth(n3).map((vb3) => {
        let parsed = parse_default8(vb3);
        let info = grammar_default(vb3, parsed);
        if (info.isInfinitive) {
          return vb3;
        }
        return toFuture_default2(vb3, parsed, info.form);
      });
    }
    toGerund(n3) {
      return this.getNth(n3).map((vb3) => {
        let parsed = parse_default8(vb3);
        let info = grammar_default(vb3, parsed);
        if (info.isInfinitive) {
          return vb3;
        }
        return toGerund_default(vb3, parsed, info.form);
      });
    }
    toPastParticiple(n3) {
      return this.getNth(n3).map((vb3) => {
        let parsed = parse_default8(vb3);
        let info = grammar_default(vb3, parsed);
        if (info.isInfinitive) {
          return vb3;
        }
        return toParticiple_default(vb3, parsed, info.form);
      });
    }
    conjugate(n3) {
      const { conjugate: conjugate2, toInfinitive: toInfinitive3 } = this.world.methods.two.transform.verb;
      return this.getNth(n3).map((vb3) => {
        let parsed = parse_default8(vb3);
        let info = grammar_default(vb3, parsed);
        if (info.form === "imperative") {
          info.form = "simple-present";
        }
        let inf = parsed.root.text("normal");
        if (!parsed.root.has("#Infinitive")) {
          let tense = getTense2(parsed.root);
          inf = toInfinitive3(inf, vb3.model, tense) || inf;
        }
        return conjugate2(inf, vb3.model);
      }, []);
    }
    /** return only verbs with 'not'*/
    isNegative() {
      return this.if("#Negative");
    }
    /**  return only verbs without 'not'*/
    isPositive() {
      return this.ifNo("#Negative");
    }
    /** remove 'not' from these verbs */
    toPositive() {
      let m3 = this.match("do not #Verb");
      if (m3.found) {
        m3.remove("do not");
      }
      return this.remove("#Negative");
    }
    toNegative(n3) {
      return this.getNth(n3).map((vb3) => {
        let parsed = parse_default8(vb3);
        let info = grammar_default(vb3, parsed);
        return toNegative_default(vb3, parsed, info.form);
      });
    }
    // overloaded - keep Verb class
    update(pointer) {
      let m3 = new Verbs(this.document, pointer);
      m3._cache = this._cache;
      return m3;
    }
  }
  Verbs.prototype.toPast = Verbs.prototype.toPastTense;
  Verbs.prototype.toPresent = Verbs.prototype.toPresentTense;
  Verbs.prototype.toFuture = Verbs.prototype.toFutureTense;
  View2.prototype.verbs = function(n3) {
    let vb3 = find_default6(this);
    vb3 = vb3.getNth(n3);
    return new Verbs(this.document, vb3.pointer);
  };
};
var api_default21 = api19;

// node_modules/compromise/src/3-three/verbs/plugin.js
var plugin_default29 = {
  api: api_default21
};

// node_modules/compromise/src/3-three/coreference/compute/lib.js
var findChained = function(want, s3) {
  let m3 = s3.match(want);
  if (m3.found) {
    let ref = m3.pronouns().refersTo();
    if (ref.found) {
      return ref;
    }
  }
  return s3.none();
};
var prevSentence = function(m3) {
  if (!m3.found) {
    return m3;
  }
  let [n3] = m3.fullPointer[0];
  if (n3 && n3 > 0) {
    return m3.update([[n3 - 1]]);
  }
  return m3.none();
};

// node_modules/compromise/src/3-three/coreference/compute/findPerson.js
var byGender = function(ppl, gender) {
  if (gender === "m") {
    return ppl.filter((m3) => !m3.presumedFemale().found);
  } else if (gender === "f") {
    return ppl.filter((m3) => !m3.presumedMale().found);
  }
  return ppl;
};
var getPerson = function(s3, gender) {
  let people = s3.people();
  people = byGender(people, gender);
  if (people.found) {
    return people.last();
  }
  people = s3.nouns("#Actor");
  if (people.found) {
    return people.last();
  }
  if (gender === "f") {
    return findChained("(she|her|hers)", s3);
  }
  if (gender === "m") {
    return findChained("(he|him|his)", s3);
  }
  return s3.none();
};
var findPerson_default = getPerson;

// node_modules/compromise/src/3-three/coreference/compute/findThey.js
var getThey = function(s3) {
  let nouns = s3.nouns();
  let things = nouns.isPlural().notIf("#Pronoun");
  if (things.found) {
    return things.last();
  }
  let chain = findChained("(they|their|theirs)", s3);
  if (chain.found) {
    return chain;
  }
  things = nouns.match("(somebody|nobody|everybody|anybody|someone|noone|everyone|anyone)");
  if (things.found) {
    return things.last();
  }
  return s3.none();
};
var findThey_default = getThey;

// node_modules/compromise/src/3-three/coreference/compute/index.js
var addReference = function(pron, m3) {
  if (m3 && m3.found) {
    let term = pron.docs[0][0];
    term.reference = m3.ptrs[0];
  }
};
var stepBack = function(m3, cb) {
  let s3 = m3.before();
  let res = cb(s3);
  if (res.found) {
    return res;
  }
  s3 = prevSentence(m3);
  res = cb(s3);
  if (res.found) {
    return res;
  }
  s3 = prevSentence(s3);
  res = cb(s3);
  if (res.found) {
    return res;
  }
  return m3.none();
};
var coreference = function(view) {
  let pronouns = view.pronouns().if("(he|him|his|she|her|hers|they|their|theirs|it|its)");
  pronouns.forEach((pron) => {
    let res = null;
    if (pron.has("(he|him|his)")) {
      res = stepBack(pron, (m3) => findPerson_default(m3, "m"));
    } else if (pron.has("(she|her|hers)")) {
      res = stepBack(pron, (m3) => findPerson_default(m3, "f"));
    } else if (pron.has("(they|their|theirs)")) {
      res = stepBack(pron, findThey_default);
    }
    if (res && res.found) {
      addReference(pron, res);
    }
  });
};
var compute_default13 = coreference;

// node_modules/compromise/src/3-three/coreference/api/pronouns.js
var api20 = function(View2) {
  class Pronouns extends View2 {
    constructor(document2, pointer, groups) {
      super(document2, pointer, groups);
      this.viewType = "Pronouns";
    }
    hasReference() {
      this.compute("coreference");
      return this.filter((m3) => {
        let term = m3.docs[0][0];
        return term.reference;
      });
    }
    // get the noun-phrase this pronoun refers to
    refersTo() {
      this.compute("coreference");
      return this.map((m3) => {
        if (!m3.found) {
          return m3.none();
        }
        let term = m3.docs[0][0];
        if (term.reference) {
          return m3.update([term.reference]);
        }
        return m3.none();
      });
    }
    // overloaded - keep Numbers class
    update(pointer) {
      let m3 = new Pronouns(this.document, pointer);
      m3._cache = this._cache;
      return m3;
    }
  }
  View2.prototype.pronouns = function(n3) {
    let m3 = this.match("#Pronoun");
    m3 = m3.getNth(n3);
    return new Pronouns(m3.document, m3.pointer);
  };
};
var pronouns_default = api20;

// node_modules/compromise/src/3-three/coreference/plugin.js
var plugin_default30 = {
  compute: { coreference: compute_default13 },
  api: pronouns_default
};

// node_modules/compromise/src/three.js
two_default.plugin(plugin_default19);
two_default.plugin(plugin_default20);
two_default.plugin(plugin_default21);
two_default.plugin(plugin_default30);
two_default.plugin(plugin_default22);
two_default.plugin(plugin_default23);
two_default.plugin(plugin_default24);
two_default.plugin(plugin_default25);
two_default.plugin(plugin_default26);
two_default.plugin(plugin_default27);
two_default.plugin(plugin_default28);
two_default.plugin(plugin_default29);
var three_default = two_default;

// nlp.ts
var FILTER_WORDS = [
  "saw",
  "seen",
  "see",
  "heard",
  "hear",
  "felt",
  "feel",
  "smelled",
  "smell",
  "tasted",
  "taste",
  "realized",
  "wondered",
  "knew",
  "thought",
  "noticed",
  "decided",
  "watched",
  "looked",
  "seemed",
  "appeared"
];
var WEAK_VERBS = [
  "is",
  "am",
  "are",
  "was",
  "were",
  "be",
  "being",
  "been",
  "have",
  "has",
  "had"
  // Often weak auxiliary, though context matters
];
var NlpService = class {
  static analyze(text2) {
    const doc = three_default(text2);
    const wordCount3 = doc.wordCount();
    const sentenceCount = doc.sentences().length;
    const avgSentenceLength = sentenceCount > 0 ? wordCount3 / sentenceCount : 0;
    const adverbCount = doc.adverbs().length;
    let filterCount = 0;
    const lowerText = text2.toLowerCase();
    FILTER_WORDS.forEach((word) => {
      const regex = new RegExp(`\\b${word}\\b`, "g");
      const matches3 = lowerText.match(regex);
      if (matches3)
        filterCount += matches3.length;
    });
    let weakCount = 0;
    WEAK_VERBS.forEach((word) => {
      const regex = new RegExp(`\\b${word}\\b`, "g");
      const matches3 = lowerText.match(regex);
      if (matches3)
        weakCount += matches3.length;
    });
    const sentences = doc.sentences().json();
    const lengths = sentences.map((s3) => s3.terms.length);
    const variance = this.calculateStandardDeviation(lengths);
    const pacingScore = Math.min(100, variance * 10);
    const readabilityScore = Math.max(0, 100 - avgSentenceLength * 1.5);
    let technicalGrade = 0;
    if (readabilityScore > 90)
      technicalGrade = 5;
    else if (readabilityScore > 60)
      technicalGrade = 9;
    else if (readabilityScore > 30)
      technicalGrade = 12;
    else
      technicalGrade = 16;
    const uniqueWords = new Set(doc.terms().out("array")).size;
    const lexicalDiversity = wordCount3 > 0 ? uniqueWords / wordCount3 * 100 : 0;
    const dialogueMatches = text2.match(/"[^"]+"/g) || [];
    const dialogueText = dialogueMatches.join(" ");
    const dialogueCount = three_default(dialogueText).wordCount();
    const dialogueRatio = wordCount3 > 0 ? dialogueCount / wordCount3 * 100 : 0;
    let voiceContrast = 0;
    if (dialogueCount > 0) {
      const narrationText = text2.replace(/"[^"]+"/g, "");
      const narrTerms = new Set(three_default(narrationText).terms().out("array"));
      const dialTerms = new Set(three_default(dialogueText).terms().out("array"));
      const intersection2 = new Set([...dialTerms].filter((x) => narrTerms.has(x)));
      const union = /* @__PURE__ */ new Set([...dialTerms, ...narrTerms]);
      const similarity = union.size > 0 ? intersection2.size / union.size : 1;
      voiceContrast = (1 - similarity) * 100;
    }
    const terms = doc.terms().out("array");
    let repetitionCount = 0;
    const windowSize = 50;
    for (let i3 = 0; i3 < terms.length; i3++) {
      const word = terms[i3].toLowerCase();
      if (word.length < 5)
        continue;
      for (let j2 = 1; j2 < windowSize && i3 + j2 < terms.length; j2++) {
        if (terms[i3 + j2].toLowerCase() === word) {
          repetitionCount++;
          break;
        }
      }
    }
    return {
      wordCount: wordCount3,
      sentenceCount,
      avgSentenceLength: parseFloat(avgSentenceLength.toFixed(1)),
      adverbCount,
      passiveVoiceCount: 0,
      // Placeholder, requires deeper dependency parsing
      readingLevel: String(technicalGrade),
      technicalGrade,
      lexicalDiversity: parseFloat(lexicalDiversity.toFixed(1)),
      sentenceVariance: parseFloat(variance.toFixed(1)),
      dialogueRatio: Math.round(dialogueRatio),
      voiceContrast: Math.round(voiceContrast),
      filterWordCount: filterCount,
      weakVerbCount: weakCount,
      repetitionCount,
      pacingScore: Math.round(pacingScore)
    };
  }
  static calculateStandardDeviation(array) {
    if (array.length === 0)
      return 0;
    const n3 = array.length;
    const mean = array.reduce((a2, b) => a2 + b) / n3;
    const variance = array.map((x) => Math.pow(x - mean, 2)).reduce((a2, b) => a2 + b) / n3;
    return Math.sqrt(variance);
  }
};

// utils.ts
function debounce(func, wait) {
  let timeout = null;
  return function(...args) {
    if (timeout)
      clearTimeout(timeout);
    timeout = setTimeout(() => {
      func(...args);
      timeout = null;
    }, wait);
  };
}
function autoResize(node, value) {
  const resize = () => {
    node.style.height = "auto";
    node.style.height = node.scrollHeight + 2 + "px";
  };
  resize();
  node.addEventListener("input", resize);
  return {
    update(newValue) {
      resize();
    },
    destroy() {
      node.removeEventListener("input", resize);
    }
  };
}

// ForgeOps.ts
var import_obsidian3 = require("obsidian");
var ForgeOps = class {
  static fixDialogue(text2) {
    let fixed = text2;
    fixed = fixed.replace(/"\b/g, "\u201C").replace(/\b"/g, "\u201D");
    fixed = fixed.replace(/'\b/g, "\u2018").replace(/\b'/g, "\u2019");
    fixed = fixed.replace(/",/g, ",\u201D");
    fixed = fixed.replace(/"\./g, ".\u201D");
    fixed = fixed.replace(/([?!]) He (said|asked|shouted)/g, "$1\u201D he $2");
    new import_obsidian3.Notice("Dialogue Punctuation Standardized.");
    return fixed;
  }
  static assassinateAdverbs(text2, mode = "highlight") {
    const adverbRegex = /\b(\w+ly)\b/gi;
    const whitelist = ["only", "family", "ugly", "ally", "holy", "early", "daily"];
    if (mode === "kill") {
      const result = text2.replace(adverbRegex, (match2) => {
        if (whitelist.includes(match2.toLowerCase()))
          return match2;
        return `[KILLED: ${match2}]`;
      });
      new import_obsidian3.Notice("Adverbs marked for termination.");
      return result;
    } else {
      const result = text2.replace(adverbRegex, (match2) => {
        if (whitelist.includes(match2.toLowerCase()))
          return match2;
        return `**${match2}**`;
      });
      new import_obsidian3.Notice("Adverbs Highlighted.");
      return result;
    }
  }
  static highlightFilters(text2) {
    const filters = ["saw", "felt", "heard", "noticed", "wondered", "realized", "knew", "decided", "watched", "looked"];
    let result = text2;
    filters.forEach((word) => {
      const regex = new RegExp(`\\b${word}\\b`, "gi");
      result = result.replace(regex, `==${word}==`);
    });
    new import_obsidian3.Notice("Filter Words Highlighted (Show, Don't Tell).");
    return result;
  }
  static passiveVoiceScan(text2) {
    const passiveRegex = /\b(am|is|are|was|were|be|been|being)\s+(\w+ed)\b/gi;
    let result = text2.replace(passiveRegex, (match2) => {
      return `==${match2}==`;
    });
    if (result === text2) {
      new import_obsidian3.Notice("No obvious passive voice detected.");
    } else {
      new import_obsidian3.Notice("Passive Voice Highlighted.");
    }
    return result;
  }
};

// ReportGen.ts
var import_obsidian4 = require("obsidian");
var ReportGen = class {
  static async generateReport(app, data, sourceFilename) {
    if (!data.lastAiResult && !data.wizardState.concept) {
      new import_obsidian4.Notice("No data found to export.");
      return;
    }
    const date = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
    const r2 = data.lastAiResult;
    const nlp2 = data.lastNlpMetrics;
    const wiz = data.wizardState;
    let md = `# NARRATIVE FORENSICS REPORT: ${sourceFilename}
`;
    md += `**Date:** ${date} | **Compu-Judge v7.2.1**

`;
    if (r2) {
      md += `## 1. Executive Summary
`;
      md += `| Metric | Score | Verdict |
|---|---|---|
`;
      md += `| **Commercial** | ${r2.commercial_score}/100 | ${this.getVerdict(r2.commercial_score)} |
`;
      md += `| **Literary** | ${r2.niche_score}/100 | ${this.getVerdict(r2.niche_score)} |
`;
      md += `| **Cohesion** | ${r2.cohesion_score}/100 | ${this.getVerdict(r2.cohesion_score)} |

`;
      md += `> **Logline:** ${r2.log_line}

`;
      md += `**Critical Flags:** ${r2.content_warning}

`;
    }
    if (nlp2) {
      md += `## 2. Prose Forensics (Hard Data)
`;
      md += `- **Word Count:** ${nlp2.wordCount}
`;
      md += `- **Reading Level:** Grade ${nlp2.readingLevel}
`;
      md += `- **Adverb Count:** ${nlp2.adverbCount} (Target: <${Math.round(nlp2.wordCount * 0.03)})
`;
      md += `- **Filter Words:** ${nlp2.filterWordCount}
`;
      md += `- **Weak Verbs:** ${nlp2.weakVerbCount}
`;
      md += `- **Pacing Score:** ${nlp2.pacingScore}/100

`;
    }
    md += `## 3. Story Bible (DNA)
`;
    md += `### The Core
`;
    md += `- **Concept:** ${wiz.concept}
`;
    md += `- **Promise (Hook):** ${wiz.threePs.promise}
`;
    md += `- **Payoff (Climax):** ${wiz.threePs.payoff}

`;
    if (wiz.philosopher && (wiz.philosopher.controllingIdea || wiz.philosopher.moralArg)) {
      md += `### The Philosopher (Theme)
`;
      md += `- **Controlling Idea:** ${wiz.philosopher.controllingIdea}
`;
      md += `- **Moral Argument:** ${wiz.philosopher.moralArg}
`;
      md += `- **Counterpoint:** ${wiz.philosopher.counterpoint}
`;
      md += `- **Key Symbols:** ${wiz.philosopher.symbols}

`;
    }
    md += `### Structure Strategy
`;
    md += `- **Primary Thread:** ${wiz.structureDNA.primaryThread}
`;
    md += `- **Nesting Order:** ${wiz.structureDNA.nestingOrder}

`;
    if (wiz.structureDNA.tryFailCycles && wiz.structureDNA.tryFailCycles.length > 0) {
      md += `#### Try / Fail Cycles (Escalation)
`;
      wiz.structureDNA.tryFailCycles.forEach((cycle, i3) => {
        md += `**Cycle ${i3 + 1}: ${cycle.goal}**
`;
        md += `1. *No, and...* ${cycle.attempt1}
`;
        md += `2. *No, but...* ${cycle.attempt2}
`;
        md += `3. *Yes, but...* ${cycle.success}

`;
      });
    }
    md += `### Cast List
`;
    wiz.characters.forEach((c2) => {
      md += `- **${c2.name}** (${c2.role}): ${c2.description} *[Flaw: ${c2.flaw} | Revelation: ${c2.revelation}]*
`;
    });
    if (r2 && r2.detailed_metrics) {
      md += `
## 4. Structural Audit (AI)
`;
      for (const [key2, cat] of Object.entries(r2.detailed_metrics)) {
        md += `### ${key2.toUpperCase()} (Score: ${cat.score})
`;
        cat.items.forEach((item) => {
          md += `- **${item.name} (${item.score}/10)**: ${item.reason}
`;
        });
        md += `
`;
      }
    }
    if (r2 && r2.thought_process) {
      md += `
## 5. AI Reasoning (Raw)
`;
      md += `${r2.thought_process}
`;
    }
    const filename = `${sourceFilename}_REPORT_${Date.now()}.md`;
    await app.vault.create(filename, md);
    new import_obsidian4.Notice(`Report saved: ${filename}`);
  }
  static getVerdict(score) {
    if (score >= 90)
      return "MASTERPIECE";
    if (score >= 80)
      return "EXCELLENT";
    if (score >= 60)
      return "COMPETENT";
    if (score >= 40)
      return "FLAWED";
    return "BROKEN";
  }
};

// node_modules/svelte/src/easing/index.js
function cubicOut(t3) {
  const f3 = t3 - 1;
  return f3 * f3 * f3 + 1;
}

// node_modules/svelte/src/animate/index.js
function flip(node, { from, to }, params = {}) {
  var { delay = 0, duration = (d2) => Math.sqrt(d2) * 120, easing = cubicOut } = params;
  var style = getComputedStyle(node);
  var transform = style.transform === "none" ? "" : style.transform;
  var [ox, oy] = style.transformOrigin.split(" ").map(parseFloat);
  ox /= node.clientWidth;
  oy /= node.clientHeight;
  var zoom = get_zoom(node);
  var sx = node.clientWidth / to.width / zoom;
  var sy = node.clientHeight / to.height / zoom;
  var fx = from.left + from.width * ox;
  var fy = from.top + from.height * oy;
  var tx = to.left + to.width * ox;
  var ty = to.top + to.height * oy;
  var dx = (fx - tx) * sx;
  var dy = (fy - ty) * sy;
  var dsx = from.width / to.width;
  var dsy = from.height / to.height;
  return {
    delay,
    duration: typeof duration === "function" ? duration(Math.sqrt(dx * dx + dy * dy)) : duration,
    easing,
    css: (t3, u2) => {
      var x = u2 * dx;
      var y = u2 * dy;
      var sx2 = t3 + u2 * dsx;
      var sy2 = t3 + u2 * dsy;
      return `transform: ${transform} translate(${x}px, ${y}px) scale(${sx2}, ${sy2});`;
    }
  };
}
function get_zoom(element2) {
  if ("currentCSSZoom" in element2) {
    return (
      /** @type {number} */
      element2.currentCSSZoom
    );
  }
  var current = element2;
  var zoom = 1;
  while (current !== null) {
    zoom *= +getComputedStyle(current).zoom;
    current = /** @type {Element | null} */
    current.parentElement;
  }
  return zoom;
}

// node_modules/svelte/src/transition/index.js
function cubic_out(t3) {
  const f3 = t3 - 1;
  return f3 * f3 * f3 + 1;
}
var slide_warning = false;
function slide(node, { delay = 0, duration = 400, easing = cubic_out, axis = "y" } = {}) {
  const style = getComputedStyle(node);
  if (dev_fallback_default && !slide_warning && /(contents|inline|table)/.test(style.display)) {
    slide_warning = true;
    Promise.resolve().then(() => slide_warning = false);
    transition_slide_display(style.display);
  }
  const opacity = +style.opacity;
  const primary_property = axis === "y" ? "height" : "width";
  const primary_property_value = parseFloat(style[primary_property]);
  const secondary_properties = axis === "y" ? ["top", "bottom"] : ["left", "right"];
  const capitalized_secondary_properties = secondary_properties.map(
    (e2) => (
      /** @type {'Left' | 'Right' | 'Top' | 'Bottom'} */
      `${e2[0].toUpperCase()}${e2.slice(1)}`
    )
  );
  const padding_start_value = parseFloat(style[`padding${capitalized_secondary_properties[0]}`]);
  const padding_end_value = parseFloat(style[`padding${capitalized_secondary_properties[1]}`]);
  const margin_start_value = parseFloat(style[`margin${capitalized_secondary_properties[0]}`]);
  const margin_end_value = parseFloat(style[`margin${capitalized_secondary_properties[1]}`]);
  const border_width_start_value = parseFloat(
    style[`border${capitalized_secondary_properties[0]}Width`]
  );
  const border_width_end_value = parseFloat(
    style[`border${capitalized_secondary_properties[1]}Width`]
  );
  return {
    delay,
    duration,
    easing,
    css: (t3) => `overflow: hidden;opacity: ${Math.min(t3 * 20, 1) * opacity};${primary_property}: ${t3 * primary_property_value}px;padding-${secondary_properties[0]}: ${t3 * padding_start_value}px;padding-${secondary_properties[1]}: ${t3 * padding_end_value}px;margin-${secondary_properties[0]}: ${t3 * margin_start_value}px;margin-${secondary_properties[1]}: ${t3 * margin_end_value}px;border-${secondary_properties[0]}-width: ${t3 * border_width_start_value}px;border-${secondary_properties[1]}-width: ${t3 * border_width_end_value}px;min-${primary_property}: 0`
  };
}

// WizardFields.svelte
var root_2 = from_html(`<div class="char-block bevel-down svelte-16d9qba" style="margin-bottom: 10px; margin-top: 10px;"><div class="char-header svelte-16d9qba"><span class="char-name-display" style="font-size: 12px;"></span> <button class="del-btn svelte-16d9qba">\xD7</button></div> <div class="char-body svelte-16d9qba"><label class="svelte-16d9qba">The Goal</label> <div class="input-wrap svelte-16d9qba"><input class="retro-input" placeholder="What do they want right now?"/> <button>?</button></div> <div class="grid-3-p svelte-16d9qba" style="margin-top: 5px;"><div><label style="color:#800000; font-size: 0.8em;" class="svelte-16d9qba">1. FAIL (NO, AND)</label> <div class="input-wrap svelte-16d9qba"><textarea class="retro-input" rows="3" placeholder="Disaster strikes..."></textarea> <button>?</button></div></div> <div><label style="color:#808000; font-size: 0.8em;" class="svelte-16d9qba">2. FAIL (NO, BUT)</label> <div class="input-wrap svelte-16d9qba"><textarea class="retro-input" rows="3" placeholder="Learning moment..."></textarea> <button>?</button></div></div> <div><label style="color:#008000; font-size: 0.8em;" class="svelte-16d9qba">3. SUCCESS (YES, BUT)</label> <div class="input-wrap svelte-16d9qba"><textarea class="retro-input" rows="3" placeholder="New problem arises..."></textarea> <button>?</button></div></div></div></div></div>`);
var root_4 = from_html(`<div class="char-body svelte-16d9qba"><div class="input-wrap svelte-16d9qba"><textarea class="retro-input" rows="2" placeholder="Role &amp; Bio..."></textarea> <button>?</button> <button class="assist-btn analyze-btn svelte-16d9qba" title="Auto-Grade Scales">\u26A1</button></div> <div class="score-grid svelte-16d9qba"><div class="score-item svelte-16d9qba"><div class="score-header svelte-16d9qba"><span class="score-label" title="How good are they at what they do?">COMPETENCE</span> <span class="score-val"> </span></div> <div class="score-track bevel-down svelte-16d9qba" role="button" tabindex="0"><div class="score-fill svelte-16d9qba"></div></div></div> <div class="score-item svelte-16d9qba"><div class="score-header svelte-16d9qba"><span class="score-label" title="Do they make things happen?">PROACTIVITY</span> <span class="score-val"> </span></div> <div class="score-track bevel-down svelte-16d9qba" role="button" tabindex="0"><div class="score-fill svelte-16d9qba"></div></div></div> <div class="score-item svelte-16d9qba"><div class="score-header svelte-16d9qba"><span class="score-label" title="Do we like them? (Sympathy)">LIKABILITY</span> <span class="score-val"> </span></div> <div class="score-track bevel-down svelte-16d9qba" role="button" tabindex="0"><div class="score-fill svelte-16d9qba"></div></div></div></div></div>`);
var root_3 = from_html(`<div class="char-block bevel-down svelte-16d9qba"><div class="char-header svelte-16d9qba" title="Toggle Expand" role="button" tabindex="0"><div class="char-title svelte-16d9qba"><span> </span> <input type="text" class="char-name-input svelte-16d9qba" placeholder="Name"/></div> <div class="char-controls svelte-16d9qba"><button class="svelte-16d9qba">\u25B2</button> <button class="del-btn svelte-16d9qba">\xD7</button> <span class="expand-icon"> </span></div></div> <!></div>`);
var root_6 = from_html(`<div class="char-body svelte-16d9qba"><div class="input-wrap svelte-16d9qba"><textarea class="retro-input" rows="3" placeholder="Action &amp; Change..."></textarea> <button>?</button> <button class="assist-btn analyze-btn svelte-16d9qba" title="Auto-Grade Tension &amp; Type">\u26A1</button></div> <div class="score-item svelte-16d9qba" style="margin-top: 10px;"><div class="score-header svelte-16d9qba"><span class="score-label">TENSION</span> <span class="score-val"> </span></div> <div class="score-track bevel-down svelte-16d9qba" role="button" tabindex="0"><div class="score-fill svelte-16d9qba"></div></div></div></div>`);
var root_5 = from_html(`<div class="char-block bevel-down svelte-16d9qba"><div class="char-header svelte-16d9qba" role="button" tabindex="0"><div class="char-title svelte-16d9qba"><span style="width: 80px; text-align:center;"> </span> <input type="text" class="char-name-input svelte-16d9qba" placeholder="Beat Title"/></div> <div class="char-controls svelte-16d9qba"><button class="svelte-16d9qba">\u25B2</button> <button class="del-btn svelte-16d9qba">\xD7</button></div></div> <!></div>`);
var root = from_html(`<div class="wizard-container svelte-16d9qba"><fieldset class="bevel-groove memory-core svelte-16d9qba"><legend class="svelte-16d9qba">MEMORY CORE</legend> <div class="memory-status svelte-16d9qba"><div class="status-indicator svelte-16d9qba"><span></span> <span> </span></div> <div class="status-details"> </div></div> <div class="context-controls svelte-16d9qba"><button> </button> <button class="scrub-btn svelte-16d9qba">\u{1F5D1}\uFE0F PURGE</button></div></fieldset> <fieldset class="bevel-groove svelte-16d9qba"><legend class="svelte-16d9qba">1. CORE ENGINE (SANDERSON'S 1ST LAW OF PLOT)</legend> <label for="w_concept" class="svelte-16d9qba">Concept / Logline</label> <div class="input-wrap svelte-16d9qba"><textarea id="w_concept" class="retro-input" rows="2" placeholder="High concept summary..."></textarea> <button>?</button></div> <label for="w_target" class="svelte-16d9qba"> </label> <div class="input-wrap svelte-16d9qba"><input type="range" id="w_target" class="retro-range" min="50" max="100" step="5"/></div> <button class="autofill-btn svelte-16d9qba">\u2728 AUTO-GENERATE STORY BIBLE</button> <div class="grid-3-p svelte-16d9qba"><div class="p-col svelte-16d9qba"><label for="p_promise" title="What plot/tonal promise do you make in the first chapter?" class="svelte-16d9qba">THE PROMISE (HOOK)</label> <div class="input-wrap svelte-16d9qba"><textarea id="p_promise" class="retro-input" rows="4"></textarea> <button>?</button></div></div> <div class="p-col svelte-16d9qba"><label for="p_progress" title="How does the story move forward? (Travel, Discovery, Clues)" class="svelte-16d9qba">THE PROGRESS (SHIFT)</label> <div class="input-wrap svelte-16d9qba"><textarea id="p_progress" class="retro-input" rows="4"></textarea> <button>?</button></div></div> <div class="p-col svelte-16d9qba"><label for="p_payoff" title="How is the promise fulfilled? (Must match the promise type)" class="svelte-16d9qba">THE PAYOFF (CLIMAX)</label> <div class="input-wrap svelte-16d9qba"><textarea id="p_payoff" class="retro-input" rows="4"></textarea> <button>?</button></div></div></div></fieldset> <fieldset class="bevel-groove svelte-16d9qba"><legend class="svelte-16d9qba">2. STRUCTURE DNA (M.I.C.E. & CYCLES)</legend> <div class="grid-2 svelte-16d9qba"><div><label for="dna_mice" class="svelte-16d9qba">Primary M.I.C.E. Thread</label> <div class="input-wrap svelte-16d9qba"><select id="dna_mice" class="retro-input"><option>EVENT (Status Quo)</option><option>CHARACTER (Identity)</option><option>MILIEU (Place)</option><option>INQUIRY (Mystery)</option></select> <button>?</button></div></div> <div><label for="dna_order" class="svelte-16d9qba">Nesting Order</label> <div class="input-wrap svelte-16d9qba"><input id="dna_order" type="text" class="retro-input" placeholder="e.g. Milieu > Inquiry > Character"/> <button>?</button></div></div></div> <div style="margin-top: 15px; color: var(--cj-accent); border-bottom: 1px dashed var(--cj-dim); font-weight:bold; font-size:0.9em; text-transform:uppercase;">TRY / FAIL CYCLES (SCENE ESCALATION)</div> <!> <button class="add-char-btn svelte-16d9qba">+ ADD TRY-FAIL CYCLE</button></fieldset> <fieldset class="bevel-groove character-section svelte-16d9qba"><legend class="svelte-16d9qba">3. DRAMATIS PERSONAE (THE SLIDERS)</legend> <div class="char-list"></div> <button class="add-char-btn svelte-16d9qba">+ ADD CHARACTER</button></fieldset> <fieldset class="bevel-groove svelte-16d9qba"><legend class="svelte-16d9qba">4. THE BEAT SHEET</legend> <div class="char-list"></div> <button class="add-char-btn svelte-16d9qba">+ ADD STORY BEAT</button></fieldset> <div class="footer-controls svelte-16d9qba"><button class="reset-form-btn svelte-16d9qba">RESET FIELDS</button></div></div>`);
var $$css = {
  hash: "svelte-16d9qba",
  code: '.wizard-container.svelte-16d9qba {display:flex;flex-direction:column;gap:20px;padding-bottom:20px;}.bevel-groove.svelte-16d9qba {border:2px groove var(--cj-dim);padding:15px;margin:0;background:transparent;}legend.svelte-16d9qba {font-weight:bold;padding:0 5px;color:var(--cj-text);font-size:1.1em;}label.svelte-16d9qba {display:block;margin-top:12px;margin-bottom:4px;font-size:0.9em;font-weight:bold;color:var(--cj-dim);text-transform:uppercase;}.input-wrap.svelte-16d9qba {display:flex;gap:5px;align-items:flex-start;}.autofill-btn.svelte-16d9qba {width:100%;margin:15px 0;padding:10px;background:linear-gradient(90deg, #4b0082, #800080);color:#fff;font-weight:900;border:2px outset #a020f0;cursor:pointer;}.autofill-btn.svelte-16d9qba:hover {background:linear-gradient(90deg, #6a0dad, #9932cc);}\n    \n    /* Reused styles from old version for consistency */.char-block.svelte-16d9qba {background:rgba(0,0,0,0.03);padding:5px;border:2px solid var(--cj-dim);}.char-header.svelte-16d9qba {display:flex;justify-content:space-between;align-items:center;background:rgba(0,0,0,0.1);padding:5px;cursor:pointer;}.char-title.svelte-16d9qba {display:flex;align-items:center;gap:8px;flex:1;}.role-badge.svelte-16d9qba {font-size:10px;font-weight:900;padding:2px 4px;color:#fff;text-transform:uppercase;background:#555;}.char-name-input.svelte-16d9qba {background:transparent;border:none;font-weight:bold;font-family:inherit;font-size:14px;color:var(--cj-text);width:100%;}.char-name-input.svelte-16d9qba:focus {outline:none;border-bottom:1px dashed var(--cj-accent);}.char-controls.svelte-16d9qba button:where(.svelte-16d9qba) {background:transparent;border:none;cursor:pointer;font-weight:bold;color:var(--cj-dim);padding:0 4px;}.del-btn.svelte-16d9qba {color:red !important;margin-left:5px;}.char-body.svelte-16d9qba {padding:10px;border-top:1px dashed var(--cj-dim);}.add-char-btn.svelte-16d9qba {width:100%;padding:8px;border:2px dashed var(--cj-dim);background:transparent;cursor:pointer;font-weight:bold;color:var(--cj-dim);}.add-char-btn.svelte-16d9qba:hover {background:rgba(0,0,0,0.05);color:var(--cj-text);border-style:solid;}.grid-3-p.svelte-16d9qba {display:grid;grid-template-columns:1fr 1fr 1fr;gap:10px;}.grid-2.svelte-16d9qba {display:grid;grid-template-columns:1fr 1fr;gap:15px;}.p-col.svelte-16d9qba label:where(.svelte-16d9qba) {text-align:center;color:var(--cj-accent);}.retro-input {resize:none;overflow:hidden;min-height:28px;box-sizing:border-box;}.memory-core.svelte-16d9qba {background:rgba(0,0,0,0.05);}.memory-status.svelte-16d9qba {display:flex;justify-content:space-between;align-items:center;background:#000;color:#00ff00;padding:8px;margin-bottom:10px;border:2px inset var(--cj-dim);}.status-indicator.svelte-16d9qba {display:flex;gap:8px;align-items:center;font-weight:900;}.led.svelte-16d9qba {width:10px;height:10px;border-radius:50%;border:1px solid #00ff00;}.led.on.svelte-16d9qba {background:#00ff00;box-shadow:0 0 5px #00ff00;}.led.off.svelte-16d9qba {background:#111;border-color:#555;}.context-controls.svelte-16d9qba {display:flex;gap:5px;}.upload-btn.svelte-16d9qba, .scrub-btn.svelte-16d9qba, .assist-btn.svelte-16d9qba, .reset-form-btn.svelte-16d9qba {background:var(--cj-bg);color:var(--cj-text);border:2px outset var(--cj-light);cursor:pointer;font-weight:bold;display:flex;align-items:center;justify-content:center;}.upload-btn.svelte-16d9qba {flex:1;padding:8px;}.assist-btn.svelte-16d9qba {width:32px;height:30px;flex-shrink:0;background:var(--cj-accent);color:#fff;border-color:var(--cj-light);position:relative;}.assist-btn.loading.svelte-16d9qba::after {content:"";width:14px;height:14px;border:2px solid #fff;border-top-color:transparent;border-radius:50%; animation: svelte-16d9qba-spin 0.8s linear infinite;position:absolute;}\n    @keyframes svelte-16d9qba-spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }.footer-controls.svelte-16d9qba {margin-top:20px;}.reset-form-btn.svelte-16d9qba {width:100%;padding:10px;border-color:#ff0000;color:#ff0000;}.reset-form-btn.svelte-16d9qba:hover {background:#ff0000;color:#fff;}\n\n    /* CHARACTER SCALES */.score-grid.svelte-16d9qba {display:grid;grid-template-columns:1fr 1fr 1fr;gap:10px;margin:15px 0;}.score-item.svelte-16d9qba {display:flex;flex-direction:column;gap:4px;}.score-header.svelte-16d9qba {display:flex;justify-content:space-between;font-size:10px;font-weight:bold;color:var(--cj-dim);}.score-track.svelte-16d9qba {height:16px;background:#fff;border:2px inset var(--cj-dim);cursor:crosshair;position:relative;overflow:hidden;}.score-fill.svelte-16d9qba {height:100%;transition:width 0.3s ease;border-right:2px solid rgba(0,0,0,0.5);}.analyze-btn.svelte-16d9qba {background:#800080;color:white;border-color:#dcdcdc;}\n\n    @media (max-width: 600px) {.grid-3-p.svelte-16d9qba, .grid-2.svelte-16d9qba {grid-template-columns:1fr;}.score-grid.svelte-16d9qba {grid-template-columns:1fr;}\n    }'
};
function WizardFields($$anchor, $$props) {
  push($$props, true);
  append_styles($$anchor, $$css);
  let wizardState = prop($$props, "wizardState", 7);
  function handleInput() {
    $$props.onSave();
  }
  function handleBlur() {
    $$props.onSave();
  }
  function addCharacter() {
    const id = "c" + Date.now();
    wizardState().characters.push({
      id,
      role: "Support",
      name: "New Character",
      description: "",
      competence: 50,
      proactivity: 50,
      likability: 50,
      flaw: "",
      revelation: "",
      expanded: true
    });
    $$props.onSave();
  }
  function removeCharacter(index4) {
    if (confirm("Delete this character block?")) {
      wizardState().characters.splice(index4, 1);
      $$props.onSave();
    }
  }
  function toggleExpandChar(index4) {
    wizardState().characters[index4].expanded = !wizardState().characters[index4].expanded;
  }
  async function autoGrade(index4) {
    if (!$$props.onGradeCharacter)
      return;
    const char = wizardState().characters[index4];
    const updated = await $$props.onGradeCharacter(char);
    wizardState().characters[index4] = updated;
    $$props.onSave();
  }
  function handleScoreClick(e2, index4, field) {
    const target = e2.currentTarget;
    const rect = target.getBoundingClientRect();
    const x = e2.clientX - rect.left;
    const percentage = Math.max(0, Math.min(100, Math.round(x / rect.width * 100)));
    wizardState().characters[index4][field] = percentage;
    $$props.onSave();
  }
  function addTryFailCycle() {
    const id = "tf" + Date.now();
    if (!wizardState().structureDNA.tryFailCycles)
      wizardState().structureDNA.tryFailCycles = [];
    wizardState().structureDNA.tryFailCycles.push({ id, goal: "", attempt1: "", attempt2: "", success: "" });
    $$props.onSave();
  }
  function removeTryFailCycle(index4) {
    if (confirm("Delete this cycle?")) {
      wizardState().structureDNA.tryFailCycles.splice(index4, 1);
      $$props.onSave();
    }
  }
  function addStoryBlock() {
    const id = "s" + Date.now();
    wizardState().structure.push({
      id,
      title: "New Beat",
      type: "Beat",
      description: "",
      characters: "",
      tension: 50,
      expanded: true
    });
    $$props.onSave();
  }
  function removeStoryBlock(index4) {
    if (confirm("Delete this story beat?")) {
      wizardState().structure.splice(index4, 1);
      $$props.onSave();
    }
  }
  function moveStoryBlock(index4, direction) {
    if (index4 + direction < 0 || index4 + direction >= wizardState().structure.length)
      return;
    const temp = wizardState().structure[index4];
    wizardState().structure[index4] = wizardState().structure[index4 + direction];
    wizardState().structure[index4 + direction] = temp;
    $$props.onSave();
  }
  function toggleExpandStory(index4) {
    wizardState().structure[index4].expanded = !wizardState().structure[index4].expanded;
  }
  async function autoGradeStructure(index4) {
    if (!$$props.onGradeStructure)
      return;
    const beat = wizardState().structure[index4];
    const updated = await $$props.onGradeStructure(beat);
    wizardState().structure[index4] = updated;
    $$props.onSave();
  }
  function handleTensionClick(e2, index4) {
    const target = e2.currentTarget;
    const rect = target.getBoundingClientRect();
    const x = e2.clientX - rect.left;
    const percentage = Math.max(0, Math.min(100, Math.round(x / rect.width * 100)));
    wizardState().structure[index4].tension = percentage;
    $$props.onSave();
  }
  function getTensionColor(val) {
    const hue = 240 + val / 100 * 60;
    return `hsl(${hue}, 70%, 50%)`;
  }
  function getScoreColor(val) {
    const c2 = $$props.settings.gradingColors;
    if (val >= 90)
      return c2.masterpiece;
    if (val >= 80)
      return c2.excellent;
    if (val >= 60)
      return c2.good;
    if (val >= 40)
      return c2.average;
    if (val >= 20)
      return c2.poor;
    return c2.critical;
  }
  let contextLength = user_derived(() => wizardState().inspirationContext ? wizardState().inspirationContext.length : 0);
  let hasContext2 = user_derived(() => get(contextLength) > 0);
  var div = root();
  var fieldset = child(div);
  var div_1 = sibling(child(fieldset), 2);
  var div_2 = child(div_1);
  var span = child(div_2);
  var span_1 = sibling(span, 2);
  var text2 = child(span_1, true);
  reset(span_1);
  reset(div_2);
  var div_3 = sibling(div_2, 2);
  var text_1 = child(div_3);
  reset(div_3);
  reset(div_1);
  var div_4 = sibling(div_1, 2);
  var button = child(div_4);
  button.__click = function(...$$args) {
    var _a3;
    (_a3 = $$props.isContextSynced ? void 0 : $$props.onUploadContext) == null ? void 0 : _a3.apply(this, $$args);
  };
  var text_2 = child(button, true);
  reset(button);
  var button_1 = sibling(button, 2);
  button_1.__click = function(...$$args) {
    var _a3;
    (_a3 = $$props.onScrubContext) == null ? void 0 : _a3.apply(this, $$args);
  };
  reset(div_4);
  reset(fieldset);
  var fieldset_1 = sibling(fieldset, 2);
  var div_5 = sibling(child(fieldset_1), 4);
  var textarea = child(div_5);
  remove_textarea_child(textarea);
  textarea.__input = handleInput;
  effect(() => bind_value(textarea, () => wizardState().concept, ($$value) => wizardState().concept = $$value));
  action(textarea, ($$node, $$action_arg) => {
    var _a3;
    return (_a3 = autoResize) == null ? void 0 : _a3($$node, $$action_arg);
  }, () => wizardState().concept);
  var button_2 = sibling(textarea, 2);
  button_2.__click = () => $$props.onAssist("concept");
  reset(div_5);
  var label = sibling(div_5, 2);
  var text_3 = child(label);
  reset(label);
  var div_6 = sibling(label, 2);
  var input = child(div_6);
  remove_input_defaults(input);
  input.__change = handleInput;
  reset(div_6);
  var button_3 = sibling(div_6, 2);
  button_3.__click = function(...$$args) {
    var _a3;
    (_a3 = $$props.onAutoFill) == null ? void 0 : _a3.apply(this, $$args);
  };
  var div_7 = sibling(button_3, 2);
  var div_8 = child(div_7);
  var div_9 = sibling(child(div_8), 2);
  var textarea_1 = child(div_9);
  remove_textarea_child(textarea_1);
  textarea_1.__input = handleInput;
  effect(() => bind_value(textarea_1, () => wizardState().threePs.promise, ($$value) => wizardState().threePs.promise = $$value));
  action(textarea_1, ($$node, $$action_arg) => {
    var _a3;
    return (_a3 = autoResize) == null ? void 0 : _a3($$node, $$action_arg);
  }, () => wizardState().threePs.promise);
  var button_4 = sibling(textarea_1, 2);
  button_4.__click = () => $$props.onAssist("threePs.promise");
  reset(div_9);
  reset(div_8);
  var div_10 = sibling(div_8, 2);
  var div_11 = sibling(child(div_10), 2);
  var textarea_2 = child(div_11);
  remove_textarea_child(textarea_2);
  textarea_2.__input = handleInput;
  effect(() => bind_value(textarea_2, () => wizardState().threePs.progress, ($$value) => wizardState().threePs.progress = $$value));
  action(textarea_2, ($$node, $$action_arg) => {
    var _a3;
    return (_a3 = autoResize) == null ? void 0 : _a3($$node, $$action_arg);
  }, () => wizardState().threePs.progress);
  var button_5 = sibling(textarea_2, 2);
  button_5.__click = () => $$props.onAssist("threePs.progress");
  reset(div_11);
  reset(div_10);
  var div_12 = sibling(div_10, 2);
  var div_13 = sibling(child(div_12), 2);
  var textarea_3 = child(div_13);
  remove_textarea_child(textarea_3);
  textarea_3.__input = handleInput;
  effect(() => bind_value(textarea_3, () => wizardState().threePs.payoff, ($$value) => wizardState().threePs.payoff = $$value));
  action(textarea_3, ($$node, $$action_arg) => {
    var _a3;
    return (_a3 = autoResize) == null ? void 0 : _a3($$node, $$action_arg);
  }, () => wizardState().threePs.payoff);
  var button_6 = sibling(textarea_3, 2);
  button_6.__click = () => $$props.onAssist("threePs.payoff");
  reset(div_13);
  reset(div_12);
  reset(div_7);
  reset(fieldset_1);
  var fieldset_2 = sibling(fieldset_1, 2);
  var div_14 = sibling(child(fieldset_2), 2);
  var div_15 = child(div_14);
  var div_16 = sibling(child(div_15), 2);
  var select = child(div_16);
  select.__change = handleInput;
  var option = child(select);
  option.value = option.__value = "Event";
  var option_1 = sibling(option);
  option_1.value = option_1.__value = "Character";
  var option_2 = sibling(option_1);
  option_2.value = option_2.__value = "Milieu";
  var option_3 = sibling(option_2);
  option_3.value = option_3.__value = "Inquiry";
  reset(select);
  var button_7 = sibling(select, 2);
  button_7.__click = () => $$props.onAssist("structureDNA.primaryThread");
  reset(div_16);
  reset(div_15);
  var div_17 = sibling(div_15, 2);
  var div_18 = sibling(child(div_17), 2);
  var input_1 = child(div_18);
  remove_input_defaults(input_1);
  input_1.__input = handleInput;
  var button_8 = sibling(input_1, 2);
  button_8.__click = () => $$props.onAssist("structureDNA.nestingOrder");
  reset(div_18);
  reset(div_17);
  reset(div_14);
  var node = sibling(div_14, 4);
  {
    var consequent = ($$anchor2) => {
      var fragment = comment();
      var node_1 = first_child(fragment);
      each(node_1, 17, () => wizardState().structureDNA.tryFailCycles, index, ($$anchor3, cycle, i3) => {
        var div_19 = root_2();
        var div_20 = child(div_19);
        var span_2 = child(div_20);
        span_2.textContent = `CYCLE ${i3 + 1}`;
        var button_9 = sibling(span_2, 2);
        button_9.__click = () => removeTryFailCycle(i3);
        reset(div_20);
        var div_21 = sibling(div_20, 2);
        var label_1 = child(div_21);
        set_attribute2(label_1, "for", `cycle_goal_${i3}`);
        var div_22 = sibling(label_1, 2);
        var input_2 = child(div_22);
        remove_input_defaults(input_2);
        set_attribute2(input_2, "id", `cycle_goal_${i3}`);
        var button_10 = sibling(input_2, 2);
        button_10.__click = () => $$props.onAssist(`structureDNA.tryFailCycles.${i3}.goal`);
        reset(div_22);
        var div_23 = sibling(div_22, 2);
        var div_24 = child(div_23);
        var label_2 = child(div_24);
        set_attribute2(label_2, "for", `cycle_att1_${i3}`);
        var div_25 = sibling(label_2, 2);
        var textarea_4 = child(div_25);
        remove_textarea_child(textarea_4);
        set_attribute2(textarea_4, "id", `cycle_att1_${i3}`);
        var button_11 = sibling(textarea_4, 2);
        button_11.__click = () => $$props.onAssist(`structureDNA.tryFailCycles.${i3}.attempt1`);
        reset(div_25);
        reset(div_24);
        var div_26 = sibling(div_24, 2);
        var label_3 = child(div_26);
        set_attribute2(label_3, "for", `cycle_att2_${i3}`);
        var div_27 = sibling(label_3, 2);
        var textarea_5 = child(div_27);
        remove_textarea_child(textarea_5);
        set_attribute2(textarea_5, "id", `cycle_att2_${i3}`);
        var button_12 = sibling(textarea_5, 2);
        button_12.__click = () => $$props.onAssist(`structureDNA.tryFailCycles.${i3}.attempt2`);
        reset(div_27);
        reset(div_26);
        var div_28 = sibling(div_26, 2);
        var label_4 = child(div_28);
        set_attribute2(label_4, "for", `cycle_succ_${i3}`);
        var div_29 = sibling(label_4, 2);
        var textarea_6 = child(div_29);
        remove_textarea_child(textarea_6);
        set_attribute2(textarea_6, "id", `cycle_succ_${i3}`);
        var button_13 = sibling(textarea_6, 2);
        button_13.__click = () => $$props.onAssist(`structureDNA.tryFailCycles.${i3}.success`);
        reset(div_29);
        reset(div_28);
        reset(div_23);
        reset(div_21);
        reset(div_19);
        template_effect(() => {
          input_2.disabled = $$props.loadingField === `structureDNA.tryFailCycles.${i3}.goal`;
          set_class(button_10, 1, `assist-btn ${$$props.loadingField === `structureDNA.tryFailCycles.${i3}.goal` ? "loading" : ""}`, "svelte-16d9qba");
          button_10.disabled = !!$$props.loadingField;
          textarea_4.disabled = $$props.loadingField === `structureDNA.tryFailCycles.${i3}.attempt1`;
          set_class(button_11, 1, `assist-btn ${$$props.loadingField === `structureDNA.tryFailCycles.${i3}.attempt1` ? "loading" : ""}`, "svelte-16d9qba");
          button_11.disabled = !!$$props.loadingField;
          textarea_5.disabled = $$props.loadingField === `structureDNA.tryFailCycles.${i3}.attempt2`;
          set_class(button_12, 1, `assist-btn ${$$props.loadingField === `structureDNA.tryFailCycles.${i3}.attempt2` ? "loading" : ""}`, "svelte-16d9qba");
          button_12.disabled = !!$$props.loadingField;
          textarea_6.disabled = $$props.loadingField === `structureDNA.tryFailCycles.${i3}.success`;
          set_class(button_13, 1, `assist-btn ${$$props.loadingField === `structureDNA.tryFailCycles.${i3}.success` ? "loading" : ""}`, "svelte-16d9qba");
          button_13.disabled = !!$$props.loadingField;
        });
        event("blur", input_2, handleBlur);
        bind_value(input_2, () => get(cycle).goal, ($$value) => get(cycle).goal = $$value);
        event("blur", textarea_4, handleBlur);
        bind_value(textarea_4, () => get(cycle).attempt1, ($$value) => get(cycle).attempt1 = $$value);
        event("blur", textarea_5, handleBlur);
        bind_value(textarea_5, () => get(cycle).attempt2, ($$value) => get(cycle).attempt2 = $$value);
        event("blur", textarea_6, handleBlur);
        bind_value(textarea_6, () => get(cycle).success, ($$value) => get(cycle).success = $$value);
        append($$anchor3, div_19);
      });
      append($$anchor2, fragment);
    };
    if_block(node, ($$render) => {
      if (wizardState().structureDNA.tryFailCycles)
        $$render(consequent);
    });
  }
  var button_14 = sibling(node, 2);
  button_14.__click = addTryFailCycle;
  reset(fieldset_2);
  var fieldset_3 = sibling(fieldset_2, 2);
  var div_30 = sibling(child(fieldset_3), 2);
  each(div_30, 31, () => wizardState().characters, (char) => char.id, ($$anchor2, char, i3) => {
    var div_31 = root_3();
    var div_32 = child(div_31);
    div_32.__click = () => toggleExpandChar(get(i3));
    div_32.__keydown = (e2) => e2.key === "Enter" && toggleExpandChar(get(i3));
    var div_33 = child(div_32);
    var span_3 = child(div_33);
    var text_4 = child(span_3, true);
    reset(span_3);
    var input_3 = sibling(span_3, 2);
    remove_input_defaults(input_3);
    input_3.__input = handleInput;
    input_3.__click = (e2) => e2.stopPropagation();
    reset(div_33);
    var div_34 = sibling(div_33, 2);
    var button_15 = child(div_34);
    button_15.__click = (e2) => {
      e2.stopPropagation();
      moveStoryBlock(get(i3), -1);
    };
    var button_16 = sibling(button_15, 2);
    button_16.__click = (e2) => {
      e2.stopPropagation();
      removeCharacter(get(i3));
    };
    var span_4 = sibling(button_16, 2);
    var text_5 = child(span_4, true);
    reset(span_4);
    reset(div_34);
    reset(div_32);
    var node_2 = sibling(div_32, 2);
    {
      var consequent_1 = ($$anchor3) => {
        var div_35 = root_4();
        var div_36 = child(div_35);
        var textarea_7 = child(div_36);
        remove_textarea_child(textarea_7);
        textarea_7.__input = handleInput;
        effect(() => bind_value(textarea_7, () => get(char).description, ($$value) => get(char).description = $$value));
        action(textarea_7, ($$node, $$action_arg) => {
          var _a3;
          return (_a3 = autoResize) == null ? void 0 : _a3($$node, $$action_arg);
        }, () => get(char).description);
        var button_17 = sibling(textarea_7, 2);
        button_17.__click = () => $$props.onAssist(`characters.${get(i3)}.description`);
        var button_18 = sibling(button_17, 2);
        button_18.__click = () => autoGrade(get(i3));
        reset(div_36);
        var div_37 = sibling(div_36, 2);
        var div_38 = child(div_37);
        var div_39 = child(div_38);
        var span_5 = sibling(child(div_39), 2);
        var text_6 = child(span_5);
        reset(span_5);
        reset(div_39);
        var div_40 = sibling(div_39, 2);
        div_40.__click = (e2) => handleScoreClick(e2, get(i3), "competence");
        div_40.__keydown = (e2) => e2.key === "Enter" && handleScoreClick(e2, get(i3), "competence");
        var div_41 = child(div_40);
        reset(div_40);
        reset(div_38);
        var div_42 = sibling(div_38, 2);
        var div_43 = child(div_42);
        var span_6 = sibling(child(div_43), 2);
        var text_7 = child(span_6);
        reset(span_6);
        reset(div_43);
        var div_44 = sibling(div_43, 2);
        div_44.__click = (e2) => handleScoreClick(e2, get(i3), "proactivity");
        div_44.__keydown = (e2) => e2.key === "Enter" && handleScoreClick(e2, get(i3), "proactivity");
        var div_45 = child(div_44);
        reset(div_44);
        reset(div_42);
        var div_46 = sibling(div_42, 2);
        var div_47 = child(div_46);
        var span_7 = sibling(child(div_47), 2);
        var text_8 = child(span_7);
        reset(span_7);
        reset(div_47);
        var div_48 = sibling(div_47, 2);
        div_48.__click = (e2) => handleScoreClick(e2, get(i3), "likability");
        div_48.__keydown = (e2) => e2.key === "Enter" && handleScoreClick(e2, get(i3), "likability");
        var div_49 = child(div_48);
        reset(div_48);
        reset(div_46);
        reset(div_37);
        reset(div_35);
        template_effect(
          ($0, $1, $2) => {
            var _a3, _b3, _c2, _d, _e, _f;
            set_class(button_17, 1, `assist-btn ${$$props.loadingField === `characters.${get(i3)}.description` ? "loading" : ""}`, "svelte-16d9qba");
            button_17.disabled = !!$$props.loadingField;
            set_text(text_6, `${(_a3 = get(char).competence) != null ? _a3 : ""}%`);
            set_style(div_41, `width: ${(_b3 = get(char).competence) != null ? _b3 : ""}%; background: ${$0 != null ? $0 : ""}`);
            set_text(text_7, `${(_c2 = get(char).proactivity) != null ? _c2 : ""}%`);
            set_style(div_45, `width: ${(_d = get(char).proactivity) != null ? _d : ""}%; background: ${$1 != null ? $1 : ""}`);
            set_text(text_8, `${(_e = get(char).likability) != null ? _e : ""}%`);
            set_style(div_49, `width: ${(_f = get(char).likability) != null ? _f : ""}%; background: ${$2 != null ? $2 : ""}`);
          },
          [
            () => getScoreColor(get(char).competence),
            () => getScoreColor(get(char).proactivity),
            () => getScoreColor(get(char).likability)
          ]
        );
        transition(3, div_35, () => slide);
        append($$anchor3, div_35);
      };
      if_block(node_2, ($$render) => {
        if (get(char).expanded)
          $$render(consequent_1);
      });
    }
    reset(div_31);
    template_effect(
      ($0) => {
        set_class(span_3, 1, `role-badge ${$0 != null ? $0 : ""}`, "svelte-16d9qba");
        set_text(text_4, get(char).role);
        button_15.disabled = get(i3) === 0;
        set_text(text_5, get(char).expanded ? "\u2212" : "+");
      },
      [() => get(char).role.toLowerCase()]
    );
    bind_value(input_3, () => get(char).name, ($$value) => get(char).name = $$value);
    animation(div_31, () => flip, () => ({ duration: 300 }));
    append($$anchor2, div_31);
  });
  reset(div_30);
  var button_19 = sibling(div_30, 2);
  button_19.__click = addCharacter;
  reset(fieldset_3);
  var fieldset_4 = sibling(fieldset_3, 2);
  var div_50 = sibling(child(fieldset_4), 2);
  each(div_50, 31, () => wizardState().structure, (block2) => block2.id, ($$anchor2, block2, i3) => {
    var div_51 = root_5();
    var div_52 = child(div_51);
    div_52.__click = () => toggleExpandStory(get(i3));
    div_52.__keydown = (e2) => e2.key === "Enter" && toggleExpandStory(get(i3));
    var div_53 = child(div_52);
    var span_8 = child(div_53);
    var text_9 = child(span_8, true);
    reset(span_8);
    var input_4 = sibling(span_8, 2);
    remove_input_defaults(input_4);
    input_4.__input = handleInput;
    input_4.__click = (e2) => e2.stopPropagation();
    reset(div_53);
    var div_54 = sibling(div_53, 2);
    var button_20 = child(div_54);
    button_20.__click = (e2) => {
      e2.stopPropagation();
      moveStoryBlock(get(i3), -1);
    };
    var button_21 = sibling(button_20, 2);
    button_21.__click = (e2) => {
      e2.stopPropagation();
      removeStoryBlock(get(i3));
    };
    reset(div_54);
    reset(div_52);
    var node_3 = sibling(div_52, 2);
    {
      var consequent_2 = ($$anchor3) => {
        var div_55 = root_6();
        var div_56 = child(div_55);
        var textarea_8 = child(div_56);
        remove_textarea_child(textarea_8);
        textarea_8.__input = handleInput;
        effect(() => bind_value(textarea_8, () => get(block2).description, ($$value) => get(block2).description = $$value));
        action(textarea_8, ($$node, $$action_arg) => {
          var _a3;
          return (_a3 = autoResize) == null ? void 0 : _a3($$node, $$action_arg);
        }, () => get(block2).description);
        var button_22 = sibling(textarea_8, 2);
        button_22.__click = () => $$props.onAssist(`structure.${get(i3)}.description`);
        var button_23 = sibling(button_22, 2);
        button_23.__click = () => autoGradeStructure(get(i3));
        reset(div_56);
        var div_57 = sibling(div_56, 2);
        var div_58 = child(div_57);
        var span_9 = sibling(child(div_58), 2);
        var text_10 = child(span_9);
        reset(span_9);
        reset(div_58);
        var div_59 = sibling(div_58, 2);
        div_59.__click = (e2) => handleTensionClick(e2, get(i3));
        div_59.__keydown = (e2) => e2.key === "Enter" && handleTensionClick(e2, get(i3));
        var div_60 = child(div_59);
        reset(div_59);
        reset(div_57);
        reset(div_55);
        template_effect(
          ($0) => {
            var _a3, _b3;
            set_class(button_22, 1, `assist-btn ${$$props.loadingField === `structure.${get(i3)}.description` ? "loading" : ""}`, "svelte-16d9qba");
            button_22.disabled = !!$$props.loadingField;
            set_text(text_10, `${(_a3 = get(block2).tension) != null ? _a3 : ""}%`);
            set_style(div_60, `width: ${(_b3 = get(block2).tension) != null ? _b3 : ""}%; background: ${$0 != null ? $0 : ""}`);
          },
          [() => getTensionColor(get(block2).tension)]
        );
        transition(3, div_55, () => slide);
        append($$anchor3, div_55);
      };
      if_block(node_3, ($$render) => {
        if (get(block2).expanded)
          $$render(consequent_2);
      });
    }
    reset(div_51);
    template_effect(
      ($0) => {
        set_class(span_8, 1, `role-badge ${$0 != null ? $0 : ""}`, "svelte-16d9qba");
        set_text(text_9, get(block2).type);
        button_20.disabled = get(i3) === 0;
      },
      [() => get(block2).type.toLowerCase().replace(/\s/g, "-")]
    );
    bind_value(input_4, () => get(block2).title, ($$value) => get(block2).title = $$value);
    animation(div_51, () => flip, () => ({ duration: 300 }));
    append($$anchor2, div_51);
  });
  reset(div_50);
  var button_24 = sibling(div_50, 2);
  button_24.__click = addStoryBlock;
  reset(fieldset_4);
  var div_61 = sibling(fieldset_4, 2);
  var button_25 = child(div_61);
  button_25.__click = function(...$$args) {
    var _a3;
    (_a3 = $$props.onClear) == null ? void 0 : _a3.apply(this, $$args);
  };
  reset(div_61);
  reset(div);
  template_effect(() => {
    var _a3, _b3;
    set_class(span, 1, `led ${get(hasContext2) ? "on" : "off"}`, "svelte-16d9qba");
    set_text(text2, get(hasContext2) ? "DATA LOADED" : "EMPTY");
    set_text(text_1, `SIZE: ${(_a3 = get(contextLength)) != null ? _a3 : ""} CHARS`);
    set_class(button, 1, `upload-btn ${$$props.isContextSynced ? "synced" : ""}`, "svelte-16d9qba");
    button.disabled = $$props.isContextSynced;
    set_text(text_2, $$props.isContextSynced ? "\u2705 SYNCED" : "\u{1F4E5} IMPORT ACTIVE NOTE");
    button_1.disabled = !get(hasContext2);
    textarea.disabled = $$props.loadingField === "concept";
    set_class(button_2, 1, `assist-btn ${$$props.loadingField === "concept" ? "loading" : ""}`, "svelte-16d9qba");
    button_2.disabled = !!$$props.loadingField;
    set_text(text_3, `TARGET QUALITY SCORE: ${(_b3 = wizardState().targetScore || $$props.settings.defaultTargetQuality) != null ? _b3 : ""}`);
    button_3.disabled = !!$$props.loadingField;
    textarea_1.disabled = $$props.loadingField === "threePs.promise";
    set_class(button_4, 1, `assist-btn ${$$props.loadingField === "threePs.promise" ? "loading" : ""}`, "svelte-16d9qba");
    button_4.disabled = !!$$props.loadingField;
    textarea_2.disabled = $$props.loadingField === "threePs.progress";
    set_class(button_5, 1, `assist-btn ${$$props.loadingField === "threePs.progress" ? "loading" : ""}`, "svelte-16d9qba");
    button_5.disabled = !!$$props.loadingField;
    textarea_3.disabled = $$props.loadingField === "threePs.payoff";
    set_class(button_6, 1, `assist-btn ${$$props.loadingField === "threePs.payoff" ? "loading" : ""}`, "svelte-16d9qba");
    button_6.disabled = !!$$props.loadingField;
    set_class(button_7, 1, `assist-btn ${$$props.loadingField === "structureDNA.primaryThread" ? "loading" : ""}`, "svelte-16d9qba");
    button_7.disabled = !!$$props.loadingField;
    set_class(button_8, 1, `assist-btn ${$$props.loadingField === "structureDNA.nestingOrder" ? "loading" : ""}`, "svelte-16d9qba");
    button_8.disabled = !!$$props.loadingField;
  });
  event("blur", textarea, handleBlur);
  bind_value(input, () => wizardState().targetScore, ($$value) => wizardState().targetScore = $$value);
  event("blur", textarea_1, handleBlur);
  event("blur", textarea_2, handleBlur);
  event("blur", textarea_3, handleBlur);
  bind_select_value(select, () => wizardState().structureDNA.primaryThread, ($$value) => wizardState().structureDNA.primaryThread = $$value);
  bind_value(input_1, () => wizardState().structureDNA.nestingOrder, ($$value) => wizardState().structureDNA.nestingOrder = $$value);
  append($$anchor, div);
  pop();
}
delegate(["click", "input", "change", "keydown"]);

// SynthesizerView.svelte
var import_obsidian5 = require("obsidian");
var root_32 = from_html(`<div class="drive-body svelte-1qda04h"><div class="memory-indicator svelte-1qda04h"><span></span> <span class="mem-text svelte-1qda04h"> </span></div> <div class="input-wrap"><textarea class="retro-input" rows="6" placeholder="Paste raw narrative data or..."></textarea> <button class="win95-btn full-width svelte-1qda04h">\u{1F4E5} IMPORT FROM ACTIVE FILE</button></div></div>`);
var root_22 = from_html(`<div class="drive-block bevel-up svelte-1qda04h"><div class="drive-header svelte-1qda04h"><div class="drive-title-row svelte-1qda04h"><span class="drive-icon svelte-1qda04h">\u{1F4BE}</span> <span class="drive-id-badge svelte-1qda04h"> </span> <input type="text" class="drive-name-input svelte-1qda04h" placeholder="Drive Label"/></div> <div class="drive-controls svelte-1qda04h"><button class="win95-btn small svelte-1qda04h" title="Save to Library">\u{1F4BE}</button> <button class="win95-btn small svelte-1qda04h" title="Unmount">\xD7</button></div></div> <!></div>`);
var root_52 = from_html(`<div class="empty-lib svelte-1qda04h">LIBRARY IS EMPTY. SAVE ACTIVE DRIVES TO POPULATE.</div>`);
var root_7 = from_html(`<div class="lib-item svelte-1qda04h"><span class="lib-icon svelte-1qda04h">\u{1F4BF}</span> <span class="lib-name svelte-1qda04h"> </span> <div class="lib-actions svelte-1qda04h"><button class="win95-btn small svelte-1qda04h" title="Mount to Project">\u25B2 LOAD</button> <button class="win95-btn small del-btn svelte-1qda04h" title="Delete from Library">\xD7</button></div></div>`);
var root_42 = from_html(`<div class="library-container bevel-down svelte-1qda04h"><div class="library-header svelte-1qda04h"><span>SOURCE: _NARRATIVE_DRIVES.MD</span> <button class="refresh-btn svelte-1qda04h">\u21BB</button></div> <!></div>`);
var root2 = from_html(`<div class="synthesizer-container svelte-1qda04h"><fieldset class="bevel-groove control-panel svelte-1qda04h"><legend class="svelte-1qda04h">FUSION CONTROL</legend> <div class="input-row svelte-1qda04h"><label for="synth-title" class="svelte-1qda04h">TARGET CODENAME:</label> <input type="text" id="synth-title" class="retro-input" placeholder="e.g. PROJECT CHIMERA (Optional)"/></div> <div class="input-row svelte-1qda04h"><label for="synth-quality" class="svelte-1qda04h"> </label> <input type="range" id="synth-quality" min="50" max="100" step="5" style="flex:1"/></div> <p class="synth-desc svelte-1qda04h">Mount multiple Context Drives to fuse them into a single Epic Narrative. <br/><strong>Status:</strong> </p> <button class="win95-btn primary svelte-1qda04h">INITIALIZE FUSION SEQUENCE</button></fieldset> <div class="drive-section-header svelte-1qda04h">ACTIVE PROJECT DRIVES</div> <div class="drive-list svelte-1qda04h"><!> <button class="win95-btn dashed-btn svelte-1qda04h">+ MOUNT NEW EMPTY DRIVE</button></div> <div class="library-section svelte-1qda04h"><button class="win95-btn library-toggle svelte-1qda04h"> </button> <!></div></div>`);
var $$css2 = {
  hash: "svelte-1qda04h",
  code: ".synthesizer-container.svelte-1qda04h {display:flex;flex-direction:column;gap:15px;padding-bottom:20px;}\n    \n    /* WIN95 PRIMITIVES */.bevel-groove.svelte-1qda04h {border:2px groove #fff;padding:10px;background:transparent;margin:0;}.bevel-up.svelte-1qda04h {border:2px outset #fff;background:var(--cj-bg);padding:2px;}.bevel-down.svelte-1qda04h {border:2px inset #fff;background:#fff;}legend.svelte-1qda04h {font-weight:bold;color:var(--cj-text);padding:0 4px;}.control-panel.svelte-1qda04h {background:rgba(0,0,0,0.05);}.input-row.svelte-1qda04h {display:flex;align-items:center;gap:10px;margin-bottom:10px;}label.svelte-1qda04h {font-weight:bold;font-size:11px;white-space:nowrap;}.synth-desc.svelte-1qda04h {font-size:11px;margin-bottom:15px;color:var(--cj-dim);text-align:center;border:1px dotted var(--cj-dim);padding:4px;}\n    \n    /* BUTTONS */.win95-btn.svelte-1qda04h {background:var(--cj-bg);color:var(--cj-text);border:2px outset #fff;border-right-color:#000;border-bottom-color:#000;font-family:'Courier New', monospace;font-weight:900;cursor:pointer;padding:6px 12px;text-transform:uppercase;font-size:12px;}.win95-btn.svelte-1qda04h:active {border-style:inset;padding-top:7px;padding-left:13px;}.win95-btn.primary.svelte-1qda04h {width:100%;padding:10px;font-size:14px;border:2px outset #fff;border-right-color:#000;border-bottom-color:#000;}.win95-btn.small.svelte-1qda04h {padding:2px 6px;min-width:20px;font-size:12px;line-height:1;}.win95-btn.full-width.svelte-1qda04h {width:100%;margin-top:4px;}.win95-btn.dashed-btn.svelte-1qda04h {border:2px dashed var(--cj-dim);background:transparent;color:var(--cj-dim);width:100%;padding:10px;}.win95-btn.dashed-btn.svelte-1qda04h:hover {border-style:solid;color:var(--cj-text);background:rgba(255,255,255,0.2);}\n\n    /* DRIVE LIST */.drive-section-header.svelte-1qda04h {font-size:11px;font-weight:900;color:var(--cj-dim);border-bottom:2px solid var(--cj-dim);margin-bottom:5px;}.drive-list.svelte-1qda04h {display:flex;flex-direction:column;gap:10px;}.drive-header.svelte-1qda04h {display:flex;justify-content:space-between;align-items:center;background:#000080; /* Win95 Title Bar Blue */color:#fff;padding:4px 6px;cursor:pointer;}.drive-title-row.svelte-1qda04h {display:flex;align-items:center;gap:8px;flex:1;overflow:hidden;}.drive-icon.svelte-1qda04h {font-size:12px;}.drive-id-badge.svelte-1qda04h {font-size:11px;font-weight:bold;white-space:nowrap;}.drive-name-input.svelte-1qda04h {background:transparent;border:none;font-weight:bold;font-family:inherit;font-size:12px;color:#fff;width:100%;}.drive-name-input.svelte-1qda04h:focus {background:#fff;color:#000;outline:none;}.drive-name-input.svelte-1qda04h::placeholder {color:#ccc;}.drive-controls.svelte-1qda04h {display:flex;gap:4px;}.drive-body.svelte-1qda04h {padding:10px;background:var(--cj-bg);border:1px solid var(--cj-dim);border-top:none;}.memory-indicator.svelte-1qda04h {display:flex;align-items:center;gap:6px;margin-bottom:8px;font-size:10px;font-weight:bold;border-bottom:1px solid var(--cj-dim);padding-bottom:4px;}.led.svelte-1qda04h {width:8px;height:8px;border-radius:50%;border:1px solid #808080;background:#004400;}.led.on.svelte-1qda04h {background:#00FF00;box-shadow:0 0 4px #00FF00;}.mem-text.svelte-1qda04h {color:var(--cj-dim);}\n\n    /* LIBRARY STYLES */.library-section.svelte-1qda04h {margin-top:20px;border-top:2px groove #fff;padding-top:10px;}.library-toggle.svelte-1qda04h {width:100%;text-align:left;}.library-container.svelte-1qda04h {margin-top:5px;padding:5px;height:200px;overflow-y:auto;background:#fff;color:#000;}.library-header.svelte-1qda04h {display:flex;justify-content:space-between;align-items:center;font-size:10px;font-weight:bold;border-bottom:1px solid #ccc;padding-bottom:4px;margin-bottom:4px;color:#555;}.refresh-btn.svelte-1qda04h {background:none;border:none;cursor:pointer;font-weight:bold;}.lib-item.svelte-1qda04h {display:flex;align-items:center;padding:4px;border-bottom:1px dotted #ccc;font-size:12px;}.lib-item.svelte-1qda04h:hover {background:#eee;}.lib-icon.svelte-1qda04h {margin-right:6px;}.lib-name.svelte-1qda04h {flex:1;font-weight:bold;overflow:hidden;white-space:nowrap;text-overflow:ellipsis;}.lib-actions.svelte-1qda04h {display:flex;gap:4px;}.del-btn.svelte-1qda04h {color:red !important;}.empty-lib.svelte-1qda04h {text-align:center;color:#999;padding:20px;font-size:11px;font-style:italic;}"
};
function SynthesizerView($$anchor, $$props) {
  push($$props, true);
  append_styles($$anchor, $$css2);
  let targetTitle = state("");
  let targetQuality = state(proxy(
    $$props.settings.defaultTargetQuality
    // Default from global
  ));
  let libraryDrives = state(proxy([]));
  let isLibraryOpen = state(false);
  const LIBRARY_PATH = "_NARRATIVE_DRIVES.md";
  function addDrive() {
    const id = "d" + Date.now();
    const currentDrives = $$props.drives || [];
    const newDrives = [
      ...currentDrives,
      { id, name: "New Narrative Drive", content: "", expanded: true }
    ];
    $$props.onUpdateDrives(newDrives);
  }
  function removeDrive(index4) {
    if (confirm("Delete this Drive from Active Project?")) {
      const newDrives = [...$$props.drives];
      newDrives.splice(index4, 1);
      $$props.onUpdateDrives(newDrives);
    }
  }
  async function uploadToDrive(index4) {
    const content = await $$props.onGetActiveContent();
    if (!content || content.trim().length === 0) {
      new import_obsidian5.Notice("Active file is empty.");
      return;
    }
    const newDrives = JSON.parse(JSON.stringify($$props.drives));
    newDrives[index4].content = content;
    new import_obsidian5.Notice(`Drive "${newDrives[index4].name}" updated with ${content.length} chars.`);
    $$props.onUpdateDrives(newDrives);
  }
  function toggleExpandDrive(index4) {
    const newDrives = [...$$props.drives];
    newDrives[index4].expanded = !newDrives[index4].expanded;
    $$props.onUpdateDrives(newDrives);
  }
  function handleDriveInput() {
    $$props.onUpdateDrives($$props.drives);
  }
  async function loadLibrary() {
    try {
      const exists = await $$props.app.vault.adapter.exists(LIBRARY_PATH);
      if (!exists) {
        set(libraryDrives, [], true);
        return;
      }
      const content = await $$props.app.vault.adapter.read(LIBRARY_PATH);
      set(libraryDrives, parseLibrary(content), true);
    } catch (e2) {
      console.error("Library Load Error", e2);
      new import_obsidian5.Notice("Failed to load Drive Library.");
    }
  }
  async function saveLibrary() {
    try {
      const content = serializeLibrary(get(libraryDrives));
      await $$props.app.vault.adapter.write(LIBRARY_PATH, content);
      new import_obsidian5.Notice("Library Saved.");
    } catch (e2) {
      console.error("Library Save Error", e2);
      new import_obsidian5.Notice("Failed to save Drive Library.");
    }
  }
  function parseLibrary(text2) {
    const lines = text2.split("\n");
    const drives = [];
    let currentDrive = null;
    let contentBuffer = [];
    for (const line of lines) {
      if (line.startsWith("## DRIVE:")) {
        if (currentDrive) {
          currentDrive.content = contentBuffer.join("\n").trim();
          drives.push(currentDrive);
        }
        const name = line.replace("## DRIVE:", "").trim();
        currentDrive = {
          id: "lib_" + Date.now() + Math.random(),
          name,
          expanded: false
        };
        contentBuffer = [];
      } else if (currentDrive) {
        contentBuffer.push(line);
      }
    }
    if (currentDrive) {
      currentDrive.content = contentBuffer.join("\n").trim();
      drives.push(currentDrive);
    }
    return drives;
  }
  function serializeLibrary(libDrives) {
    return libDrives.map((d2) => `## DRIVE: ${d2.name}
${d2.content}
`).join("\n");
  }
  async function saveToLibrary(drive) {
    await loadLibrary();
    const existing = get(libraryDrives).find((d2) => d2.name === drive.name);
    if (existing) {
      if (!confirm(`Overwrite existing library drive "${drive.name}"?`))
        return;
      existing.content = drive.content;
    } else {
      get(libraryDrives).push({ ...drive, id: "lib_" + Date.now() });
    }
    await saveLibrary();
  }
  async function mountFromLibrary(libDrive) {
    const id = "d" + Date.now();
    const newDrives = [...$$props.drives, { ...libDrive, id, expanded: true }];
    $$props.onUpdateDrives(newDrives);
    new import_obsidian5.Notice(`Mounted "${libDrive.name}" to Active Project.`);
  }
  async function deleteFromLibrary(index4) {
    if (!confirm("Permanently delete this drive from the Library File?"))
      return;
    get(libraryDrives).splice(index4, 1);
    set(
      libraryDrives,
      // Trigger update
      get(libraryDrives),
      true
    );
    await saveLibrary();
  }
  function toggleLibrary() {
    set(isLibraryOpen, !get(isLibraryOpen));
    if (get(isLibraryOpen))
      loadLibrary();
  }
  var div = root2();
  var fieldset = child(div);
  var div_1 = sibling(child(fieldset), 2);
  var input = sibling(child(div_1), 2);
  remove_input_defaults(input);
  reset(div_1);
  var div_2 = sibling(div_1, 2);
  var label = child(div_2);
  var text_1 = child(label);
  reset(label);
  var input_1 = sibling(label, 2);
  remove_input_defaults(input_1);
  reset(div_2);
  var p5 = sibling(div_2, 2);
  var text_2 = sibling(child(p5), 3);
  reset(p5);
  var button = sibling(p5, 2);
  button.__click = () => $$props.onRunSynthesis(get(targetTitle), get(targetQuality));
  reset(fieldset);
  var div_3 = sibling(fieldset, 4);
  var node = child(div_3);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment = comment();
      var node_1 = first_child(fragment);
      each(node_1, 27, () => $$props.drives, (drive) => drive.id, ($$anchor3, drive, i3) => {
        var div_4 = root_22();
        var div_5 = child(div_4);
        div_5.__click = () => toggleExpandDrive(get(i3));
        var div_6 = child(div_5);
        var span = sibling(child(div_6), 2);
        var text_3 = child(span);
        reset(span);
        var input_2 = sibling(span, 2);
        remove_input_defaults(input_2);
        input_2.__input = handleDriveInput;
        input_2.__click = (e2) => e2.stopPropagation();
        reset(div_6);
        var div_7 = sibling(div_6, 2);
        var button_1 = child(div_7);
        button_1.__click = (e2) => {
          e2.stopPropagation();
          saveToLibrary(get(drive));
        };
        var button_2 = sibling(button_1, 2);
        button_2.__click = (e2) => {
          e2.stopPropagation();
          removeDrive(get(i3));
        };
        reset(div_7);
        reset(div_5);
        var node_2 = sibling(div_5, 2);
        {
          var consequent = ($$anchor4) => {
            var div_8 = root_32();
            var div_9 = child(div_8);
            var span_1 = child(div_9);
            var span_2 = sibling(span_1, 2);
            var text_4 = child(span_2, true);
            reset(span_2);
            reset(div_9);
            var div_10 = sibling(div_9, 2);
            var textarea = child(div_10);
            remove_textarea_child(textarea);
            textarea.__input = handleDriveInput;
            effect(() => bind_value(textarea, () => get(drive).content, ($$value) => get(drive).content = $$value));
            action(textarea, ($$node, $$action_arg) => {
              var _a3;
              return (_a3 = autoResize) == null ? void 0 : _a3($$node, $$action_arg);
            }, () => get(drive).content);
            var button_3 = sibling(textarea, 2);
            button_3.__click = () => uploadToDrive(get(i3));
            reset(div_10);
            reset(div_8);
            template_effect(() => {
              set_class(span_1, 1, `led ${get(drive).content.length > 0 ? "on" : "off"}`, "svelte-1qda04h");
              set_text(text_4, get(drive).content.length > 0 ? `BUFFER: ${get(drive).content.length} BYTES` : "BUFFER EMPTY");
            });
            transition(3, div_8, () => slide);
            append($$anchor4, div_8);
          };
          if_block(node_2, ($$render) => {
            if (get(drive).expanded)
              $$render(consequent);
          });
        }
        reset(div_4);
        template_effect(() => set_text(text_3, `DRIVE ${get(i3) + 1}:`));
        bind_value(input_2, () => get(drive).name, ($$value) => get(drive).name = $$value);
        animation(div_4, () => flip, () => ({ duration: 300 }));
        append($$anchor3, div_4);
      });
      append($$anchor2, fragment);
    };
    if_block(node, ($$render) => {
      if ($$props.drives)
        $$render(consequent_1);
    });
  }
  var button_4 = sibling(node, 2);
  button_4.__click = addDrive;
  reset(div_3);
  var div_11 = sibling(div_3, 2);
  var button_5 = child(div_11);
  button_5.__click = toggleLibrary;
  var text_5 = child(button_5, true);
  reset(button_5);
  var node_3 = sibling(button_5, 2);
  {
    var consequent_3 = ($$anchor2) => {
      var div_12 = root_42();
      var div_13 = child(div_12);
      var button_6 = sibling(child(div_13), 2);
      button_6.__click = loadLibrary;
      reset(div_13);
      var node_4 = sibling(div_13, 2);
      {
        var consequent_2 = ($$anchor3) => {
          var div_14 = root_52();
          append($$anchor3, div_14);
        };
        var alternate = ($$anchor3) => {
          var fragment_1 = comment();
          var node_5 = first_child(fragment_1);
          each(node_5, 17, () => get(libraryDrives), index, ($$anchor4, libDrive, i3) => {
            var div_15 = root_7();
            var span_3 = sibling(child(div_15), 2);
            var text_6 = child(span_3, true);
            reset(span_3);
            var div_16 = sibling(span_3, 2);
            var button_7 = child(div_16);
            button_7.__click = () => mountFromLibrary(get(libDrive));
            var button_8 = sibling(button_7, 2);
            button_8.__click = () => deleteFromLibrary(i3);
            reset(div_16);
            reset(div_15);
            template_effect(() => set_text(text_6, get(libDrive).name));
            append($$anchor4, div_15);
          });
          append($$anchor3, fragment_1);
        };
        if_block(node_4, ($$render) => {
          if (get(libraryDrives).length === 0)
            $$render(consequent_2);
          else
            $$render(alternate, false);
        });
      }
      reset(div_12);
      transition(3, div_12, () => slide);
      append($$anchor2, div_12);
    };
    if_block(node_3, ($$render) => {
      if (get(isLibraryOpen))
        $$render(consequent_3);
    });
  }
  reset(div_11);
  reset(div);
  template_effect(() => {
    var _a3, _b3, _c2;
    set_text(text_1, `TARGET QUALITY: ${(_a3 = get(targetQuality)) != null ? _a3 : ""}`);
    set_text(text_2, ` ${(_c2 = ((_b3 = $$props.drives) == null ? void 0 : _b3.length) || 0) != null ? _c2 : ""} Drives Mounted.`);
    set_text(text_5, get(isLibraryOpen) ? "\u25BC CLOSE DRIVE LIBRARY" : "\u25BA OPEN DRIVE LIBRARY");
  });
  bind_value(input, () => get(targetTitle), ($$value) => set(targetTitle, $$value));
  bind_value(input_1, () => get(targetQuality), ($$value) => set(targetQuality, $$value));
  append($$anchor, div);
  pop();
}
delegate(["click", "input"]);

// Glossary.ts
var IDEAL_ARCS = {
  "truby": {
    label: "7-Act Structure (Truby)",
    points: [10, 30, 45, 60, 90, 20, 10]
  },
  "hero": {
    label: "Hero's Journey (Campbell)",
    points: [10, 5, 15, 30, 50, 40, 85, 30, 60, 95, 10]
  },
  "cat": {
    label: "Save the Cat (Snyder)",
    points: [0, 40, 20, 50, 70, -20, -10, 90, 10]
  },
  "fichtean": {
    label: "Fichtean Curve",
    points: [10, 30, 20, 50, 40, 70, 60, 90, 100, 10]
  },
  "kishotenketsu": {
    label: "Kish\u014Dtenketsu (4-Act)",
    points: [0, 30, 30, 80, 80, 10]
  },
  "harmon": {
    label: "Harmon's Circle",
    points: [0, 20, 40, 50, 60, 80, 50, 10]
  }
};

// CriticDisplay.svelte
var root_1 = from_html(`<div class="score-divider-horizontal svelte-1wfho06"></div>`);
var root_23 = from_html(`<div class="tooltip bottom svelte-1wfho06"> </div>`);
var root_33 = from_html(`<div class="sub-divider svelte-1wfho06"></div>`);
var root_43 = from_html(`<div class="tooltip bottom svelte-1wfho06"> </div>`);
var root_53 = from_html(`<div class="sub-divider svelte-1wfho06"></div>`);
var root_62 = from_html(`<div class="tooltip bottom svelte-1wfho06"> </div>`);
var root_72 = from_html(`<div class="warning-box warning-stripe svelte-1wfho06"><span class="warning-icon">\u26A0</span> <span class="warning-text"> </span></div>`);
var root_10 = from_html(`<div class="ascii-bar"> </div>`);
var root_11 = from_html(`<div class="slider-track svelte-1wfho06"><div class="slider-fill svelte-1wfho06"></div></div>`);
var root_9 = from_html(`<div class="slider-item svelte-1wfho06"><div class="slider-text-row svelte-1wfho06"><span class="s-label"> </span> <span class="s-val"> </span></div> <!></div>`);
var root_8 = from_html(`<div class="slider-group svelte-1wfho06"><div class="slider-label svelte-1wfho06">PROTAGONIST SCALE</div> <!></div>`);
var root_13 = from_html(`<span class="mod-score svelte-1wfho06"> </span>`);
var root_14 = from_html(`<div class="diverging-bar-container svelte-1wfho06"><div class="center-line svelte-1wfho06"></div> <div></div></div> <span> </span>`, 1);
var root_12 = from_html(`<div class="module-item svelte-1wfho06"><span class="mod-label svelte-1wfho06"> </span> <!></div>`);
var root_18 = from_html(`<div class="metric-bar-container diverging-bar-container svelte-1wfho06"><div class="center-line svelte-1wfho06"></div> <div></div></div>`);
var root_17 = from_html(`<div class="metric-card svelte-1wfho06"><div class="metric-top svelte-1wfho06"><span class="metric-name svelte-1wfho06"> </span> <span> </span></div> <!> <div class="metric-diagnosis svelte-1wfho06"><span class="diag-label svelte-1wfho06">DIAGNOSIS:</span> <span class="diag-text svelte-1wfho06"> </span></div></div>`);
var root_16 = from_html(`<div class="detail-category svelte-1wfho06"><div class="cat-header svelte-1wfho06"><span class="cat-name"> </span> <span> </span></div> <div class="cat-items svelte-1wfho06"></div></div>`);
var root_15 = from_html(`<div class="section-header svelte-1wfho06">FORENSIC REPORT</div> <div class="details-grid bevel-down svelte-1wfho06"></div>`, 1);
var root_20 = from_html(`<option> </option>`);
var root_19 = from_html(`<select class="retro-select svelte-1wfho06"></select>`);
var root_21 = from_html(`<pre style="font-size:10px; line-height:10px; color:var(--cj-text); overflow-x:auto;"> </pre>`);
var root_232 = from_html(`<div class="bar-col tooltip-container svelte-1wfho06"><div></div> <div class="tooltip chart-tooltip svelte-1wfho06"><strong> </strong><br/> <br/> <span style="font-size:0.8em; opacity:0.8"> </span></div></div>`);
var root_222 = from_html(`<div class="chart-area zero-center svelte-1wfho06"><div class="chart-center-line svelte-1wfho06"></div> <svg class="chart-overlay svelte-1wfho06" preserveAspectRatio="none" viewBox="0 0 100 100"><path fill="none" stroke="#000080" stroke-width="0.5" stroke-dasharray="2,1" opacity="0.6"></path></svg> <!></div>`);
var root_25 = from_html(`<div><div class="node-header svelte-1wfho06"><span class="node-type svelte-1wfho06"> </span> <span class="node-title"> </span> <span> </span></div> <div class="node-desc svelte-1wfho06"> </div> <div class="node-chars svelte-1wfho06"> </div></div>`);
var root_27 = from_html(`<div class="structure-item"><div class="square-bullet">\u25A0</div> <div class="beat-text"> </div></div>`);
var root_29 = from_html(`<div class="raw-box svelte-1wfho06"><pre> </pre></div>`);
var root_28 = from_html(`<button class="toggle-btn svelte-1wfho06"> </button> <!>`, 1);
var root3 = from_html(`<div class="critic-display svelte-1wfho06"><div><div class="main-score-row svelte-1wfho06"><div class="score-block main svelte-1wfho06"><div class="score-title svelte-1wfho06">OVERALL SCORE</div> <div> </div> <div> </div></div></div> <!> <div class="sub-score-row svelte-1wfho06"><div class="sub-score-block tooltip-container svelte-1wfho06"><div class="sub-title svelte-1wfho06">COMMERCIAL</div> <div class="sub-val svelte-1wfho06"> </div> <!></div> <!> <div class="sub-score-block tooltip-container svelte-1wfho06"><div class="sub-title svelte-1wfho06">LITERARY</div> <div class="sub-val svelte-1wfho06"> </div> <!></div> <!> <div class="sub-score-block tooltip-container svelte-1wfho06"><div class="sub-title svelte-1wfho06">COHESION</div> <div class="sub-val svelte-1wfho06"> </div> <!></div></div> <!> <div class="log-section svelte-1wfho06" style="margin-top: 10px;"><span class="log-label svelte-1wfho06">LOGLINE:</span> <span class="log-text-blue"> </span></div></div> <div class="section-header svelte-1wfho06">SANDERSON ENGINE METRICS</div> <div class="modules-grid bevel-down svelte-1wfho06"><!> <div class="divider-line svelte-1wfho06"></div> <!></div> <!> <div class="section-header svelte-1wfho06"><span>NARRATIVE TENSION ARC</span> <!></div> <div class="chart-box bevel-down svelte-1wfho06"><!></div> <div class="section-header svelte-1wfho06">UNIVERSAL OUTLINE</div> <div class="structure-box bevel-down svelte-1wfho06"><!></div> <!> <button class="action-btn secondary"> </button></div>`);
var $$css3 = {
  hash: "svelte-1wfho06",
  code: `.critic-display.svelte-1wfho06 {display:flex;flex-direction:column;gap:15px;font-family:'Courier New', monospace;color:#000;font-weight:bold;}.bevel-down.svelte-1wfho06 {border:2px solid #808080;border-bottom-color:#fff;border-right-color:#fff;background:#c0c0c0;padding:10px;}.no-border.svelte-1wfho06 {border:none;background:transparent;padding:0;}
    
    /* SCORES */.score-container.svelte-1wfho06 {background:#d4d4d4;padding-bottom:25px;position:relative;z-index:100; /* Ensure tooltips are above following sections */}
    
    /* NEW LAYOUT */.main-score-row.svelte-1wfho06 {display:flex;justify-content:center;padding:15px 0;}.score-block.main.svelte-1wfho06 {display:flex;flex-direction:column;align-items:center;}.score-title.svelte-1wfho06 {font-size:14px;color:#555;font-weight:900;letter-spacing:2px;margin-bottom:5px;}.score-main.svelte-1wfho06 {font-size:64px;font-weight:900;line-height:0.9;text-shadow:2px 2px 0px rgba(255,255,255,0.5);}.score-verdict.svelte-1wfho06 {font-size:16px;font-weight:900;margin-top:5px;text-shadow:1px 1px 0px #000;letter-spacing:3px;}.score-divider-horizontal.svelte-1wfho06 {height:2px;background:#808080;width:80%;margin:10px auto;}.sub-score-row.svelte-1wfho06 {position:relative;z-index:101; /* Ensure sub-scores are even higher */display:flex;justify-content:space-around;align-items:center;padding-top:5px;}.sub-score-block.svelte-1wfho06 {text-align:center;flex:1;position:relative;cursor:help;} /* Added relative/cursor */.sub-title.svelte-1wfho06 {font-size:10px;font-weight:bold;color:#555;margin-bottom:2px;}.sub-val.svelte-1wfho06 {font-size:18px;font-weight:900;}.sub-divider.svelte-1wfho06 {width:1px;height:20px;background:#999;}

    /* TOOLTIPS */.tooltip-container.svelte-1wfho06 {position:relative;overflow:visible;}.tooltip.svelte-1wfho06 {visibility:hidden;opacity:0;background-color:#FFFFE0;color:#000;text-align:center;border:2px solid #000;padding:5px 8px;position:absolute;z-index:10000; /* FORCE TOP LAYER */font-size:11px;width:140px;box-shadow:4px 4px 0px rgba(0,0,0,0.2);transition:opacity 0.2s;pointer-events:none;}.tooltip.bottom.svelte-1wfho06 {top:100%;left:50%;transform:translateX(-50%);margin-top:8px;}

    /* Standard tooltip arrow (CSS triangle) */.tooltip.bottom.svelte-1wfho06::after {content:"";position:absolute;bottom:100%;left:50%;margin-left:-5px;border-width:5px;border-style:solid;border-color:transparent transparent #000 transparent;}.tooltip-container.svelte-1wfho06:hover .tooltip:where(.svelte-1wfho06) {visibility:visible;opacity:1;}

    /* ANIMATIONS */.masterpiece.svelte-1wfho06 {color:var(--cj-grade-masterpiece) !important; animation: god-mode 1.5s infinite alternate cubic-bezier(0.45, 0.05, 0.55, 0.95);text-shadow:0 0 10px var(--cj-grade-masterpiece), 0 0 20px var(--cj-grade-masterpiece);z-index:5;position:relative;}.glow-bar.svelte-1wfho06 {background-color:var(--cj-grade-masterpiece) !important;box-shadow:0 0 10px var(--cj-grade-masterpiece), 0 0 15px var(--cj-grade-masterpiece); animation: pulse-bar 0.8s infinite alternate;}

    /* SANDERSON METRICS (Updated for Diverging Bars) */.modules-grid.svelte-1wfho06 {padding:10px;}.module-item.svelte-1wfho06 {display:flex;align-items:center;gap:8px;font-size:10px;margin-bottom:8px;}.mod-label.svelte-1wfho06 {width:110px;text-align:right;color:#444;font-weight:900;}.diverging-bar-container.svelte-1wfho06 {flex:1;height:16px;background:#ddd;border:2px solid #808080;position:relative;overflow:hidden;}.center-line.svelte-1wfho06 {position:absolute;left:50%;top:0;bottom:0;width:2px;background:#555;z-index:2;opacity:0.5;}.fill.svelte-1wfho06 {height:100%;transition:width 0.5s ease;position:absolute;z-index:1;}.mod-score.svelte-1wfho06 {font-weight:900;width:35px;text-align:center;font-size:12px;text-shadow:1px 1px 0 #fff;}

    /* NEW SLIDER STYLES */.slider-group.svelte-1wfho06 {padding:0 0 10px 0;}.slider-label.svelte-1wfho06 {font-size:11px;font-weight:900;color:#000080;border-bottom:1px dashed #888;margin-bottom:6px;}.slider-item.svelte-1wfho06 {margin-bottom:6px;}.slider-text-row.svelte-1wfho06 {display:flex;justify-content:space-between;font-size:10px;font-weight:bold;margin-bottom:2px;}.slider-track.svelte-1wfho06 {height:10px;background:#fff;border:1px inset #fff;border-top-color:#888;border-left-color:#888;}.slider-fill.svelte-1wfho06 {height:100%;background:#008080; /* Teal for sliders */}.divider-line.svelte-1wfho06 {height:1px;background:#808080;margin:10px 0;}

    /* DETAILED METRICS (Updated) */.details-grid.svelte-1wfho06 {display:flex;flex-direction:column;gap:15px;background:#dcdcdc;padding:12px;}.detail-category.svelte-1wfho06 {border:2px groove #fff;background:#e0e0e0;padding:8px;}.cat-header.svelte-1wfho06 {display:flex;justify-content:space-between;font-weight:900;font-size:12px;color:#000080;margin-bottom:8px;border-bottom:2px dotted #808080;padding-bottom:4px;}.cat-items.svelte-1wfho06 {display:flex;flex-direction:column;gap:8px;}.metric-card.svelte-1wfho06 {background:#f0f0f0;border:2px solid #aaa;padding:6px;}.metric-top.svelte-1wfho06 {display:flex;justify-content:space-between;font-size:11px;margin-bottom:4px;}.metric-name.svelte-1wfho06 {font-weight:bold;color:#222;}.metric-val.svelte-1wfho06 {font-weight:900;}.metric-bar-container.svelte-1wfho06 {height:8px;background:#fff;border:1px solid #888;margin-bottom:6px;}.metric-bar.svelte-1wfho06 {height:100%;transition:width 0.5s ease;position:absolute;top:0;bottom:0;}.metric-diagnosis.svelte-1wfho06 {font-size:10px;line-height:1.3;color:#333;border-top:1px dashed #ccc;padding-top:4px;}.diag-label.svelte-1wfho06 {font-weight:900;color:#800000;margin-right:4px;}.diag-text.svelte-1wfho06 {font-style:italic;}

    /* CHART AREA (Diverging) */.chart-box.svelte-1wfho06 {padding:10px;background:#d4d4d4;position:relative;z-index:50; /* Lower than score but above normal flow if needed */}.chart-area.svelte-1wfho06 {height:100px;display:flex;align-items:stretch;gap:1px;padding-bottom:4px;border-bottom:2px solid #808080;position:relative;}.chart-center-line.svelte-1wfho06 {position:absolute;top:50%;left:0;right:0;height:1px;background:#555;z-index:0;}.chart-overlay.svelte-1wfho06 {position:absolute;top:0;left:0;width:100%;height:100%;z-index:10;pointer-events:none;}.chart-axis.svelte-1wfho06 {display:flex;justify-content:space-between;font-size:9px;color:#555;margin-top:2px;align-items:center;}.retro-select.svelte-1wfho06 {font-family:inherit;font-size:10px;background:#fff;border:1px solid #808080;margin-left:auto;}.legend-box.svelte-1wfho06 {width:10px;height:10px;display:inline-block;}.bar-col.svelte-1wfho06 {display:flex;flex-direction:column;justify-content:center;align-items:center;min-width:4px;position:relative;transition:opacity 0.2s;height:100%;}.bar-col.svelte-1wfho06:hover {opacity:0.8;}.bar-fill.svelte-1wfho06 {width:100%;transition:height 0.5s ease;border:1px solid rgba(0,0,0,0.2);}.chart-tooltip.svelte-1wfho06 {bottom:100%;margin-bottom:5px;white-space:nowrap;pointer-events:none;}

    /* STRUCTURE NODES */.structure-box.svelte-1wfho06 {padding:12px;background:#d4d4d4;}.structure-node.svelte-1wfho06 {background:#e0e0e0;border:2px inset #fff;padding:8px;margin-bottom:8px;}.structure-node.promise.svelte-1wfho06 {border-left:4px solid #000080;}.structure-node.payoff.svelte-1wfho06 {border-left:4px solid #800000;}.structure-node.progress.svelte-1wfho06 {border-left:4px solid #008000;}.node-header.svelte-1wfho06 {display:flex;justify-content:space-between;font-size:10px;font-weight:900;margin-bottom:4px;border-bottom:1px dashed #999;}.node-type.svelte-1wfho06 {color:#555;}.node-tension.svelte-1wfho06 {color:#BF40BF;}.node-desc.svelte-1wfho06 {font-size:11px;margin-bottom:4px;}.node-chars.svelte-1wfho06 {font-size:9px;color:#666;font-style:italic;}

    /* MISC */.section-header.svelte-1wfho06 {display:flex;align-items:center;gap:10px;font-weight:900;font-size:12px;color:#000;text-transform:uppercase;margin-top:10px;margin-bottom:5px;}.section-header.svelte-1wfho06::after {content:"";flex:1;height:2px;background:#808080;}.warning-box.svelte-1wfho06 {background:#FFFF00;border:2px solid #000;padding:8px;font-size:11px;font-weight:900;display:flex;gap:8px;align-items:flex-start;margin-bottom:10px;}.log-section.svelte-1wfho06 {width:100%;text-align:left;font-size:12px;line-height:1.4;}.log-label.svelte-1wfho06 {color:#000080;font-weight:900;}.log-text.svelte-1wfho06 {color:#222;font-style:italic;font-weight:bold;}.toggle-btn.svelte-1wfho06 {background:none;border:none;color:#444;cursor:pointer;font-size:11px;padding:0;text-align:left;font-weight:bold;}.raw-box.svelte-1wfho06 {background:#000;color:#0f0;padding:10px;overflow-x:auto;font-size:11px;max-height:200px;font-weight:bold;}`
};
function CriticDisplay($$anchor, $$props) {
  push($$props, true);
  append_styles($$anchor, $$css3);
  let isMsDos = prop($$props, "isMsDos", 3, false);
  let showRaw = state(false);
  function getBarColor(val) {
    if (isMsDos())
      return $$props.settings.msDosColor || "#00FF00";
    if (val >= 75)
      return $$props.settings.gradingColors.masterpiece;
    if (val >= 50)
      return $$props.settings.gradingColors.excellent;
    if (val > 0)
      return $$props.settings.gradingColors.good;
    if (val === 0)
      return $$props.settings.gradingColors.average;
    if (val >= -25)
      return $$props.settings.gradingColors.poor;
    return $$props.settings.gradingColors.critical;
  }
  function isMasterpieceEffect(val) {
    if (isMsDos())
      return false;
    return getBarColor(val) === $$props.settings.gradingColors.masterpiece;
  }
  function isCritical(val) {
    if (isMsDos())
      return false;
    return val <= -50;
  }
  function getContainerClass(val) {
    if (isMsDos())
      return "score-container no-border";
    if (isMasterpieceEffect(val))
      return "score-container bevel-down masterpiece-border pattern-mesh-dark";
    if (isCritical(val))
      return "score-container bevel-down critical-crack pattern-mesh-critical";
    return "score-container bevel-down";
  }
  function getBarMetrics(val) {
    const cap = 100;
    const clamped = Math.max(-cap, Math.min(cap, val));
    const width = Math.abs(clamped) / cap * 50;
    const isNegative = val < 0;
    return { width, isNegative };
  }
  function getSliderMetrics(val) {
    const clamped = Math.max(0, Math.min(100, val));
    return clamped;
  }
  function formatScoreDisplay(val) {
    if (typeof val !== "number")
      return "0";
    return (val > 0 ? "+" : "") + val.toFixed(0);
  }
  function formatUnsignedScore(val) {
    if (typeof val !== "number")
      return "0";
    return val.toFixed(0);
  }
  function getVerdict(val) {
    if (val >= 90)
      return "GOD TIER";
    if (val >= 75)
      return "MASTERPIECE";
    if (val >= 50)
      return "EXCELLENT";
    if (val > 0)
      return "GOOD";
    if (val === 0)
      return "COMPETENT";
    if (val >= -25)
      return "FLAWED";
    if (val >= -50)
      return "BROKEN";
    return "CRITICAL FAILURE";
  }
  let structure = user_derived(() => $$props.data.structure_map || []);
  let isUniversalOutline = user_derived(() => get(structure).length > 0 && typeof get(structure)[0] !== "string");
  let warning = user_derived(() => $$props.data.content_warning || "No specific warnings detected.");
  let details = user_derived(() => $$props.data.detailed_metrics || {});
  let hasDetails = user_derived(() => Object.keys(get(details)).length > 0);
  let sanderson = user_derived(() => $$props.data.sanderson_metrics || { promise_payoff: 0, laws_of_magic: 0, character_agency: 0 });
  let averageScore = user_derived(() => {
    const c2 = $$props.data.commercial_score || 0;
    const n3 = $$props.data.niche_score || 0;
    const co = $$props.data.cohesion_score || 0;
    return Math.round((c2 + n3 + co) / 3);
  });
  let selectedArc = state("truby");
  let chartData = user_derived(() => {
    if (!get(isUniversalOutline)) {
      const legacyArc = $$props.data.tension_arc || [0, 10, 5, 20, 15, 30];
      return legacyArc.map((val, i3) => ({
        tension: val,
        widthPerc: 100 / legacyArc.length,
        title: `Beat ${i3 + 1}`,
        desc: "Legacy Data"
      }));
    }
    const nodes = get(structure);
    const totalChars = nodes.reduce(
      (acc, node) => {
        var _a3;
        return acc + (((_a3 = node.description) === null || _a3 === void 0 ? void 0 : _a3.length) || 50);
      },
      0
    );
    return nodes.map((node) => {
      var _a3;
      const len = ((_a3 = node.description) === null || _a3 === void 0 ? void 0 : _a3.length) || 50;
      let rawPerc = len / totalChars * 100;
      return {
        tension: node.tension,
        widthPerc: rawPerc,
        title: node.title,
        desc: node.description
      };
    });
  });
  let idealPathD = user_derived(() => {
    if (!get(chartData) || get(chartData).length === 0)
      return "";
    const idealPoints = IDEAL_ARCS[get(selectedArc)].points;
    const numBeats = get(chartData).length;
    let path = "";
    let currentX = 0;
    get(chartData).forEach((beat, i3) => {
      const centerX = currentX + beat.widthPerc / 2;
      const progress = i3 / (numBeats - 1 || 1);
      const idealIndex = progress * (idealPoints.length - 1);
      const lowerIdx = Math.floor(idealIndex);
      const upperIdx = Math.ceil(idealIndex);
      const weight = idealIndex - lowerIdx;
      const val1 = idealPoints[lowerIdx];
      const val2 = idealPoints[upperIdx];
      const idealVal = val1 + (val2 - val1) * weight;
      const yPos = 50 - idealVal / 2;
      if (i3 === 0)
        path += `M ${centerX} ${yPos}`;
      else
        path += ` L ${centerX} ${yPos}`;
      currentX += beat.widthPerc;
    });
    return path;
  });
  function generateAsciiChart(data) {
    const rows = 10;
    const cols = 40;
    let grid = Array(rows).fill(null).map(() => Array(cols).fill(" "));
    const mid = Math.floor(rows / 2);
    for (let c2 = 0; c2 < cols; c2++)
      grid[mid][c2] = "-";
    data.forEach((beat, i3) => {
      const x = Math.floor(i3 / data.length * cols);
      const norm = Math.max(-100, Math.min(100, beat.tension));
      const y = Math.floor(mid - norm / 100 * (rows / 2));
      const safeY = Math.max(0, Math.min(rows - 1, y));
      grid[safeY][x] = "*";
      if (safeY < mid) {
        for (let k2 = safeY + 1; k2 < mid; k2++)
          grid[k2][x] = "|";
      } else {
        for (let k2 = mid + 1; k2 < safeY; k2++)
          grid[k2][x] = "|";
      }
    });
    return grid.map((r2) => r2.join("")).join("\n");
  }
  var div = root3();
  var div_1 = child(div);
  var div_2 = child(div_1);
  var div_3 = child(div_2);
  var div_4 = child(div_3);
  var div_5 = sibling(div_4, 2);
  var text2 = child(div_5, true);
  reset(div_5);
  var div_6 = sibling(div_5, 2);
  var text_1 = child(div_6, true);
  reset(div_6);
  reset(div_3);
  reset(div_2);
  var node_1 = sibling(div_2, 2);
  {
    var consequent = ($$anchor2) => {
      var div_7 = root_1();
      append($$anchor2, div_7);
    };
    if_block(node_1, ($$render) => {
      if (!isMsDos())
        $$render(consequent);
    });
  }
  var div_8 = sibling(node_1, 2);
  var div_9 = child(div_8);
  var div_10 = sibling(child(div_9), 2);
  var text_2 = child(div_10, true);
  reset(div_10);
  var node_2 = sibling(div_10, 2);
  {
    var consequent_1 = ($$anchor2) => {
      var div_11 = root_23();
      var text_3 = child(div_11, true);
      reset(div_11);
      template_effect(() => set_text(text_3, $$props.data.commercial_reason));
      append($$anchor2, div_11);
    };
    if_block(node_2, ($$render) => {
      if (!isMsDos())
        $$render(consequent_1);
    });
  }
  reset(div_9);
  var node_3 = sibling(div_9, 2);
  {
    var consequent_2 = ($$anchor2) => {
      var div_12 = root_33();
      append($$anchor2, div_12);
    };
    if_block(node_3, ($$render) => {
      if (!isMsDos())
        $$render(consequent_2);
    });
  }
  var div_13 = sibling(node_3, 2);
  var div_14 = sibling(child(div_13), 2);
  var text_4 = child(div_14, true);
  reset(div_14);
  var node_4 = sibling(div_14, 2);
  {
    var consequent_3 = ($$anchor2) => {
      var div_15 = root_43();
      var text_5 = child(div_15, true);
      reset(div_15);
      template_effect(() => set_text(text_5, $$props.data.niche_reason));
      append($$anchor2, div_15);
    };
    if_block(node_4, ($$render) => {
      if (!isMsDos())
        $$render(consequent_3);
    });
  }
  reset(div_13);
  var node_5 = sibling(div_13, 2);
  {
    var consequent_4 = ($$anchor2) => {
      var div_16 = root_53();
      append($$anchor2, div_16);
    };
    if_block(node_5, ($$render) => {
      if (!isMsDos())
        $$render(consequent_4);
    });
  }
  var div_17 = sibling(node_5, 2);
  var div_18 = sibling(child(div_17), 2);
  var text_6 = child(div_18, true);
  reset(div_18);
  var node_6 = sibling(div_18, 2);
  {
    var consequent_5 = ($$anchor2) => {
      var div_19 = root_62();
      var text_7 = child(div_19, true);
      reset(div_19);
      template_effect(() => set_text(text_7, $$props.data.cohesion_reason));
      append($$anchor2, div_19);
    };
    if_block(node_6, ($$render) => {
      if (!isMsDos())
        $$render(consequent_5);
    });
  }
  reset(div_17);
  reset(div_8);
  var node_7 = sibling(div_8, 2);
  {
    var consequent_6 = ($$anchor2) => {
      var div_20 = root_72();
      var span = sibling(child(div_20), 2);
      var text_8 = child(span, true);
      reset(span);
      reset(div_20);
      template_effect(() => {
        set_style(div_20, `margin-top: 15px; ${isMsDos() ? "background:transparent; color:red; border:1px solid red;" : ""}`);
        set_text(text_8, get(warning));
      });
      append($$anchor2, div_20);
    };
    if_block(node_7, ($$render) => {
      if (get(warning) && get(warning).length > 5 && get(warning) !== "None")
        $$render(consequent_6);
    });
  }
  var div_21 = sibling(node_7, 2);
  var span_1 = sibling(child(div_21), 2);
  var text_9 = child(span_1);
  reset(span_1);
  reset(div_21);
  reset(div_1);
  var div_22 = sibling(div_1, 4);
  var node_8 = child(div_22);
  {
    var consequent_8 = ($$anchor2) => {
      var div_23 = root_8();
      var node_9 = sibling(child(div_23), 2);
      each(
        node_9,
        17,
        () => {
          var _a3, _b3, _c2;
          return [
            { label: "COMPETENCE", val: (_a3 = get(sanderson).competence) != null ? _a3 : 50 },
            {
              label: "PROACTIVITY",
              val: (_b3 = get(sanderson).proactivity) != null ? _b3 : 50
            },
            { label: "LIKABILITY", val: (_c2 = get(sanderson).likability) != null ? _c2 : 50 }
          ];
        },
        index,
        ($$anchor3, s3) => {
          var div_24 = root_9();
          var div_25 = child(div_24);
          var span_2 = child(div_25);
          var text_10 = child(span_2, true);
          reset(span_2);
          var span_3 = sibling(span_2, 2);
          var text_11 = child(span_3);
          reset(span_3);
          reset(div_25);
          var node_10 = sibling(div_25, 2);
          {
            var consequent_7 = ($$anchor4) => {
              var div_26 = root_10();
              var text_12 = child(div_26);
              reset(div_26);
              template_effect(($0) => set_text(text_12, `[${$0 != null ? $0 : ""}]`), [
                () => "|".repeat(Math.round(get(s3).val / 5)).padEnd(20, ".")
              ]);
              append($$anchor4, div_26);
            };
            var alternate = ($$anchor4) => {
              var div_27 = root_11();
              var div_28 = child(div_27);
              reset(div_27);
              template_effect(($0) => set_style(div_28, `width: ${$0 != null ? $0 : ""}%;`), [() => getSliderMetrics(get(s3).val)]);
              append($$anchor4, div_27);
            };
            if_block(node_10, ($$render) => {
              if (isMsDos())
                $$render(consequent_7);
              else
                $$render(alternate, false);
            });
          }
          reset(div_24);
          template_effect(
            ($0) => {
              set_text(text_10, get(s3).label);
              set_text(text_11, `${$0 != null ? $0 : ""}%`);
            },
            [() => formatUnsignedScore(get(s3).val)]
          );
          append($$anchor3, div_24);
        }
      );
      reset(div_23);
      append($$anchor2, div_23);
    };
    if_block(node_8, ($$render) => {
      if (get(sanderson).competence !== void 0)
        $$render(consequent_8);
    });
  }
  var node_11 = sibling(node_8, 4);
  each(
    node_11,
    17,
    () => [
      {
        label: "PROMISE/PAYOFF",
        val: get(sanderson).promise_payoff
      },
      { label: "LAWS OF MAGIC", val: get(sanderson).laws_of_magic },
      { label: "AGENCY", val: get(sanderson).character_agency }
    ],
    index,
    ($$anchor2, m3) => {
      const bar = user_derived(() => getBarMetrics(get(m3).val));
      var div_29 = root_12();
      var span_4 = child(div_29);
      var text_13 = child(span_4, true);
      reset(span_4);
      var node_12 = sibling(span_4, 2);
      {
        var consequent_9 = ($$anchor3) => {
          var span_5 = root_13();
          var text_14 = child(span_5, true);
          reset(span_5);
          template_effect(($0) => set_text(text_14, $0), [() => formatScoreDisplay(get(m3).val)]);
          append($$anchor3, span_5);
        };
        var alternate_1 = ($$anchor3) => {
          var fragment = root_14();
          var div_30 = first_child(fragment);
          var div_31 = sibling(child(div_30), 2);
          reset(div_30);
          var span_6 = sibling(div_30, 2);
          var text_15 = child(span_6, true);
          reset(span_6);
          template_effect(
            ($0, $1, $2, $3, $4) => {
              var _a3;
              set_class(div_31, 1, `fill ${$0 != null ? $0 : ""}`, "svelte-1wfho06");
              set_style(div_31, `
                                width: ${(_a3 = get(bar).width) != null ? _a3 : ""}%;
                                left: ${get(bar).isNegative ? 50 - get(bar).width + "%" : "50%"};
                                background: ${$1 != null ? $1 : ""}
                             `);
              set_class(span_6, 1, `mod-score ${$2 != null ? $2 : ""}`, "svelte-1wfho06");
              set_style(span_6, `color: ${$3 != null ? $3 : ""}`);
              set_text(text_15, $4);
            },
            [
              () => isMasterpieceEffect(get(m3).val) ? "glow-bar" : "",
              () => getBarColor(get(m3).val),
              () => isMasterpieceEffect(get(m3).val) ? "masterpiece-text" : "",
              () => isMasterpieceEffect(get(m3).val) ? "" : getBarColor(get(m3).val),
              () => formatScoreDisplay(get(m3).val)
            ]
          );
          append($$anchor3, fragment);
        };
        if_block(node_12, ($$render) => {
          if (isMsDos())
            $$render(consequent_9);
          else
            $$render(alternate_1, false);
        });
      }
      reset(div_29);
      template_effect(() => set_text(text_13, get(m3).label));
      append($$anchor2, div_29);
    }
  );
  reset(div_22);
  var node_13 = sibling(div_22, 2);
  {
    var consequent_11 = ($$anchor2) => {
      var fragment_1 = root_15();
      var div_32 = sibling(first_child(fragment_1), 2);
      each(div_32, 21, () => Object.entries(get(details)), index, ($$anchor3, $$item) => {
        var $$array = user_derived(() => to_array(get($$item), 2));
        let key2 = () => get($$array)[0];
        let cat = () => get($$array)[1];
        var div_33 = root_16();
        var div_34 = child(div_33);
        var span_7 = child(div_34);
        var text_16 = child(span_7, true);
        reset(span_7);
        var span_8 = sibling(span_7, 2);
        var text_17 = child(span_8);
        reset(span_8);
        reset(div_34);
        var div_35 = sibling(div_34, 2);
        each(div_35, 21, () => cat().items, index, ($$anchor4, item) => {
          const bar = user_derived(() => getBarMetrics(get(item).score));
          var div_36 = root_17();
          var div_37 = child(div_36);
          var span_9 = child(div_37);
          var text_18 = child(span_9, true);
          reset(span_9);
          var span_10 = sibling(span_9, 2);
          var text_19 = child(span_10, true);
          reset(span_10);
          reset(div_37);
          var node_14 = sibling(div_37, 2);
          {
            var consequent_10 = ($$anchor5) => {
              var div_38 = root_18();
              var div_39 = sibling(child(div_38), 2);
              reset(div_38);
              template_effect(
                ($0, $1) => {
                  var _a3;
                  set_class(div_39, 1, `metric-bar ${$0 != null ? $0 : ""}`, "svelte-1wfho06");
                  set_style(div_39, `
                                        width: ${(_a3 = get(bar).width) != null ? _a3 : ""}%; 
                                        left: ${get(bar).isNegative ? 50 - get(bar).width + "%" : "50%"};
                                        background: ${$1 != null ? $1 : ""}
                                     `);
                },
                [
                  () => isMasterpieceEffect(get(item).score) ? "glow-bar" : "",
                  () => getBarColor(get(item).score)
                ]
              );
              append($$anchor5, div_38);
            };
            if_block(node_14, ($$render) => {
              if (!isMsDos())
                $$render(consequent_10);
            });
          }
          var div_40 = sibling(node_14, 2);
          var span_11 = sibling(child(div_40), 2);
          var text_20 = child(span_11, true);
          reset(span_11);
          reset(div_40);
          reset(div_36);
          template_effect(
            ($0, $1, $2) => {
              set_text(text_18, get(item).name);
              set_class(span_10, 1, `metric-val ${$0 != null ? $0 : ""}`, "svelte-1wfho06");
              set_style(span_10, `color: ${$1 != null ? $1 : ""}`);
              set_text(text_19, $2);
              set_text(text_20, get(item).reason);
            },
            [
              () => isMasterpieceEffect(get(item).score) ? "masterpiece-text" : "",
              () => isMasterpieceEffect(get(item).score) ? "" : getBarColor(get(item).score),
              () => formatScoreDisplay(get(item).score)
            ]
          );
          append($$anchor4, div_36);
        });
        reset(div_35);
        reset(div_33);
        template_effect(
          ($0, $1, $2, $3) => {
            set_text(text_16, $0);
            set_class(span_8, 1, `cat-score ${$1 != null ? $1 : ""}`);
            set_style(span_8, `color: ${$2 != null ? $2 : ""}`);
            set_text(text_17, `AVG: ${$3 != null ? $3 : ""}`);
          },
          [
            () => key2().toUpperCase(),
            () => isMasterpieceEffect(cat().score) ? "masterpiece-text" : "",
            () => isMasterpieceEffect(cat().score) ? "" : getBarColor(cat().score),
            () => formatScoreDisplay(cat().score)
          ]
        );
        append($$anchor3, div_33);
      });
      reset(div_32);
      append($$anchor2, fragment_1);
    };
    if_block(node_13, ($$render) => {
      if (get(hasDetails))
        $$render(consequent_11);
    });
  }
  var div_41 = sibling(node_13, 2);
  var node_15 = sibling(child(div_41), 2);
  {
    var consequent_12 = ($$anchor2) => {
      var select = root_19();
      each(select, 21, () => Object.entries(IDEAL_ARCS), index, ($$anchor3, $$item) => {
        var $$array_1 = user_derived(() => to_array(get($$item), 2));
        let key2 = () => get($$array_1)[0];
        let arc = () => get($$array_1)[1];
        var option = root_20();
        var text_21 = child(option, true);
        reset(option);
        var option_value = {};
        template_effect(() => {
          var _a3;
          set_text(text_21, arc().label);
          if (option_value !== (option_value = key2())) {
            option.value = (_a3 = option.__value = key2()) != null ? _a3 : "";
          }
        });
        append($$anchor3, option);
      });
      reset(select);
      bind_select_value(select, () => get(selectedArc), ($$value) => set(selectedArc, $$value));
      append($$anchor2, select);
    };
    if_block(node_15, ($$render) => {
      if (!isMsDos())
        $$render(consequent_12);
    });
  }
  reset(div_41);
  var div_42 = sibling(div_41, 2);
  var node_16 = child(div_42);
  {
    var consequent_13 = ($$anchor2) => {
      var pre = root_21();
      var text_22 = child(pre);
      reset(pre);
      template_effect(
        ($0) => set_text(text_22, `${$0 != null ? $0 : ""}
            `),
        [() => generateAsciiChart(get(chartData))]
      );
      append($$anchor2, pre);
    };
    var alternate_2 = ($$anchor2) => {
      var div_43 = root_222();
      var svg = sibling(child(div_43), 2);
      var path_1 = child(svg);
      reset(svg);
      var node_17 = sibling(svg, 2);
      each(node_17, 17, () => get(chartData), index, ($$anchor3, beat, i3) => {
        const bar = user_derived(() => getBarMetrics(get(beat).tension));
        var div_44 = root_232();
        var div_45 = child(div_44);
        var div_46 = sibling(div_45, 2);
        var strong = child(div_46);
        var text_23 = child(strong);
        reset(strong);
        var text_24 = sibling(strong, 2);
        var span_12 = sibling(text_24, 3);
        var text_25 = child(span_12);
        reset(span_12);
        reset(div_46);
        reset(div_44);
        template_effect(
          ($0, $1, $2, $3) => {
            var _a3, _b3, _c2;
            set_style(div_44, `flex-grow: ${(_a3 = get(beat).widthPerc) != null ? _a3 : ""};`);
            set_class(div_45, 1, `bar-fill ${$0 != null ? $0 : ""}`, "svelte-1wfho06");
            set_style(div_45, `
                                height: ${(_b3 = get(bar).width) != null ? _b3 : ""}%;
                                background-color: ${$1 != null ? $1 : ""};
                                position: absolute;
                                bottom: ${get(bar).isNegative ? "auto" : "50%"};
                                top: ${get(bar).isNegative ? "50%" : "auto"};
                                left: 1px; right: 1px;
                             `);
            set_text(text_23, `${i3 + 1}. ${(_c2 = get(beat).title) != null ? _c2 : ""}`);
            set_text(text_24, ` Tension: ${$2 != null ? $2 : ""}`);
            set_text(text_25, `Duration: ${$3 != null ? $3 : ""}%`);
          },
          [
            () => isMasterpieceEffect(get(beat).tension) ? "glow-bar" : "",
            () => getBarColor(get(beat).tension),
            () => formatScoreDisplay(get(beat).tension),
            () => Math.round(get(beat).widthPerc)
          ]
        );
        append($$anchor3, div_44);
      });
      reset(div_43);
      template_effect(() => set_attribute2(path_1, "d", get(idealPathD)));
      append($$anchor2, div_43);
    };
    if_block(node_16, ($$render) => {
      if (isMsDos())
        $$render(consequent_13);
      else
        $$render(alternate_2, false);
    });
  }
  reset(div_42);
  var div_47 = sibling(div_42, 4);
  var node_18 = child(div_47);
  {
    var consequent_14 = ($$anchor2) => {
      var fragment_2 = comment();
      var node_19 = first_child(fragment_2);
      each(node_19, 17, () => get(structure), index, ($$anchor3, node) => {
        var div_48 = root_25();
        var div_49 = child(div_48);
        var span_13 = child(div_49);
        var text_26 = child(span_13, true);
        reset(span_13);
        var span_14 = sibling(span_13, 2);
        var text_27 = child(span_14, true);
        reset(span_14);
        var span_15 = sibling(span_14, 2);
        var text_28 = child(span_15);
        reset(span_15);
        reset(div_49);
        var div_50 = sibling(div_49, 2);
        var text_29 = child(div_50, true);
        reset(div_50);
        var div_51 = sibling(div_50, 2);
        var text_30 = child(div_51);
        reset(div_51);
        reset(div_48);
        template_effect(
          ($0, $1, $2, $3, $4) => {
            var _a3;
            set_class(div_48, 1, `structure-node ${(_a3 = get(node).type) != null ? _a3 : ""}`, "svelte-1wfho06");
            set_text(text_26, $0);
            set_text(text_27, get(node).title);
            set_class(span_15, 1, `node-tension ${$1 != null ? $1 : ""}`, "svelte-1wfho06");
            set_style(span_15, `color: ${$2 != null ? $2 : ""}`);
            set_text(text_28, `\u26A1 ${$3 != null ? $3 : ""}`);
            set_text(text_29, get(node).description);
            set_text(text_30, `ACTORS: ${$4 != null ? $4 : ""}`);
          },
          [
            () => get(node).type.toUpperCase(),
            () => isMasterpieceEffect(get(node).tension) ? "masterpiece-text" : "",
            () => isMasterpieceEffect(get(node).tension) ? "" : "#BF40BF",
            () => formatScoreDisplay(get(node).tension),
            () => get(node).characters.join(", ")
          ]
        );
        append($$anchor3, div_48);
      });
      append($$anchor2, fragment_2);
    };
    var alternate_3 = ($$anchor2) => {
      var fragment_3 = comment();
      var node_20 = first_child(fragment_3);
      each(node_20, 17, () => get(structure), index, ($$anchor3, beat) => {
        var div_52 = root_27();
        var div_53 = sibling(child(div_52), 2);
        var text_31 = child(div_53, true);
        reset(div_53);
        reset(div_52);
        template_effect(() => set_text(text_31, get(beat)));
        append($$anchor3, div_52);
      });
      append($$anchor2, fragment_3);
    };
    if_block(node_18, ($$render) => {
      if (get(isUniversalOutline))
        $$render(consequent_14);
      else
        $$render(alternate_3, false);
    });
  }
  reset(div_47);
  var node_21 = sibling(div_47, 2);
  {
    var consequent_16 = ($$anchor2) => {
      var fragment_4 = root_28();
      var button = first_child(fragment_4);
      button.__click = () => set(showRaw, !get(showRaw));
      var text_32 = child(button, true);
      reset(button);
      var node_22 = sibling(button, 2);
      {
        var consequent_15 = ($$anchor3) => {
          var div_54 = root_29();
          var pre_1 = child(div_54);
          var text_33 = child(pre_1, true);
          reset(pre_1);
          reset(div_54);
          template_effect(() => set_text(text_33, $$props.data.thought_process));
          transition(3, div_54, () => slide);
          append($$anchor3, div_54);
        };
        if_block(node_22, ($$render) => {
          if (get(showRaw))
            $$render(consequent_15);
        });
      }
      template_effect(() => set_text(text_32, get(showRaw) ? "[-] HIDE RAW LOGIC" : "[+] SHOW TRUBY LOGIC"));
      append($$anchor2, fragment_4);
    };
    if_block(node_21, ($$render) => {
      if ($$props.data.thought_process)
        $$render(consequent_16);
    });
  }
  var button_1 = sibling(node_21, 2);
  button_1.__click = function(...$$args) {
    var _a3;
    (_a3 = $$props.onRunMeta) == null ? void 0 : _a3.apply(this, $$args);
  };
  var text_34 = child(button_1, true);
  reset(button_1);
  reset(div);
  template_effect(
    ($0, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15) => {
      var _a3;
      set_class(div_1, 1, $0, "svelte-1wfho06");
      set_style(div_4, `color: ${$1 != null ? $1 : ""}`);
      set_class(
        div_5,
        1,
        `score-main ${$2 != null ? $2 : ""} 
                            ${$3 != null ? $3 : ""}`,
        "svelte-1wfho06"
      );
      set_style(div_5, `color: ${$4 != null ? $4 : ""}`);
      set_text(text2, $5);
      set_class(div_6, 1, `score-verdict ${$6 != null ? $6 : ""} ${$7 != null ? $7 : ""}`, "svelte-1wfho06");
      set_style(div_6, `color: ${$8 != null ? $8 : ""}`);
      set_text(text_1, $9);
      set_style(div_10, `color: ${$10 != null ? $10 : ""}`);
      set_text(text_2, $11);
      set_style(div_14, `color: ${$12 != null ? $12 : ""}`);
      set_text(text_4, $13);
      set_style(div_18, `color: ${$14 != null ? $14 : ""}`);
      set_text(text_6, $15);
      set_style(span_1, isMsDos() ? "color:var(--cj-text); font-style:normal;" : "");
      set_text(text_9, `"${(_a3 = $$props.data.log_line || "Analysis pending...") != null ? _a3 : ""}"`);
      button_1.disabled = $$props.isProcessing;
      set_text(text_34, isMsDos() ? "[ RUN META-ANALYSIS ]" : "RUN DEEP META-ANALYSIS");
    },
    [
      () => getContainerClass(get(averageScore)),
      () => isMsDos() ? "var(--cj-dim)" : isMasterpieceEffect(get(averageScore)) || isCritical(get(averageScore)) ? "#999" : "#555",
      () => isMasterpieceEffect(get(averageScore)) ? "masterpiece-text" : "",
      () => isCritical(get(averageScore)) ? "critical-text" : "",
      () => isMsDos() ? "var(--cj-text)" : isMasterpieceEffect(get(averageScore)) ? "" : isCritical(get(averageScore)) ? "#000" : getBarColor(get(averageScore)),
      () => formatScoreDisplay(get(averageScore)),
      () => isMasterpieceEffect(get(averageScore)) ? "masterpiece-text" : "",
      () => isCritical(get(averageScore)) ? "critical-text" : "",
      () => isMsDos() ? "var(--cj-text)" : isMasterpieceEffect(get(averageScore)) ? "" : isCritical(get(averageScore)) ? "#000" : getBarColor(get(averageScore)),
      () => getVerdict(get(averageScore)),
      () => getBarColor($$props.data.commercial_score),
      () => formatScoreDisplay($$props.data.commercial_score),
      () => getBarColor($$props.data.niche_score),
      () => formatScoreDisplay($$props.data.niche_score),
      () => getBarColor($$props.data.cohesion_score),
      () => formatScoreDisplay($$props.data.cohesion_score)
    ]
  );
  append($$anchor, div);
  pop();
}
delegate(["click"]);

// Win95ProgressBar.svelte
var root4 = from_html(`<div class="win95-loader svelte-9apvmc"><div class="loader-header svelte-9apvmc"><div class="loader-label svelte-9apvmc"> </div> <div class="loader-time svelte-9apvmc"> </div></div> <div class="progress-container bevel-down svelte-9apvmc"><div class="progress-bar-fill svelte-9apvmc"></div></div></div>`);
var $$css4 = {
  hash: "svelte-9apvmc",
  code: ".win95-loader.svelte-9apvmc {padding:15px 0;width:100%;display:flex;flex-direction:column;gap:6px;}.loader-header.svelte-9apvmc {display:flex;justify-content:space-between;align-items:center;width:100%;}.loader-label.svelte-9apvmc {font-family:'Courier New', monospace;font-weight:900; /* CHUNKY */font-size:11px;color:var(--cj-text);text-transform:uppercase;margin-left:2px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;flex:1;\n        animation: svelte-9apvmc-blink-text 2s infinite;}\n    \n    @keyframes svelte-9apvmc-blink-text {\n        0%, 100% { opacity: 1; }\n        50% { opacity: 0.7; }\n    }.loader-time.svelte-9apvmc {font-family:'Courier New', monospace;font-size:11px;color:var(--cj-dim);font-weight:900; /* CHUNKY */margin-right:2px;white-space:nowrap;}.progress-container.svelte-9apvmc {height:24px;padding:3px;box-sizing:border-box;background:var(--cj-light);border-top:2px solid var(--cj-dim);border-left:2px solid var(--cj-dim);border-right:2px solid var(--cj-light);border-bottom:2px solid var(--cj-light);position:relative;overflow:hidden;}.progress-bar-fill.svelte-9apvmc {height:100%;background-color:var(--cj-accent);\n        /* Creates the blocky effect using a repeating linear gradient */background-image:repeating-linear-gradient(\n            90deg,\n            var(--cj-accent),\n            var(--cj-accent) 12px,\n            var(--cj-light) 12px,\n            var(--cj-light) 14px\n        );transition:width 0.1s linear;}"
};
function Win95ProgressBar($$anchor, $$props) {
  push($$props, true);
  append_styles($$anchor, $$css4);
  const $statusMessage = () => store_get(statusMessage, "$statusMessage", $$stores);
  const [$$stores, $$cleanup] = setup_stores();
  let label = prop($$props, "label", 3, "INITIALIZING..."), estimatedDuration = prop($$props, "estimatedDuration", 3, 5e3);
  let progress = state(0);
  let interval;
  let timeDisplay = state("");
  let currentStatus = state(proxy(label()));
  const thoughts = [
    "PARSING NARRATIVE STRUCTURE...",
    "QUERYING TROPE DATABASE...",
    "ANALYZING CHARACTER VECTORS...",
    "CALCULATING PACING ENTROPY...",
    "DETECTING PLOT HOLES...",
    "SYNTHESIZING FEEDBACK...",
    "COMPILING FINAL REPORT...",
    "CHECKING THEMATIC CONSISTENCY...",
    "OPTIMIZING NARRATIVE ARC...",
    "CROSS-REFERENCING CAST LIST...",
    "CALCULATING INCITING INCIDENT...",
    "EVALUATING MIDPOINT REVERSAL..."
  ];
  user_effect(() => {
    if ($statusMessage() && $statusMessage() !== "READY") {
      set(currentStatus, $statusMessage(), true);
    } else {
      set(currentStatus, label());
    }
  });
  onMount(() => {
    const fps = 30;
    const intervalTime = 1e3 / fps;
    const totalSteps = estimatedDuration() / intervalTime;
    let currentStep = 0;
    let lastThoughtSwitch = 0;
    const seconds = Math.ceil(estimatedDuration() / 1e3);
    set(timeDisplay, `EST: ~${seconds}s`);
    interval = setInterval(
      () => {
        currentStep++;
        const t3 = currentStep / totalSteps;
        const targetProgress = 95 * (1 - Math.exp(-3 * t3));
        if (targetProgress > get(progress)) {
          set(progress, targetProgress);
        }
        if (get(progress) > 99)
          set(progress, 99);
        const remaining = Math.max(0, Math.ceil((estimatedDuration() - currentStep * intervalTime) / 1e3));
        set(timeDisplay, remaining > 0 ? `EST: ~${remaining}s` : `FINALIZING...`, true);
        if ($statusMessage() === "PROCESSING..." || $statusMessage() === label()) {
          lastThoughtSwitch += intervalTime;
          if (lastThoughtSwitch > 2e3) {
            lastThoughtSwitch = 0;
            set(currentStatus, thoughts[Math.floor(Math.random() * thoughts.length)], true);
          }
        }
      },
      intervalTime
    );
    return () => clearInterval(interval);
  });
  onDestroy(() => {
    if (interval)
      clearInterval(interval);
  });
  var div = root4();
  var div_1 = child(div);
  var div_2 = child(div_1);
  var text2 = child(div_2);
  reset(div_2);
  var div_3 = sibling(div_2, 2);
  var text_1 = child(div_3, true);
  reset(div_3);
  reset(div_1);
  var div_4 = sibling(div_1, 2);
  var div_5 = child(div_4);
  reset(div_4);
  reset(div);
  template_effect(() => {
    var _a3, _b3;
    set_text(text2, `> ${(_a3 = get(currentStatus)) != null ? _a3 : ""}`);
    set_text(text_1, get(timeDisplay));
    set_style(div_5, `width: ${(_b3 = get(progress)) != null ? _b3 : ""}%`);
  });
  append($$anchor, div);
  pop();
  $$cleanup();
}

// AudioEngine.ts
var import_obsidian6 = require("obsidian");
var AudioEngine = class {
  constructor() {
    this.ctx = null;
    this.gainNode = null;
    this.enabled = true;
    this.volume = 0.5;
    this.theme = "win95";
    try {
      const AudioContextClass = window.AudioContext || window.webkitAudioContext;
      this.ctx = new AudioContextClass();
      this.gainNode = this.ctx.createGain();
      this.gainNode.connect(this.ctx.destination);
      this.setVolume(0.5);
    } catch (e2) {
      console.error("AudioEngine Init Failed", e2);
    }
  }
  setEnabled(enabled) {
    var _a3;
    this.enabled = enabled;
    if (((_a3 = this.ctx) == null ? void 0 : _a3.state) === "suspended" && enabled) {
      this.ctx.resume();
    }
  }
  setVolume(vol) {
    this.volume = Math.max(0, Math.min(1, vol));
    if (this.gainNode) {
      this.gainNode.gain.value = this.volume;
    }
  }
  setTheme(theme) {
    if (theme === "msdos" || theme === "win95") {
      this.theme = theme;
    } else {
      this.theme = "win95";
    }
  }
  playTone(freq2, type, duration, startTime = 0) {
    if (!this.enabled || !this.ctx || !this.gainNode)
      return;
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    osc.type = type;
    osc.frequency.setValueAtTime(freq2, this.ctx.currentTime + startTime);
    gain.gain.setValueAtTime(0, this.ctx.currentTime + startTime);
    gain.gain.linearRampToValueAtTime(this.volume, this.ctx.currentTime + startTime + 0.01);
    gain.gain.exponentialRampToValueAtTime(1e-3, this.ctx.currentTime + startTime + duration);
    osc.connect(gain);
    gain.connect(this.gainNode);
    osc.start(this.ctx.currentTime + startTime);
    osc.stop(this.ctx.currentTime + startTime + duration + 0.1);
  }
  playNoise(duration) {
    if (!this.enabled || !this.ctx || !this.gainNode)
      return;
    const bufferSize = this.ctx.sampleRate * duration;
    const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i3 = 0; i3 < bufferSize; i3++) {
      data[i3] = Math.random() * 2 - 1;
    }
    const noise = this.ctx.createBufferSource();
    noise.buffer = buffer;
    const gain = this.ctx.createGain();
    gain.gain.setValueAtTime(this.volume * 0.2, this.ctx.currentTime);
    gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + duration);
    noise.connect(gain);
    gain.connect(this.gainNode);
    noise.start();
  }
  // --- SOUND PROFILES ---
  playStartup() {
    if (this.theme === "msdos") {
      this.playTone(880, "square", 0.3);
    } else {
      const t3 = 0;
      const dur = 2;
      this.playTone(311.13, "sine", dur, t3);
      this.playTone(466.16, "sine", dur, t3 + 0.1);
      this.playTone(622.25, "triangle", dur, t3 + 0.2);
      this.playTone(830.61, "sine", dur * 1.5, t3 + 0.4);
      this.playTone(932.33, "sine", dur, t3 + 0.6);
    }
  }
  playClick() {
    if (this.theme === "msdos") {
      this.playTone(1200, "square", 0.01);
    } else {
      this.playTone(600, "triangle", 0.02);
      this.playTone(800, "sine", 0.02, 0.01);
    }
  }
  playKeystroke() {
    if (this.theme === "msdos") {
      this.playTone(150, "sawtooth", 0.03);
    } else {
      this.playTone(300, "triangle", 0.02);
    }
  }
  playProcess() {
    if (this.theme === "msdos") {
      const count = 3;
      for (let i3 = 0; i3 < count; i3++) {
        this.playTone(200 + Math.random() * 600, "square", 0.05, i3 * 0.1);
      }
    } else {
      this.playNoise(0.1);
      setTimeout(() => this.playNoise(0.05), 150);
    }
  }
  playSuccess() {
    if (this.theme === "msdos") {
      this.playTone(523.25, "square", 0.1, 0);
      this.playTone(659.25, "square", 0.1, 0.1);
      this.playTone(783.99, "square", 0.2, 0.2);
    } else {
      const start2 = 0;
      this.playTone(1046.5, "triangle", 0.4, start2);
      this.playTone(523.25, "sine", 0.4, start2);
      this.playTone(1318.51, "triangle", 0.6, start2 + 0.1);
      this.playTone(1567.98, "sine", 0.8, start2 + 0.2);
      this.playTone(2093, "triangle", 1, start2 + 0.4);
    }
  }
  playError() {
    if (this.theme === "msdos") {
      this.playTone(100, "sawtooth", 0.4);
    } else {
      this.playTone(200, "sawtooth", 0.2, 0);
      this.playTone(150, "square", 0.2, 0);
    }
  }
};

// GradingPanel.svelte
var root_110 = from_html(`<button class="reset-btn" title="Force Format / Stop">RST</button>`);
var root_24 = from_html(`<div class="empty-state">INSERT DISK (OPEN MARKDOWN FILE)</div>`);
var root_82 = from_html(`<p class="quick-synopsis"><span class="prefix">LOG:</span> </p>`);
var root_73 = from_html(`<div class="quick-result"><div class="quick-header"><span class="quick-grade"> </span> <span class="quick-score"> </span></div> <!> <p class="quick-summary"> </p> <p class="quick-fix"> </p></div>`);
var root_92 = from_html(`<!> <button class="action-btn tertiary" style="margin-top:10px;"> </button>`, 1);
var root_54 = from_html(`<div class="panel-critic"><div class="button-row"><button class="action-btn primary"> </button> <button class="action-btn secondary"> </button></div> <!> <!> <!></div>`);
var root_112 = from_html(`<div class="panel-wizard"><button class="action-btn secondary"> </button> <!> <!></div>`);
var root_142 = from_html(`<div class="panel-synth"><!> <!></div>`);
var root_192 = from_html(`<span> </span>`);
var root_202 = from_html(`<span></span> <span> </span>`, 1);
var root_223 = from_html(`<details class="thought-trace bevel-groove"><summary class="thought-header"> </summary> <div class="thought-content"> </div></details>`);
var root_242 = from_html(`<div class="repair-item"><div class="repair-header"> </div> <div class="repair-body"> </div> <div class="repair-why"> </div></div>`);
var root_233 = from_html(`<div class="repair-list"></div>`);
var root_272 = from_html(`<li> </li>`);
var root_26 = from_html(`<div class="repair-list legacy-mode"><p class="legacy-note">[LEGACY REPORT DETECTED - RE-RUN FOR DETAILS]</p> <ol class="forge-steps"></ol></div>`);
var root_212 = from_html(`<div class="forge-report"><!> <div class="weakness-alert"> </div> <!> <button class="action-btn secondary"> </button></div>`);
var root_172 = from_html(`<div class="panel-forge"><button class="action-btn primary"> </button> <!> <div class="repair-focus-area"><label for="repairFocus" class="input-label">REPAIR FOCUS (OPTIONAL):</label> <textarea id="repairFocus" class="retro-input" rows="2" placeholder="E.g., 'Fix the pacing in Act 2' or 'Make the villain scarier'"></textarea></div> <fieldset class="outline-fieldset"><legend> </legend> <div class="button-grid"><button class="action-btn secondary"> </button> <button class="action-btn secondary"> </button> <button class="action-btn secondary"> </button></div></fieldset> <fieldset class="outline-fieldset"><legend> </legend> <div class="memory-core bevel-down"><div class="memory-status"><div class="status-indicator"><!></div> <div class="status-details"> </div></div> <div class="context-controls"><button title="Load active file into buffer"> </button> <button class="scrub-btn"> </button></div></div> <textarea class="retro-input archivist-prompt" rows="2" placeholder="INSTRUCTIONS: Focus area OR Story Title (e.g. 'The Matrix')"></textarea> <div class="grid-2"><button class="action-btn tertiary outline-btn"> </button> <button class="action-btn secondary outline-btn"> </button></div></fieldset> <!></div>`);
var root5 = from_html(`<div><div class="title-bar"><div class="title-bar-text"> </div> <!></div> <div class="tab-strip"><button> </button> <button> </button> <button> </button> <button> </button></div> <div class="window-body"><!></div> <div class="status-bar"><span> </span> <span class="spacer"></span> <span> </span></div></div>`);
var $$css5 = {
  hash: "svelte-1ykavxi",
  code: "\n    /* GLOBAL OVERRIDES IN STYLES.CSS */"
};
function GradingPanel($$anchor, $$props) {
  push($$props, true);
  append_styles($$anchor, $$css5);
  const $processRegistry = () => store_get(processRegistry, "$processRegistry", $$stores);
  const $processOrigin = () => store_get(processOrigin, "$processOrigin", $$stores);
  const [$$stores, $$cleanup] = setup_stores();
  let settings = proxy($$props.settings);
  let activeFile = state(null);
  let projectData = state(null);
  let currentTab = state("critic");
  let themeClass = state("");
  let isSaving = state(false);
  let estimatedDuration = state(4e3);
  let wizardLoadingField = state(null);
  let isMsDos = user_derived(() => settings.theme === "msdos" || settings.theme === "auto" && document.body.classList.contains("theme-dark"));
  let isContextSynced = state(false);
  let isArchivistSynced = state(false);
  let archivistLength = user_derived(() => (get(projectData) === null || get(projectData) === void 0 ? void 0 : get(projectData).archivistContext) ? get(projectData).archivistContext.length : 0);
  let hasArchivistData = user_derived(() => get(archivistLength) > 0);
  let activeFileStatus = user_derived(() => get(activeFile) && $processRegistry()[get(activeFile).path] ? "PROCESSING" : "READY");
  const debouncedSave = debounce(() => saveProject(false), 1e3);
  function handleSettingsUpdate(updates) {
    Object.assign(settings, updates);
    $$props.onUpdateSettings(updates);
    if (updates.theme) {
      $$props.audio.setTheme(updates.theme);
      applyTheme(updates.theme);
    }
  }
  function handleDrivesUpdate(newDrives) {
    if (!get(projectData))
      return;
    get(projectData).wizardState.synthesisDrives = newDrives;
    saveProject(false);
  }
  function handleError(context, error) {
    $$props.audio.playError();
    console.error(`[Compu-Judge] ${context} Error:`, error);
    let msg = error instanceof Error ? error.message : String(error);
    msg = msg.replace(/^Error:\s*/i, "").replace(/^Gemini Error:\s*/i, "");
    if (msg.includes("429"))
      msg = "Rate Limit Exceeded. Please wait.";
    if (msg.includes("401") || msg.includes("403"))
      msg = "Invalid API Key or Permissions.";
    if (msg.includes("TIMEOUT"))
      msg = "AI Timeout. Task was too heavy.";
    new import_obsidian7.Notice(`\u274C ${context}: ${msg}`, 6e3);
    set(wizardLoadingField, null);
  }
  const updateActiveFile = async (file) => {
    if ((get(activeFile) === null || get(activeFile) === void 0 ? void 0 : get(activeFile).path) === (file === null || file === void 0 ? void 0 : file.path))
      return;
    set(activeFile, file, true);
    set(projectData, null);
    if (file)
      await loadProjectData(file);
  };
  const updateTheme = (theme) => {
    applyTheme(theme);
    $$props.audio.setTheme(theme);
  };
  async function loadProjectData(file) {
    try {
      const loadedData = await db.getProjectData(file.path);
      if (get(activeFile) && get(activeFile).path === file.path) {
        set(projectData, loadedData, true);
        await checkAllSyncs();
      }
    } catch (e2) {
      handleError("Load Data", e2);
    }
  }
  async function saveProject(updateMtime = false) {
    if (!get(projectData) || !get(activeFile))
      return;
    if (get(projectData).filePath !== get(activeFile).path) {
      console.warn("Save aborted: State mismatch detected.");
      return;
    }
    set(isSaving, true);
    try {
      if (updateMtime && get(activeFile) instanceof import_obsidian7.TFile) {
        get(projectData).lastAnalysisMtime = get(activeFile).stat.mtime;
      }
      await db.saveProjectData(get(projectData), get(projectData).lastAnalysisMtime);
      await checkAllSyncs();
    } catch (e2) {
      handleError("Save Failed", e2);
    } finally {
      setTimeout(() => set(isSaving, false), 300);
    }
  }
  async function checkAllSyncs() {
    if (!get(activeFile) || !get(projectData)) {
      set(isContextSynced, false);
      set(isArchivistSynced, false);
      return;
    }
    try {
      const content = (await $$props.app.vault.read(get(activeFile))).trim();
      if (!content) {
        set(isContextSynced, true);
        set(isArchivistSynced, true);
        return;
      }
      const wizCtx = get(projectData).wizardState.inspirationContext || "";
      set(isContextSynced, wizCtx.includes(content), true);
      const arcCtx = get(projectData).archivistContext || "";
      set(isArchivistSynced, arcCtx === content || arcCtx.length > 0 && arcCtx.includes(content.substring(0, 100)), true);
    } catch (_a3) {
      set(isContextSynced, false);
      set(isArchivistSynced, false);
    }
  }
  async function getActiveFileContent() {
    if (!get(activeFile))
      return "";
    return await $$props.app.vault.read(get(activeFile));
  }
  async function updateActiveFileContent(newContent) {
    if (!get(activeFile))
      return;
    await $$props.app.vault.modify(get(activeFile), newContent);
  }
  async function handleUploadContext() {
    if (!get(activeFile) || !get(projectData))
      return;
    $$props.audio.playClick();
    try {
      const content = await $$props.app.vault.read(get(activeFile));
      if (!content.trim())
        return new import_obsidian7.Notice("File is empty.");
      const currentContext = get(projectData).wizardState.inspirationContext || "";
      const newContext = currentContext ? `${currentContext}

[IMPORTED SOURCE]:
${content}` : `[IMPORTED SOURCE]:
${content}`;
      get(projectData).wizardState.inspirationContext = newContext;
      set(projectData, { ...get(projectData) }, true);
      new import_obsidian7.Notice("Wizard Memory Updated.");
      await saveProject(false);
    } catch (e2) {
      handleError("Memory Upload", e2);
    }
  }
  function handleScrubContext() {
    if (!get(projectData))
      return;
    $$props.audio.playClick();
    if (confirm("Purge Inspiration Memory?")) {
      get(projectData).wizardState.inspirationContext = "";
      set(projectData, { ...get(projectData) }, true);
      saveProject(false);
      new import_obsidian7.Notice("Wizard Memory Purged.");
    }
  }
  function handleClearWizardState() {
    if (!get(projectData))
      return;
    $$props.audio.playClick();
    if (confirm("Clear all Wizard fields? (Memory/Context will be kept)")) {
      const currentContext = get(projectData).wizardState.inspirationContext;
      get(projectData).wizardState = {
        ...JSON.parse(JSON.stringify(DEFAULT_WIZARD_STATE)),
        inspirationContext: currentContext
      };
      set(projectData, { ...get(projectData) }, true);
      saveProject(false);
      new import_obsidian7.Notice("Wizard Fields Cleared.");
    }
  }
  async function handleUploadArchivist() {
    if (!get(activeFile) || !get(projectData))
      return;
    $$props.audio.playClick();
    try {
      const content = await $$props.app.vault.read(get(activeFile));
      if (!content.trim())
        return new import_obsidian7.Notice("File is empty.");
      get(projectData).archivistContext = content;
      set(projectData, { ...get(projectData) }, true);
      new import_obsidian7.Notice("Archivist Memory Loaded.");
      await saveProject(false);
    } catch (e2) {
      handleError("Buffer Load", e2);
    }
  }
  function handleScrubArchivist() {
    if (!get(projectData))
      return;
    $$props.audio.playClick();
    if (confirm("Clear Archivist Memory?")) {
      get(projectData).archivistContext = "";
      set(projectData, { ...get(projectData) }, true);
      saveProject(false);
      new import_obsidian7.Notice("Archivist Memory Cleared.");
    }
  }
  function startLoading(path, duration = 4e3, label = "PROCESSING...") {
    set(estimatedDuration, duration, true);
    setStatus(label);
    setFileLoading(path, true, get(currentTab));
    $$props.audio.playProcess();
  }
  function stopLoading(path) {
    setTimeout(() => setFileLoading(path, false), 200);
    set(wizardLoadingField, null);
  }
  async function safeCreateFile(filename, content) {
    let finalPath = filename;
    const exists = await $$props.app.vault.adapter.exists(finalPath);
    if (exists) {
      finalPath = filename.replace(".md", `_${Date.now()}.md`);
    }
    const file = await $$props.app.vault.create(finalPath, content);
    new import_obsidian7.Notice(`Created: ${file.path}`);
    return file.path;
  }
  async function handleGradeCharacter(char) {
    if (!get(activeFile) || !get(projectData))
      return char;
    const path = get(activeFile).path;
    startLoading(path, 3e3, `ANALYZING ${char.name.toUpperCase()}...`);
    try {
      const context = get(projectData).wizardState.inspirationContext || "No context provided.";
      const updated = await $$props.cloud.gradeCharacter(char, context);
      $$props.audio.playSuccess();
      new import_obsidian7.Notice(`Metrics Updated for ${char.name}`);
      return updated;
    } catch (e2) {
      handleError("Character Grading", e2);
      return char;
    } finally {
      stopLoading(path);
    }
  }
  async function handleGradeStructure(beat) {
    if (!get(activeFile) || !get(projectData))
      return beat;
    const path = get(activeFile).path;
    startLoading(path, 3e3, `ANALYZING ${beat.type.toUpperCase()}...`);
    try {
      const context = get(projectData).wizardState.inspirationContext || "No context provided.";
      const updated = await $$props.cloud.gradeStructureBeat(beat, context);
      $$props.audio.playSuccess();
      new import_obsidian7.Notice(`Tension Calculated for ${beat.title}`);
      return updated;
    } catch (e2) {
      handleError("Structure Grading", e2);
      return beat;
    } finally {
      stopLoading(path);
    }
  }
  async function runAnalysis() {
    const file = get(activeFile);
    if (!file || !get(projectData))
      return;
    const content = await $$props.app.vault.read(file);
    const estTime = $$props.cloud.estimateDuration(content, "scan");
    startLoading(file.path, estTime, "CALCULATING METRICS...");
    try {
      const nlpStats = NlpService.analyze(content);
      setStatus("SYNTHESIZING DEEP SCAN...");
      const context = {
        inspiration: get(projectData).wizardState.inspirationContext,
        target: get(projectData).wizardState.targetScore
      };
      const result = await $$props.cloud.gradeContent(content, context, nlpStats);
      if ((get(activeFile) === null || get(activeFile) === void 0 ? void 0 : get(activeFile).path) !== file.path)
        return;
      get(projectData).lastAiResult = result;
      get(projectData).lastAnalysisMtime = file.stat.mtime;
      set(projectData, { ...get(projectData) }, true);
      await saveProject(true);
      $$props.audio.playSuccess();
      new import_obsidian7.Notice("Deep Scan Complete.");
    } catch (e2) {
      handleError("Deep Scan", e2);
    } finally {
      stopLoading(file.path);
    }
  }
  async function runQuickScan() {
    const file = get(activeFile);
    if (!file || !get(projectData))
      return;
    const content = await $$props.app.vault.read(file);
    const estTime = $$props.cloud.estimateDuration(content, "quick");
    startLoading(file.path, estTime, "QUICK SCANNING...");
    try {
      const aiGrade = await $$props.cloud.getLightGrade(content);
      if ((get(activeFile) === null || get(activeFile) === void 0 ? void 0 : get(activeFile).path) !== file.path)
        return;
      const summary = `${aiGrade.summary_line}`;
      get(projectData).lastLightResult = { ...aiGrade, summary_line: summary };
      set(projectData, { ...get(projectData) }, true);
      await saveProject(false);
      $$props.audio.playSuccess();
    } catch (e2) {
      handleError("Quick Scan", e2);
    } finally {
      stopLoading(file.path);
    }
  }
  async function runMeta() {
    if (!get(activeFile) || !get(projectData))
      return;
    const path = get(activeFile).path;
    startLoading(path, 4e3, "META-ANALYSIS...");
    try {
      const content = await $$props.app.vault.read(get(activeFile));
      const meta = await $$props.cloud.getMetaAnalysis(content);
      if (get(activeFile).path !== path)
        return;
      get(projectData).lastMetaResult = meta;
      set(projectData, { ...get(projectData) }, true);
      await saveProject(false);
      $$props.audio.playSuccess();
    } catch (e2) {
      handleError("System Diagnostics", e2);
    } finally {
      stopLoading(path);
    }
  }
  async function runWizardAssist(fieldPath) {
    if (!get(projectData) || !get(activeFile))
      return;
    const path = get(activeFile).path;
    set(wizardLoadingField, fieldPath, true);
    startLoading(path, 3e3, "CONSULTING...");
    try {
      const suggestion = await $$props.cloud.assistWizard(fieldPath, get(projectData).wizardState);
      if (get(activeFile).path !== path)
        return;
      const parts = fieldPath.split(".");
      let target = get(projectData).wizardState;
      for (let i3 = 0; i3 < parts.length - 1; i3++)
        target = target[parts[i3]];
      const key2 = parts[parts.length - 1];
      if (target) {
        target[key2] = suggestion;
        set(projectData, { ...get(projectData) }, true);
        new import_obsidian7.Notice("Suggestion Applied.");
        await saveProject(false);
        $$props.audio.playSuccess();
      }
    } catch (e2) {
      handleError("Wizard Assist", e2);
    } finally {
      stopLoading(path);
    }
  }
  async function runGhostwriter() {
    if (!get(activeFile) || !get(projectData))
      return;
    const path = get(activeFile).path;
    const estTime = $$props.cloud.estimateDuration("generate comprehensive outline", "architect");
    startLoading(path, estTime, "ARCHITECTING FULL OUTLINE...");
    try {
      const synopsis = await $$props.cloud.wizardCompose(get(projectData).wizardState);
      const outputName = get(activeFile).basename + "_FULL_OUTLINE.md";
      await safeCreateFile(outputName, synopsis);
      new import_obsidian7.Notice(`Full Outline Created.`);
      $$props.audio.playSuccess();
    } catch (e2) {
      handleError("Ghostwriter", e2);
    } finally {
      stopLoading(path);
    }
  }
  async function runAutoFill() {
    if (!get(activeFile) || !get(projectData))
      return;
    const concept = get(projectData).wizardState.concept;
    if (!concept || concept.length < 5) {
      new import_obsidian7.Notice("Please enter a Concept/Logline first.");
      return;
    }
    if (!confirm("AUTO-FILL WARNING:\nThis will overwrite your current characters, structure, and 3 Ps.\n\nContinue?"))
      return;
    const path = get(activeFile).path;
    startLoading(path, 8e3, "ARCHITECTING STORY BIBLE...");
    try {
      const context = get(projectData).wizardState.inspirationContext || "";
      const generatedState = await $$props.cloud.autoFillWizard(concept, context);
      if (get(activeFile).path !== path)
        return;
      get(projectData).wizardState = {
        ...get(projectData).wizardState,
        ...generatedState,
        concept,
        inspirationContext: context,
        characters: generatedState.characters || [],
        structure: generatedState.structure || [],
        structureDNA: generatedState.structureDNA || get(projectData).wizardState.structureDNA,
        threePs: generatedState.threePs || get(projectData).wizardState.threePs,
        sandersonLaws: generatedState.sandersonLaws || get(projectData).wizardState.sandersonLaws,
        philosopher: generatedState.philosopher || get(projectData).wizardState.philosopher
      };
      set(projectData, { ...get(projectData) }, true);
      await saveProject(false);
      new import_obsidian7.Notice("Story Bible Generated Successfully.");
      $$props.audio.playSuccess();
    } catch (e2) {
      handleError("Auto-Fill", e2);
    } finally {
      stopLoading(path);
    }
  }
  async function runDriveSynthesis(customTitle) {
    if (!get(activeFile) || !get(projectData))
      return;
    const drives = get(projectData).wizardState.synthesisDrives || [];
    if (drives.length === 0) {
      new import_obsidian7.Notice("No drives found. Create a drive first.");
      return;
    }
    if (!confirm("INITIATE FUSION?\nThis will generate a new Universal Outline document from your drives.\n\nProceed?"))
      return;
    const path = get(activeFile).path;
    startLoading(path, 1e4, "FUSING NARRATIVE DRIVES...");
    try {
      const outlineMarkdown = await $$props.cloud.synthesizeDrives(drives, customTitle);
      let outputName = "";
      if (customTitle && customTitle.trim().length > 0) {
        const safeTitle = customTitle.replace(/[^a-z0-9]/gi, "_").substring(0, 50);
        outputName = `${safeTitle}.md`;
      } else {
        outputName = `${get(activeFile).basename}_UNIVERSAL_OUTLINE.md`;
      }
      await safeCreateFile(outputName, outlineMarkdown);
      new import_obsidian7.Notice("Universal Outline Created.");
      $$props.audio.playSuccess();
    } catch (e2) {
      handleError("Synthesis", e2);
    } finally {
      stopLoading(path);
    }
  }
  async function runForge() {
    if (!get(activeFile) || !get(projectData))
      return;
    const path = get(activeFile).path;
    const content = await $$props.app.vault.read(get(activeFile));
    const estTime = $$props.cloud.estimateDuration(content, "scan");
    startLoading(path, estTime, "FORGING ACTION PLAN...");
    try {
      const plan = await $$props.cloud.getActionPlan(content, get(projectData).repairFocus, get(projectData).lastAiResult || void 0, get(projectData).lastLightResult || void 0);
      if (get(activeFile).path !== path)
        return;
      get(projectData).lastActionPlan = plan;
      set(projectData, { ...get(projectData) }, true);
      await saveProject(false);
      $$props.audio.playSuccess();
    } catch (e2) {
      handleError("Forge", e2);
    } finally {
      stopLoading(path);
    }
  }
  async function runOutlineGeneration() {
    if (!get(activeFile) || !get(projectData))
      return;
    const path = get(activeFile).path;
    try {
      const sourceText = get(projectData).archivistContext ? get(projectData).archivistContext.trim() : "";
      const instructions = get(projectData).archivistPrompt ? get(projectData).archivistPrompt.trim() : "";
      if (sourceText.length === 0 && instructions.length === 0)
        throw new Error("ARCHIVIST IDLE: Please Upload Text OR enter a Title/Concept.");
      let combinedInput = "";
      let modeLabel = "";
      let useSearch = false;
      let outputFilename = get(activeFile).basename + "_OUTLINE.md";
      const estTime = $$props.cloud.estimateDuration(sourceText || instructions, "architect");
      if (sourceText.length > 0) {
        modeLabel = "ANALYZING UPLOADED TEXT...";
        combinedInput = `INSTRUCTIONS: ${instructions}

TEXT TO ANALYZE:
${sourceText}`;
        startLoading(path, estTime, modeLabel);
      } else {
        modeLabel = "RESEARCHING & GENERATING...";
        combinedInput = `TARGET TITLE / CONCEPT: "${instructions}"

DIRECTIVE: If this is an existing published story (Book/Movie), retrieve the accurate plot details and outline the published work.`;
        useSearch = true;
        const sanitizedTitle = instructions.replace(/[^a-z0-9\s]/gi, "").trim().replace(/\s+/g, "_").substring(0, 40);
        if (sanitizedTitle.length > 0)
          outputFilename = sanitizedTitle + "_OUTLINE.md";
        startLoading(path, estTime, modeLabel);
      }
      new import_obsidian7.Notice(modeLabel);
      const outlineText = await $$props.cloud.generateOutline(combinedInput, useSearch);
      await safeCreateFile(outputFilename, outlineText);
      new import_obsidian7.Notice(`Archivist Created.`);
      $$props.audio.playSuccess();
    } catch (e2) {
      handleError("Archivist", e2);
    } finally {
      stopLoading(path);
    }
  }
  async function runAutoRepair() {
    if (!get(activeFile) || !get(projectData) || !get(projectData).lastActionPlan)
      return;
    const path = get(activeFile).path;
    const content = await $$props.app.vault.read(get(activeFile));
    const estTime = $$props.cloud.estimateDuration(content, "repair");
    startLoading(path, estTime, "APPLYING NARRATIVE PATCH...");
    try {
      const repairedText = await $$props.cloud.autoRepair(content, get(projectData).lastActionPlan);
      const outputName = get(activeFile).basename + "_REPAIRED.md";
      await safeCreateFile(outputName, repairedText);
      new import_obsidian7.Notice(`Repaired File Created.`);
      $$props.audio.playSuccess();
    } catch (e2) {
      handleError("Auto-Patch", e2);
    } finally {
      stopLoading(path);
    }
  }
  async function runDeepRename() {
    if (!get(activeFile) || !get(projectData))
      return;
    const chars = get(projectData).wizardState.characters;
    if (!chars || chars.length === 0) {
      new import_obsidian7.Notice("No characters found in Wizard.");
      return;
    }
    if (!confirm("RENAME CAST WARNING:\nThis will permanently update character names in your Wizard based on Deep Nomenclature logic. Undo is not supported.\n\nProceed?"))
      return;
    const path = get(activeFile).path;
    startLoading(path, 6e3, "ETYMOLOGIST: RENAMING...");
    try {
      const context = get(projectData).wizardState.inspirationContext || "";
      const nameMap = await $$props.cloud.generateDeepNames(chars, context);
      let updateCount = 0;
      const newChars = chars.map((c2) => {
        if (nameMap[c2.name]) {
          updateCount++;
          return { ...c2, name: nameMap[c2.name] };
        }
        return c2;
      });
      get(projectData).wizardState.characters = newChars;
      set(projectData, { ...get(projectData) }, true);
      await saveProject(false);
      new import_obsidian7.Notice(`Renaming Complete. ${updateCount} characters updated.`);
      $$props.audio.playSuccess();
    } catch (e2) {
      handleError("Deep Rename", e2);
    } finally {
      stopLoading(path);
    }
  }
  async function resetCurrentDisc() {
    if (!get(activeFile))
      return;
    setFileLoading(get(activeFile).path, false);
    if (!get(projectData))
      return;
    $$props.audio.playClick();
    if (window.confirm("FORCE FORMAT DISC? Resets all data.")) {
      const blankState = JSON.parse(JSON.stringify(DEFAULT_WIZARD_STATE));
      get(projectData).wizardState = blankState;
      get(projectData).lastAiResult = null;
      get(projectData).lastLightResult = null;
      get(projectData).lastActionPlan = null;
      get(projectData).lastMetaResult = null;
      get(projectData).lastAnalysisMtime = null;
      get(projectData).archivistPrompt = "";
      get(projectData).archivistContext = "";
      get(projectData).repairFocus = "";
      set(projectData, { ...get(projectData) }, true);
      await saveProject(true);
      new import_obsidian7.Notice("Disc Formatted.");
    }
  }
  function applyTheme(mode) {
    const isDark = document.body.classList.contains("theme-dark");
    if (mode === "win95")
      set(themeClass, "theme-win95");
    else if (mode === "msdos")
      set(themeClass, "theme-msdos");
    else if (mode === "invert")
      set(themeClass, isDark ? "theme-win95" : "theme-msdos", true);
    else
      set(themeClass, isDark ? "theme-msdos" : "theme-win95", true);
  }
  function switchTab(tab) {
    $$props.audio.playClick();
    set(currentTab, tab, true);
  }
  async function runFixDialogue() {
    if (!get(activeFile))
      return;
    $$props.audio.playClick();
    try {
      const content = await getActiveFileContent();
      const fixed = ForgeOps.fixDialogue(content);
      if (fixed !== content) {
        await updateActiveFileContent(fixed);
      }
    } catch (e2) {
      handleError("Dialogue Fix", e2);
    }
  }
  async function runAdverbKiller(mode) {
    if (!get(activeFile))
      return;
    $$props.audio.playClick();
    try {
      const content = await getActiveFileContent();
      const fixed = ForgeOps.assassinateAdverbs(content, mode);
      if (fixed !== content) {
        await updateActiveFileContent(fixed);
      }
    } catch (e2) {
      handleError("Adverb Killer", e2);
    }
  }
  async function runFilterHighlight() {
    if (!get(activeFile))
      return;
    $$props.audio.playClick();
    try {
      const content = await getActiveFileContent();
      const fixed = ForgeOps.highlightFilters(content);
      if (fixed !== content) {
        await updateActiveFileContent(fixed);
      }
    } catch (e2) {
      handleError("Filter Highlight", e2);
    }
  }
  async function runGenerateReport() {
    if (!get(activeFile) || !get(projectData))
      return;
    $$props.audio.playClick();
    try {
      await ReportGen.generateReport($$props.app, get(projectData), get(activeFile).basename);
    } catch (e2) {
      handleError("Report Gen", e2);
    }
  }
  onMount(() => {
    const f3 = $$props.app.workspace.getActiveFile();
    updateActiveFile(f3);
    applyTheme(settings.theme);
  });
  var $$exports = { updateActiveFile, updateTheme };
  var div = root5();
  var div_1 = child(div);
  var div_2 = child(div_1);
  var text2 = child(div_2);
  reset(div_2);
  var node = sibling(div_2, 2);
  {
    var consequent = ($$anchor2) => {
      var button = root_110();
      button.__click = resetCurrentDisc;
      append($$anchor2, button);
    };
    if_block(node, ($$render) => {
      if (get(activeFile))
        $$render(consequent);
    });
  }
  reset(div_1);
  var div_3 = sibling(div_1, 2);
  var button_1 = child(div_3);
  button_1.__click = () => switchTab("critic");
  let classes;
  var text_1 = child(button_1, true);
  reset(button_1);
  var button_2 = sibling(button_1, 2);
  button_2.__click = () => switchTab("wizard");
  let classes_1;
  var text_2 = child(button_2, true);
  reset(button_2);
  var button_3 = sibling(button_2, 2);
  button_3.__click = () => switchTab("synth");
  let classes_2;
  var text_3 = child(button_3, true);
  reset(button_3);
  var button_4 = sibling(button_3, 2);
  button_4.__click = () => switchTab("forge");
  let classes_3;
  var text_4 = child(button_4, true);
  reset(button_4);
  reset(div_3);
  var div_4 = sibling(div_3, 2);
  var node_1 = child(div_4);
  {
    var consequent_1 = ($$anchor2) => {
      var div_5 = root_24();
      append($$anchor2, div_5);
    };
    var alternate_5 = ($$anchor2) => {
      var fragment = comment();
      var node_2 = first_child(fragment);
      {
        var consequent_18 = ($$anchor3) => {
          var fragment_1 = comment();
          var node_3 = first_child(fragment_1);
          {
            var consequent_6 = ($$anchor4) => {
              var div_6 = root_54();
              var div_7 = child(div_6);
              var button_5 = child(div_7);
              button_5.__click = () => runAnalysis();
              var text_5 = child(button_5, true);
              reset(button_5);
              var button_6 = sibling(button_5, 2);
              button_6.__click = runQuickScan;
              var text_6 = child(button_6, true);
              reset(button_6);
              reset(div_7);
              var node_4 = sibling(div_7, 2);
              {
                var consequent_2 = ($$anchor5) => {
                  Win95ProgressBar($$anchor5, {
                    label: "ANALYZING...",
                    get estimatedDuration() {
                      return get(estimatedDuration);
                    }
                  });
                };
                if_block(node_4, ($$render) => {
                  if ($processRegistry()[get(activeFile).path] && $processOrigin()[get(activeFile).path] === "critic")
                    $$render(consequent_2);
                });
              }
              var node_5 = sibling(node_4, 2);
              {
                var consequent_4 = ($$anchor5) => {
                  var div_8 = root_73();
                  var div_9 = child(div_8);
                  var span = child(div_9);
                  var text_7 = child(span, true);
                  reset(span);
                  var span_1 = sibling(span, 2);
                  var text_8 = child(span_1, true);
                  reset(span_1);
                  reset(div_9);
                  var node_6 = sibling(div_9, 2);
                  {
                    var consequent_3 = ($$anchor6) => {
                      var p5 = root_82();
                      var text_9 = sibling(child(p5));
                      reset(p5);
                      template_effect(() => {
                        var _a3;
                        return set_text(text_9, ` ${(_a3 = get(projectData).lastLightResult.synopsis) != null ? _a3 : ""}`);
                      });
                      append($$anchor6, p5);
                    };
                    if_block(node_6, ($$render) => {
                      if (get(projectData).lastLightResult.synopsis)
                        $$render(consequent_3);
                    });
                  }
                  var p_1 = sibling(node_6, 2);
                  var text_10 = child(p_1, true);
                  reset(p_1);
                  var p_2 = sibling(p_1, 2);
                  var text_11 = child(p_2);
                  reset(p_2);
                  reset(div_8);
                  template_effect(() => {
                    var _a3;
                    set_text(text_7, get(projectData).lastLightResult.letter_grade);
                    set_text(text_8, get(projectData).lastLightResult.score);
                    set_text(text_10, get(projectData).lastLightResult.summary_line);
                    set_text(text_11, `FIX: ${(_a3 = get(projectData).lastLightResult.key_improvement) != null ? _a3 : ""}`);
                  });
                  append($$anchor5, div_8);
                };
                if_block(node_5, ($$render) => {
                  if (get(projectData).lastLightResult)
                    $$render(consequent_4);
                });
              }
              var node_7 = sibling(node_5, 2);
              {
                var consequent_5 = ($$anchor5) => {
                  var fragment_3 = root_92();
                  var node_8 = first_child(fragment_3);
                  CriticDisplay(node_8, {
                    get data() {
                      return get(projectData).lastAiResult;
                    },
                    get meta() {
                      return get(projectData).lastMetaResult;
                    },
                    get isProcessing() {
                      return $processRegistry()[get(activeFile).path];
                    },
                    get settings() {
                      return settings;
                    },
                    onRunMeta: runMeta,
                    get isMsDos() {
                      return get(isMsDos);
                    }
                  });
                  var button_7 = sibling(node_8, 2);
                  button_7.__click = runGenerateReport;
                  var text_12 = child(button_7, true);
                  reset(button_7);
                  template_effect(() => set_text(text_12, get(isMsDos) ? "[ EXPORT REPORT ]" : "\u{1F4C4} EXPORT FORENSIC REPORT"));
                  append($$anchor5, fragment_3);
                };
                if_block(node_7, ($$render) => {
                  if (get(projectData).lastAiResult)
                    $$render(consequent_5);
                });
              }
              reset(div_6);
              template_effect(() => {
                set_text(text_5, get(isMsDos) ? "[ RUN DEEP SCAN ]" : `DEEP SCAN (${settings.analysisPasses} CORE)`);
                set_text(text_6, get(isMsDos) ? "[ QUICK SCAN ]" : "QUICK SCAN");
              });
              append($$anchor4, div_6);
            };
            var alternate_4 = ($$anchor4) => {
              var fragment_4 = comment();
              var node_9 = first_child(fragment_4);
              {
                var consequent_8 = ($$anchor5) => {
                  var div_10 = root_112();
                  var button_8 = child(div_10);
                  button_8.__click = runGhostwriter;
                  var text_13 = child(button_8, true);
                  reset(button_8);
                  var node_10 = sibling(button_8, 2);
                  {
                    var consequent_7 = ($$anchor6) => {
                      Win95ProgressBar($$anchor6, {
                        label: "ARCHITECTING...",
                        get estimatedDuration() {
                          return get(estimatedDuration);
                        }
                      });
                    };
                    if_block(node_10, ($$render) => {
                      if ($processRegistry()[get(activeFile).path] && $processOrigin()[get(activeFile).path] === "wizard")
                        $$render(consequent_7);
                    });
                  }
                  var node_11 = sibling(node_10, 2);
                  WizardFields(node_11, {
                    get wizardState() {
                      return get(projectData).wizardState;
                    },
                    get settings() {
                      return settings;
                    },
                    get onSave() {
                      return debouncedSave;
                    },
                    onAssist: runWizardAssist,
                    onUploadContext: handleUploadContext,
                    onScrubContext: handleScrubContext,
                    onClear: handleClearWizardState,
                    onAutoFill: runAutoFill,
                    get isContextSynced() {
                      return get(isContextSynced);
                    },
                    get loadingField() {
                      return get(wizardLoadingField);
                    },
                    onGradeCharacter: handleGradeCharacter,
                    onGradeStructure: handleGradeStructure
                  });
                  reset(div_10);
                  template_effect(() => set_text(text_13, get(isMsDos) ? "[ GENERATE FULL OUTLINE ]" : "GENERATE FULL OUTLINE"));
                  append($$anchor5, div_10);
                };
                var alternate_3 = ($$anchor5) => {
                  var fragment_6 = comment();
                  var node_12 = first_child(fragment_6);
                  {
                    var consequent_10 = ($$anchor6) => {
                      var div_11 = root_142();
                      var node_13 = child(div_11);
                      {
                        var consequent_9 = ($$anchor7) => {
                          Win95ProgressBar($$anchor7, { label: "SYNTHESIZING...", estimatedDuration: 1e4 });
                        };
                        if_block(node_13, ($$render) => {
                          if ($processRegistry()[get(activeFile).path] && $processOrigin()[get(activeFile).path] === "synth")
                            $$render(consequent_9);
                        });
                      }
                      var node_14 = sibling(node_13, 2);
                      {
                        let $0 = user_derived(() => get(projectData).wizardState.synthesisDrives || []);
                        SynthesizerView(node_14, {
                          get app() {
                            return $$props.app;
                          },
                          get settings() {
                            return settings;
                          },
                          get drives() {
                            return get($0);
                          },
                          onUpdateDrives: handleDrivesUpdate,
                          onUpdateSettings: handleSettingsUpdate,
                          onRunSynthesis: runDriveSynthesis,
                          onGetActiveContent: getActiveFileContent
                        });
                      }
                      reset(div_11);
                      append($$anchor6, div_11);
                    };
                    var alternate_2 = ($$anchor6) => {
                      var fragment_8 = comment();
                      var node_15 = first_child(fragment_8);
                      {
                        var consequent_17 = ($$anchor7) => {
                          var div_12 = root_172();
                          var button_9 = child(div_12);
                          button_9.__click = runForge;
                          var text_14 = child(button_9, true);
                          reset(button_9);
                          var node_16 = sibling(button_9, 2);
                          {
                            var consequent_11 = ($$anchor8) => {
                              Win95ProgressBar($$anchor8, {
                                label: "FORGING...",
                                get estimatedDuration() {
                                  return get(estimatedDuration);
                                }
                              });
                            };
                            if_block(node_16, ($$render) => {
                              if ($processRegistry()[get(activeFile).path] && $processOrigin()[get(activeFile).path] === "forge")
                                $$render(consequent_11);
                            });
                          }
                          var div_13 = sibling(node_16, 2);
                          var textarea = sibling(child(div_13), 2);
                          remove_textarea_child(textarea);
                          effect(() => bind_value(textarea, () => get(projectData).repairFocus, ($$value) => get(projectData).repairFocus = $$value));
                          action(textarea, ($$node, $$action_arg) => {
                            var _a3;
                            return (_a3 = autoResize) == null ? void 0 : _a3($$node, $$action_arg);
                          }, () => get(projectData).repairFocus);
                          reset(div_13);
                          var fieldset = sibling(div_13, 2);
                          var legend = child(fieldset);
                          var text_15 = child(legend, true);
                          reset(legend);
                          var div_14 = sibling(legend, 2);
                          var button_10 = child(div_14);
                          button_10.__click = runFixDialogue;
                          var text_16 = child(button_10, true);
                          reset(button_10);
                          var button_11 = sibling(button_10, 2);
                          button_11.__click = () => runAdverbKiller("highlight");
                          var text_17 = child(button_11, true);
                          reset(button_11);
                          var button_12 = sibling(button_11, 2);
                          button_12.__click = runFilterHighlight;
                          var text_18 = child(button_12, true);
                          reset(button_12);
                          reset(div_14);
                          reset(fieldset);
                          var fieldset_1 = sibling(fieldset, 2);
                          var legend_1 = child(fieldset_1);
                          var text_19 = child(legend_1, true);
                          reset(legend_1);
                          var div_15 = sibling(legend_1, 2);
                          var div_16 = child(div_15);
                          var div_17 = child(div_16);
                          var node_17 = child(div_17);
                          {
                            var consequent_12 = ($$anchor8) => {
                              var span_2 = root_192();
                              var text_20 = child(span_2, true);
                              reset(span_2);
                              template_effect(() => set_text(text_20, get(hasArchivistData) ? "[ LOADED ]" : "[ EMPTY ]"));
                              append($$anchor8, span_2);
                            };
                            var alternate = ($$anchor8) => {
                              var fragment_10 = root_202();
                              var span_3 = first_child(fragment_10);
                              var span_4 = sibling(span_3, 2);
                              var text_21 = child(span_4, true);
                              reset(span_4);
                              template_effect(() => {
                                set_class(span_3, 1, `led ${get(hasArchivistData) ? "on" : "off"}`);
                                set_text(text_21, get(hasArchivistData) ? "BUFFER LOADED" : "BUFFER EMPTY");
                              });
                              append($$anchor8, fragment_10);
                            };
                            if_block(node_17, ($$render) => {
                              if (get(isMsDos))
                                $$render(consequent_12);
                              else
                                $$render(alternate, false);
                            });
                          }
                          reset(div_17);
                          var div_18 = sibling(div_17, 2);
                          var text_22 = child(div_18);
                          reset(div_18);
                          reset(div_16);
                          var div_19 = sibling(div_16, 2);
                          var button_13 = child(div_19);
                          button_13.__click = handleUploadArchivist;
                          var text_23 = child(button_13, true);
                          reset(button_13);
                          var button_14 = sibling(button_13, 2);
                          button_14.__click = handleScrubArchivist;
                          var text_24 = child(button_14, true);
                          reset(button_14);
                          reset(div_19);
                          reset(div_15);
                          var textarea_1 = sibling(div_15, 2);
                          remove_textarea_child(textarea_1);
                          effect(() => bind_value(textarea_1, () => get(projectData).archivistPrompt, ($$value) => get(projectData).archivistPrompt = $$value));
                          action(textarea_1, ($$node, $$action_arg) => {
                            var _a3;
                            return (_a3 = autoResize) == null ? void 0 : _a3($$node, $$action_arg);
                          }, () => get(projectData).archivistPrompt);
                          var div_20 = sibling(textarea_1, 2);
                          var button_15 = child(div_20);
                          button_15.__click = runOutlineGeneration;
                          var text_25 = child(button_15, true);
                          reset(button_15);
                          var button_16 = sibling(button_15, 2);
                          button_16.__click = runDeepRename;
                          var text_26 = child(button_16, true);
                          reset(button_16);
                          reset(div_20);
                          reset(fieldset_1);
                          var node_18 = sibling(fieldset_1, 2);
                          {
                            var consequent_16 = ($$anchor8) => {
                              var div_21 = root_212();
                              var node_19 = child(div_21);
                              {
                                var consequent_13 = ($$anchor9) => {
                                  var details = root_223();
                                  var summary_1 = child(details);
                                  var text_27 = child(summary_1, true);
                                  reset(summary_1);
                                  var div_22 = sibling(summary_1, 2);
                                  var text_28 = child(div_22, true);
                                  reset(div_22);
                                  reset(details);
                                  template_effect(() => {
                                    set_text(text_27, get(isMsDos) ? "> TRACE" : "COGNITIVE TRACE (RAW)");
                                    set_text(text_28, get(projectData).lastActionPlan.thought_process);
                                  });
                                  append($$anchor9, details);
                                };
                                if_block(node_19, ($$render) => {
                                  if (get(projectData).lastActionPlan.thought_process)
                                    $$render(consequent_13);
                                });
                              }
                              var div_23 = sibling(node_19, 2);
                              var text_29 = child(div_23);
                              reset(div_23);
                              var node_20 = sibling(div_23, 2);
                              {
                                var consequent_14 = ($$anchor9) => {
                                  var div_24 = root_233();
                                  each(div_24, 21, () => get(projectData).lastActionPlan.repairs, index, ($$anchor10, repair, i3) => {
                                    var div_25 = root_242();
                                    var div_26 = child(div_25);
                                    var text_30 = child(div_26);
                                    reset(div_26);
                                    var div_27 = sibling(div_26, 2);
                                    var text_31 = child(div_27, true);
                                    reset(div_27);
                                    var div_28 = sibling(div_27, 2);
                                    var text_32 = child(div_28);
                                    reset(div_28);
                                    reset(div_25);
                                    template_effect(() => {
                                      var _a3, _b3;
                                      set_text(text_30, `ISSUE ${i3 + 1}: ${(_a3 = get(repair).issue) != null ? _a3 : ""}`);
                                      set_text(text_31, get(repair).instruction);
                                      set_text(text_32, `RATIONALE: ${(_b3 = get(repair).why) != null ? _b3 : ""}`);
                                    });
                                    append($$anchor10, div_25);
                                  });
                                  reset(div_24);
                                  append($$anchor9, div_24);
                                };
                                var alternate_1 = ($$anchor9) => {
                                  var fragment_11 = comment();
                                  var node_21 = first_child(fragment_11);
                                  {
                                    var consequent_15 = ($$anchor10) => {
                                      var div_29 = root_26();
                                      var ol = sibling(child(div_29), 2);
                                      each(ol, 21, () => get(projectData).lastActionPlan.steps, index, ($$anchor11, step) => {
                                        var li = root_272();
                                        var text_33 = child(li, true);
                                        reset(li);
                                        template_effect(() => set_text(text_33, get(step)));
                                        append($$anchor11, li);
                                      });
                                      reset(ol);
                                      reset(div_29);
                                      append($$anchor10, div_29);
                                    };
                                    if_block(
                                      node_21,
                                      ($$render) => {
                                        if (get(projectData).lastActionPlan.steps)
                                          $$render(consequent_15);
                                      },
                                      true
                                    );
                                  }
                                  append($$anchor9, fragment_11);
                                };
                                if_block(node_20, ($$render) => {
                                  if (get(projectData).lastActionPlan.repairs)
                                    $$render(consequent_14);
                                  else
                                    $$render(alternate_1, false);
                                });
                              }
                              var button_17 = sibling(node_20, 2);
                              button_17.__click = runAutoRepair;
                              var text_34 = child(button_17, true);
                              reset(button_17);
                              reset(div_21);
                              template_effect(() => {
                                var _a3;
                                set_text(text_29, `WEAK LINK: ${(_a3 = get(projectData).lastActionPlan.weakest_link) != null ? _a3 : ""}`);
                                set_text(text_34, get(isMsDos) ? "[ AUTO-PATCH ]" : "EXECUTE REPAIR PROTOCOL (AUTO-PATCH)");
                              });
                              append($$anchor8, div_21);
                            };
                            if_block(node_18, ($$render) => {
                              if (get(projectData).lastActionPlan)
                                $$render(consequent_16);
                            });
                          }
                          reset(div_12);
                          template_effect(() => {
                            var _a3;
                            set_text(text_14, get(isMsDos) ? "[ GENERATE REPAIR PLAN ]" : "GENERATE REPAIR PLAN");
                            set_text(text_15, get(isMsDos) ? "[ PROSE TOOLS ]" : "PROSE TOOLS");
                            set_text(text_16, get(isMsDos) ? "[ FIX PUNCTUATION ]" : "FIX DIALOGUE PUNCTUATION");
                            set_text(text_17, get(isMsDos) ? "[ HIGHLIGHT ADVERBS ]" : "HIGHLIGHT ADVERBS (RED)");
                            set_text(text_18, get(isMsDos) ? "[ HIGHLIGHT FILTER WORDS ]" : "HIGHLIGHT FILTER WORDS (YELLOW)");
                            set_text(text_19, get(isMsDos) ? "[ ARCHIVIST ]" : "STRUCTURAL ARCHIVIST");
                            set_text(text_22, `${(_a3 = get(archivistLength)) != null ? _a3 : ""} CHARS`);
                            set_class(button_13, 1, `upload-btn ${get(isArchivistSynced) ? "synced" : ""}`);
                            button_13.disabled = get(isArchivistSynced);
                            set_text(text_23, get(isArchivistSynced) ? get(isMsDos) ? "[ SYNCED ]" : "\u2705 SYNCED" : get(isMsDos) ? "[ LOAD ]" : "\u{1F4E5} LOAD BUFFER");
                            button_14.disabled = !get(hasArchivistData);
                            set_text(text_24, get(isMsDos) ? "[ DEL ]" : "\u{1F5D1}\uFE0F");
                            set_text(text_25, get(hasArchivistData) ? get(isMsDos) ? "[ ANALYZE ]" : "ANALYZE BUFFER" : get(isMsDos) ? "[ GEN FROM TITLE ]" : "GENERATE FROM TITLE");
                            set_text(text_26, get(isMsDos) ? "[ RENAME CAST ]" : "\u{1F3F7}\uFE0F RENAME CAST (DEEP)");
                          });
                          append($$anchor7, div_12);
                        };
                        if_block(
                          node_15,
                          ($$render) => {
                            if (get(currentTab) === "forge")
                              $$render(consequent_17);
                          },
                          true
                        );
                      }
                      append($$anchor6, fragment_8);
                    };
                    if_block(
                      node_12,
                      ($$render) => {
                        if (get(currentTab) === "synth")
                          $$render(consequent_10);
                        else
                          $$render(alternate_2, false);
                      },
                      true
                    );
                  }
                  append($$anchor5, fragment_6);
                };
                if_block(
                  node_9,
                  ($$render) => {
                    if (get(currentTab) === "wizard")
                      $$render(consequent_8);
                    else
                      $$render(alternate_3, false);
                  },
                  true
                );
              }
              append($$anchor4, fragment_4);
            };
            if_block(node_3, ($$render) => {
              if (get(currentTab) === "critic")
                $$render(consequent_6);
              else
                $$render(alternate_4, false);
            });
          }
          append($$anchor3, fragment_1);
        };
        if_block(
          node_2,
          ($$render) => {
            if (get(projectData))
              $$render(consequent_18);
          },
          true
        );
      }
      append($$anchor2, fragment);
    };
    if_block(node_1, ($$render) => {
      if (!get(activeFile))
        $$render(consequent_1);
      else
        $$render(alternate_5, false);
    });
  }
  reset(div_4);
  var div_30 = sibling(div_4, 2);
  var span_5 = child(div_30);
  var text_35 = child(span_5);
  reset(span_5);
  var span_6 = sibling(span_5, 4);
  let classes_4;
  var text_36 = child(span_6, true);
  reset(span_6);
  reset(div_30);
  reset(div);
  template_effect(
    ($0) => {
      var _a3, _b3, _c2, _d;
      set_class(div, 1, `compu-container ${(_a3 = get(themeClass)) != null ? _a3 : ""}`);
      set_style(div, `--cj-user-color: ${(_b3 = settings.msDosColor || "#00FF00") != null ? _b3 : ""}; --cj-grade-masterpiece: ${(_c2 = settings.gradingColors.masterpiece) != null ? _c2 : ""}`);
      set_text(text2, `Compu-Judge 98 ${$0 != null ? $0 : ""}`);
      classes = set_class(button_1, 1, "", null, classes, { active: get(currentTab) === "critic" });
      set_text(text_1, get(isMsDos) ? "[ CRITIC ]" : "CRITIC");
      classes_1 = set_class(button_2, 1, "", null, classes_1, { active: get(currentTab) === "wizard" });
      set_text(text_2, get(isMsDos) ? "[ WIZARD ]" : "WIZARD");
      classes_2 = set_class(button_3, 1, "", null, classes_2, { active: get(currentTab) === "synth" });
      set_text(text_3, get(isMsDos) ? "[ SYNTH ]" : "SYNTH");
      classes_3 = set_class(button_4, 1, "", null, classes_3, { active: get(currentTab) === "forge" });
      set_text(text_4, get(isMsDos) ? "[ FORGE ]" : "FORGE");
      set_text(text_35, `STATUS: ${(_d = get(activeFileStatus)) != null ? _d : ""}`);
      classes_4 = set_class(span_6, 1, "disk-led", null, classes_4, { "active-led": get(isSaving) });
      set_text(text_36, get(isMsDos) ? "[DISK]" : "DISK ACT");
    },
    [
      () => get(activeFile) ? `[${get(activeFile).basename.toUpperCase()}]` : "[NO DISC]"
    ]
  );
  append($$anchor, div);
  var $$pop = pop($$exports);
  $$cleanup();
  return $$pop;
}
delegate(["click"]);

// CompuJudgeView.ts
var VIEW_TYPE_COMPU_JUDGE = "compu-judge-view";
var CompuJudgeView = class extends import_obsidian8.ItemView {
  // NEW
  constructor(leaf, app, settings, cloud, plugin5, audio) {
    super(leaf);
    this.app = app;
    this.settings = settings;
    this.cloud = cloud;
    this.plugin = plugin5;
    this.audio = audio;
  }
  getViewType() {
    return VIEW_TYPE_COMPU_JUDGE;
  }
  getDisplayText() {
    return "Compu-Judge 98";
  }
  getIcon() {
    return "bot";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    this.component = mount(GradingPanel, {
      target: container,
      props: {
        app: this.app,
        cloud: this.cloud,
        settings: this.settings,
        audio: this.audio,
        // NEW: Pass AudioEngine
        onUpdateSettings: async (newSettings) => {
          Object.assign(this.settings, newSettings);
          Object.assign(this.plugin.settings, newSettings);
          await this.plugin.saveSettings();
        }
      }
    });
  }
  async onClose() {
    if (this.component) {
      unmount(this.component);
    }
  }
  updateActiveFile(file) {
    if (this.component && this.component.updateActiveFile) {
      this.component.updateActiveFile(file);
    }
  }
  updateTheme(theme) {
    if (this.component && this.component.updateTheme) {
      this.component.updateTheme(theme);
    }
  }
};

// editor-extension.ts
var import_view = require("@codemirror/view");
var import_state = require("@codemirror/state");
var adverbMark = import_view.Decoration.mark({ class: "cj-highlight-adverb", attributes: { "data-cj-type": "Adverb Toxicity" } });
var filterMark = import_view.Decoration.mark({ class: "cj-highlight-filter", attributes: { "data-cj-type": "Filter Word (Distance)" } });
var weakMark = import_view.Decoration.mark({ class: "cj-highlight-weak", attributes: { "data-cj-type": "Weak Verb" } });
var DEBOUNCE_MS = 1e3;
var compuJudgeHud = import_view.ViewPlugin.fromClass(class {
  constructor(view) {
    this.timeout = null;
    this.decorations = import_view.Decoration.none;
    this.scheduleScan(view);
  }
  update(update2) {
    if (update2.docChanged || update2.viewportChanged) {
      this.scheduleScan(update2.view);
    }
  }
  scheduleScan(view) {
    if (this.timeout)
      window.clearTimeout(this.timeout);
    this.timeout = window.setTimeout(() => {
      this.decorations = this.scan(view);
      view.dispatch({ effects: [] });
    }, DEBOUNCE_MS);
  }
  scan(view) {
    const builder = new import_state.RangeSetBuilder();
    const docText = view.state.doc.toString();
    const adverbRegex = /\b(\w+ly)\b/gi;
    const whitelist = ["only", "family", "ugly", "ally", "holy", "early", "daily", "suddenly", "really", "barely"];
    let match2;
    while ((match2 = adverbRegex.exec(docText)) !== null) {
      if (!whitelist.includes(match2[0].toLowerCase())) {
        builder.add(match2.index, match2.index + match2[0].length, adverbMark);
      }
    }
    const filters = ["saw", "felt", "heard", "noticed", "wondered", "realized", "knew", "thought", "decided"];
    filters.forEach((word) => {
      const regex = new RegExp(`\\b${word}\\b`, "gi");
      while ((match2 = regex.exec(docText)) !== null) {
        builder.add(match2.index, match2.index + match2[0].length, filterMark);
      }
    });
    const weak = ["was", "were", "is", "are", "been", "being"];
    weak.forEach((word) => {
      const regex = new RegExp(`\\b${word}\\b`, "gi");
      while ((match2 = regex.exec(docText)) !== null) {
        builder.add(match2.index, match2.index + match2[0].length, weakMark);
      }
    });
    return builder.finish();
  }
}, {
  decorations: (v2) => v2.decorations
});

// main.ts
var CompuJudgePlugin = class extends import_obsidian9.Plugin {
  // NEW
  async onload() {
    await this.loadSettings();
    db.connect(this);
    await db.init();
    this.audio = new AudioEngine();
    this.audio.setEnabled(this.settings.enableAudio);
    this.audio.setVolume(this.settings.audioVolume);
    this.audio.setTheme(this.settings.theme);
    this.registerEditorExtension(compuJudgeHud);
    this.cloud = new CloudGenService(this.app, this.settings);
    this.registerView(
      VIEW_TYPE_COMPU_JUDGE,
      (leaf) => new CompuJudgeView(leaf, this.app, this.settings, this.cloud, this, this.audio)
    );
    this.addRibbonIcon("bot", "Compu-Judge 98", () => this.activateView());
    this.addCommand({
      id: "open-compu-judge",
      name: "Open Interface",
      callback: () => this.activateView()
    });
    this.addCommand({
      id: "purge-db",
      name: "DEBUG: Purge Database",
      callback: async () => {
        if (window.confirm("Delete all saved scan data? This cannot be undone.")) {
          await db.deleteDatabase();
          new import_obsidian9.Notice("Database Purged. Please Restart Obsidian.");
        }
      }
    });
    this.addSettingTab(new NigsSettingTab(this.app, this));
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", () => {
        const file = this.app.workspace.getActiveFile();
        this.updateViewFile(file);
      })
    );
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = workspace.getLeavesOfType(VIEW_TYPE_COMPU_JUDGE)[0];
    if (!leaf) {
      leaf = workspace.getRightLeaf(false);
      if (leaf)
        await leaf.setViewState({ type: VIEW_TYPE_COMPU_JUDGE, active: true });
    }
    if (leaf)
      workspace.revealLeaf(leaf);
    this.audio.playStartup();
  }
  updateViewFile(file) {
    const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_COMPU_JUDGE);
    leaves.forEach((leaf) => {
      if (leaf.view instanceof CompuJudgeView)
        leaf.view.updateActiveFile(file);
    });
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    if (this.settings.temperature !== void 0 && this.settings.tempCritic === 0.1) {
      delete this.settings.temperature;
      await this.saveSettings();
    }
    this.settings.gradingColors = { ...DEFAULT_SETTINGS.gradingColors, ...this.settings.gradingColors };
    if (!this.settings.drives) {
      this.settings.drives = [];
    }
    if (this.settings.tempSynth === void 0) {
      this.settings.tempSynth = 1;
    }
    if (this.settings.namePool === void 0)
      this.settings.namePool = "";
    if (this.settings.negativeNamePool === void 0)
      this.settings.negativeNamePool = "";
    if (this.settings.enableAudio === void 0)
      this.settings.enableAudio = true;
    if (this.settings.audioVolume === void 0)
      this.settings.audioVolume = 0.5;
  }
  async saveSettings() {
    const cleanSettings = { ...this.settings };
    cleanSettings.projects = {};
    await this.saveData(cleanSettings);
    if (this.audio) {
      this.audio.setEnabled(this.settings.enableAudio);
      this.audio.setVolume(this.settings.audioVolume);
      this.audio.setTheme(this.settings.theme);
    }
    const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_COMPU_JUDGE);
    leaves.forEach((leaf) => {
      if (leaf.view instanceof CompuJudgeView) {
        leaf.view.settings = this.settings;
        leaf.view.updateTheme(this.settings.theme);
      }
    });
  }
};
var NigsSettingTab = class extends import_obsidian9.PluginSettingTab {
  constructor(app, plugin5) {
    super(app, plugin5);
    this.plugin = plugin5;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "BIOS SETUP" });
    new import_obsidian9.Setting(containerEl).setName("AI Provider").setDesc("Select your intelligence engine.").addDropdown((drop) => drop.addOption("gemini", "Google Gemini").addOption("openai", "OpenAI (ChatGPT)").addOption("anthropic", "Anthropic (Claude)").setValue(this.plugin.settings.aiProvider).onChange(async (val) => {
      this.plugin.settings.aiProvider = val;
      await this.plugin.saveSettings();
      this.display();
    }));
    containerEl.createEl("h4", { text: "Connection Settings" });
    if (this.plugin.settings.aiProvider === "gemini") {
      new import_obsidian9.Setting(containerEl).setName("Gemini API Key").addText((text2) => text2.setPlaceholder("AIzaSy...").setValue(this.plugin.settings.apiKey).onChange(async (val) => {
        this.plugin.settings.apiKey = val;
        await this.plugin.saveSettings();
      }));
      new import_obsidian9.Setting(containerEl).setName("Model ID").addText((text2) => text2.setPlaceholder("gemini-2.0-flash").setValue(this.plugin.settings.modelId).onChange(async (val) => {
        this.plugin.settings.modelId = val;
        await this.plugin.saveSettings();
      }));
    }
    if (this.plugin.settings.aiProvider === "openai") {
      new import_obsidian9.Setting(containerEl).setName("OpenAI API Key").addText((text2) => text2.setPlaceholder("sk-...").setValue(this.plugin.settings.openaiKey).onChange(async (val) => {
        this.plugin.settings.openaiKey = val;
        await this.plugin.saveSettings();
      }));
      new import_obsidian9.Setting(containerEl).setName("Model ID").addText((text2) => text2.setPlaceholder("gpt-4o").setValue(this.plugin.settings.openaiModel).onChange(async (val) => {
        this.plugin.settings.openaiModel = val;
        await this.plugin.saveSettings();
      }));
    }
    if (this.plugin.settings.aiProvider === "anthropic") {
      new import_obsidian9.Setting(containerEl).setName("Anthropic API Key").addText((text2) => text2.setPlaceholder("sk-ant-...").setValue(this.plugin.settings.anthropicKey).onChange(async (val) => {
        this.plugin.settings.anthropicKey = val;
        await this.plugin.saveSettings();
      }));
      new import_obsidian9.Setting(containerEl).setName("Model ID").addText((text2) => text2.setPlaceholder("claude-3-7-sonnet-20250219").setValue(this.plugin.settings.anthropicModel).onChange(async (val) => {
        this.plugin.settings.anthropicModel = val;
        await this.plugin.saveSettings();
      }));
    }
    containerEl.createEl("h4", { text: "Intelligence & Quality Control" });
    new import_obsidian9.Setting(containerEl).setName("AI Intelligence Level (Thinking)").setDesc("1 (Fast/Shallow) to 5 (Deep Thought/Slow). Modulates the amount of reasoning the AI performs.").addSlider((slider) => slider.setLimits(1, 5, 1).setValue(this.plugin.settings.aiThinkingLevel).setDynamicTooltip().onChange(async (val) => {
      this.plugin.settings.aiThinkingLevel = val;
      await this.plugin.saveSettings();
    }));
    new import_obsidian9.Setting(containerEl).setName("Default Target Quality").setDesc("The score (0-100) the AI should aim for when generating content (Wizard/Synthesizer default).").addSlider((slider) => slider.setLimits(0, 100, 5).setValue(this.plugin.settings.defaultTargetQuality).setDynamicTooltip().onChange(async (val) => {
      this.plugin.settings.defaultTargetQuality = val;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h4", { text: "Creativity Matrix (Temperature)" });
    const mult = this.plugin.settings.tempMultiplier;
    new import_obsidian9.Setting(containerEl).setName('Global Multiplier (The "Vibe" Slider)').setDesc("Multiplies all settings below. < 1.0 = Rigid, > 1.0 = Chaos.").addSlider((slider) => slider.setLimits(0.5, 2, 0.1).setValue(this.plugin.settings.tempMultiplier).setDynamicTooltip().onChange(async (val) => {
      this.plugin.settings.tempMultiplier = val;
      await this.plugin.saveSettings();
      this.display();
    }));
    containerEl.createEl("strong", { text: "Task-Specific Fine Tuning" });
    new import_obsidian9.Setting(containerEl).setName(`Critic (Analysis) - Effective: ${(this.plugin.settings.tempCritic * mult).toFixed(2)}`).setDesc("Low = Objective/Harsh. High = Creative Interpretation.").addSlider((slider) => slider.setLimits(0, 1, 0.05).setValue(this.plugin.settings.tempCritic).setDynamicTooltip().onChange(async (val) => {
      this.plugin.settings.tempCritic = val;
      await this.plugin.saveSettings();
    }));
    new import_obsidian9.Setting(containerEl).setName(`Wizard (Brainstorming) - Effective: ${(this.plugin.settings.tempWizard * mult).toFixed(2)}`).setDesc("High recommended for original ideas.").addSlider((slider) => slider.setLimits(0, 1.5, 0.05).setValue(this.plugin.settings.tempWizard).setDynamicTooltip().onChange(async (val) => {
      this.plugin.settings.tempWizard = val;
      await this.plugin.saveSettings();
    }));
    new import_obsidian9.Setting(containerEl).setName(`Synthesizer (Fusion) - Effective: ${(this.plugin.settings.tempSynth * mult).toFixed(2)}`).setDesc("Controls how aggressively the AI merges conflicting drives.").addSlider((slider) => slider.setLimits(0, 1.5, 0.05).setValue(this.plugin.settings.tempSynth).setDynamicTooltip().onChange(async (val) => {
      this.plugin.settings.tempSynth = val;
      await this.plugin.saveSettings();
    }));
    new import_obsidian9.Setting(containerEl).setName(`Architect (Structure) - Effective: ${(this.plugin.settings.tempArchitect * mult).toFixed(2)}`).setDesc("Balance between rigid structure and creative flow.").addSlider((slider) => slider.setLimits(0, 1.2, 0.05).setValue(this.plugin.settings.tempArchitect).setDynamicTooltip().onChange(async (val) => {
      this.plugin.settings.tempArchitect = val;
      await this.plugin.saveSettings();
    }));
    new import_obsidian9.Setting(containerEl).setName(`Repair (Editing) - Effective: ${(this.plugin.settings.tempRepair * mult).toFixed(2)}`).setDesc("Low recommended to preserve your voice.").addSlider((slider) => slider.setLimits(0, 1, 0.05).setValue(this.plugin.settings.tempRepair).setDynamicTooltip().onChange(async (val) => {
      this.plugin.settings.tempRepair = val;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h4", { text: "Name Pools (Character Generation)" });
    new import_obsidian9.Setting(containerEl).setName("Name Pool (Preferred Names)").setDesc("Comma-separated list of names the AI should prioritize when generating characters.").addTextArea((text2) => text2.setPlaceholder("e.g. Kael, Elara, Thorne, ...").setValue(this.plugin.settings.namePool).onChange(async (val) => {
      this.plugin.settings.namePool = val;
      await this.plugin.saveSettings();
    }));
    new import_obsidian9.Setting(containerEl).setName("Negative Name Pool (Banned Names)").setDesc("Comma-separated list of names the AI must NEVER use.").addTextArea((text2) => text2.setPlaceholder("e.g. Dave, Bob, ...").setValue(this.plugin.settings.negativeNamePool).onChange(async (val) => {
      this.plugin.settings.negativeNamePool = val;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h4", { text: "Safety & Constraints" });
    new import_obsidian9.Setting(containerEl).setName("Wizard Negative Constraints").setDesc("What should the AI explicitly AVOID generating? (Anti-Tropes)").addTextArea((text2) => text2.setPlaceholder("e.g. Talking Animals, Time Travel, Deus Ex Machina...").setValue(this.plugin.settings.wizardNegativeConstraints).onChange(async (val) => {
      this.plugin.settings.wizardNegativeConstraints = val;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h4", { text: "Hardware Settings" });
    new import_obsidian9.Setting(containerEl).setName("Max Output Tokens").setDesc("Limit the length of the AI response.").addText((text2) => text2.setValue(String(this.plugin.settings.maxOutputTokens)).onChange(async (val) => {
      const num = parseInt(val);
      if (!isNaN(num)) {
        this.plugin.settings.maxOutputTokens = num;
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian9.Setting(containerEl).setName("Analysis Cores (Critic)").setDesc("Parallel passes (1-10). Higher = Slower but more accurate averaging.").addSlider((slider) => slider.setLimits(1, 10, 1).setValue(this.plugin.settings.analysisPasses).setDynamicTooltip().onChange(async (val) => {
      this.plugin.settings.analysisPasses = val;
      await this.plugin.saveSettings();
    }));
    new import_obsidian9.Setting(containerEl).setName("Enable Tribunal (Multi-Agent Consensus)").setDesc("Uses 3 specialized agents (Market, Logic, Lit) instead of brute-force averaging. (More tokens, better quality).").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableTribunal).onChange(async (val) => {
      this.plugin.settings.enableTribunal = val;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h4", { text: "Grading Palette (Gradient Map)" });
    const colors2 = this.plugin.settings.gradingColors;
    new import_obsidian9.Setting(containerEl).setName("Critical (0-20%)").addColorPicker((col) => col.setValue(colors2.critical).onChange(async (v2) => {
      colors2.critical = v2;
      await this.plugin.saveSettings();
    }));
    new import_obsidian9.Setting(containerEl).setName("Poor (20-40%)").addColorPicker((col) => col.setValue(colors2.poor).onChange(async (v2) => {
      colors2.poor = v2;
      await this.plugin.saveSettings();
    }));
    new import_obsidian9.Setting(containerEl).setName("Average (40-60%)").addColorPicker((col) => col.setValue(colors2.average).onChange(async (v2) => {
      colors2.average = v2;
      await this.plugin.saveSettings();
    }));
    new import_obsidian9.Setting(containerEl).setName("Good (60-80%)").addColorPicker((col) => col.setValue(colors2.good).onChange(async (v2) => {
      colors2.good = v2;
      await this.plugin.saveSettings();
    }));
    new import_obsidian9.Setting(containerEl).setName("Excellent (80-90%)").addColorPicker((col) => col.setValue(colors2.excellent).onChange(async (v2) => {
      colors2.excellent = v2;
      await this.plugin.saveSettings();
    }));
    new import_obsidian9.Setting(containerEl).setName("Masterpiece (90%+)").setDesc("Also defines the 'God Mode' glow color.").addColorPicker((col) => col.setValue(colors2.masterpiece).onChange(async (v2) => {
      colors2.masterpiece = v2;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h4", { text: "System Override" });
    new import_obsidian9.Setting(containerEl).setName("Custom Critic Prompt").addTextArea((text2) => text2.setPlaceholder("You are a harsh literary critic...").setValue(this.plugin.settings.customSystemPrompt).onChange(async (val) => {
      this.plugin.settings.customSystemPrompt = val;
      await this.plugin.saveSettings();
    }));
    new import_obsidian9.Setting(containerEl).setName("Custom Archivist Prompt").addTextArea((text2) => text2.setValue(this.plugin.settings.customOutlinePrompt).onChange(async (val) => {
      this.plugin.settings.customOutlinePrompt = val;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h4", { text: "Visual Aesthetics" });
    new import_obsidian9.Setting(containerEl).setName("Theme").addDropdown((drop) => drop.addOption("win95", "Windows 95").addOption("msdos", "MS-DOS").addOption("auto", "Auto (System)").setValue(this.plugin.settings.theme).onChange(async (val) => {
      this.plugin.settings.theme = val;
      await this.plugin.saveSettings();
    }));
    new import_obsidian9.Setting(containerEl).setName("MS-DOS Text Color").addColorPicker((col) => col.setValue(this.plugin.settings.msDosColor).onChange(async (val) => {
      this.plugin.settings.msDosColor = val;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h4", { text: "Audio Subsystem" });
    new import_obsidian9.Setting(containerEl).setName("Enable Audio Engine").setDesc("Plays startup sounds and UI feedback.").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableAudio).onChange(async (val) => {
      this.plugin.settings.enableAudio = val;
      await this.plugin.saveSettings();
    }));
    new import_obsidian9.Setting(containerEl).setName("Audio Volume").addSlider((slider) => slider.setLimits(0, 1, 0.1).setValue(this.plugin.settings.audioVolume).setDynamicTooltip().onChange(async (val) => {
      this.plugin.settings.audioVolume = val;
      await this.plugin.saveSettings();
    }));
  }
};
